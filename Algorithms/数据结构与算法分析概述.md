### 数据结构与算法概述

#### 算法与数据图谱

*数据结构与算法图谱*

<img src="./Images/DataStructures/数据结构和算法图谱.jpg" style="zoom:75%;" />

* 数据结构是为算法服务的，算法要作用在特定的数据结构之上。无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构
* 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是无用的。

#### 数据结构分类

从直接前继和直接后继个数的维度来分：

##### 线性结构

0 至 1 个直接前继和直接后继。当线性结构非空时，有唯一的首元素和尾元素，其他所有元素都有唯一的直接前继和直接后继

###### 数组

用一组连续的内存空间，来存储一组具有相同类型的数据。数组能保证随机访问 O(1) 时间复杂度，查找的时间复杂度 O(logn)，修改为 O(n)

###### 队列

First-In First Out，先进先出，是一种访问受限的线性表结构，支持在队列尾部插入元素，在队列头部删除元素，入队出队时间复杂度为 O(1)

* 顺序队列

  用数组实现的队列

* 链式队列

  用链表实现的队列

* 循环队列

  收尾相连，形成一个环

* 双端队列

  队头队尾都支持入队出队的队列

###### 链表

不需要连续内存空间，通过指针将一组零散的内存块串联起来使用，随机访问时间复杂度为 O(n)，修改为 O(1)，链表本身没有大小限制，支持动态扩容。

* 单链表

  head 节点指针记录链表的基地址，通过 next 指针将节点串联起来，tail 节点的 next 指针指向 null

* 循环链表

  特殊的单链表，tail 节点 next 指针指向 head 节点

* 双向链表

  节点新增了 prev 指针指向上一个节点

哨兵机制

对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。引入哨兵节点，在任何时候，不管链表是否为空，head 指针都会一直指向这个哨兵节点。这个带有哨兵节点的链表为带头链表，没有哨兵结点的链表为不带头链表

###### 栈

Last-In First-Out，后进者先出，先进者后出，是一种访问受限的线性表结构，只允许在一端插入和删除数据，只涉及一端几个数据，时间空间复杂度均为 O(1)

##### 树性结构

###### 树的定义

树由节点和边连接组成，是一种非线性的数据结构。除了根节点外的节点有且仅有一条执行自己的边。这个边的方向代表了父节点指向了子节点。

0 至 1 个直接前继和 0 至 n 个直接后继（n 不小于 2）

树是一种常用的数据结构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的这些节点中。最顶层只有一个节点，称为根节点。

在分支处有一个节点，指向多个方向，如果某节点下方没有任何分叉的话，就是叶子节点。

* 节点高度

  <u>从某节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的高度</u>

* 节点深度

  <u>从根节点出发，到某节点边的条数，称为该节点的深度</u>

树结构特点

* 一个节点，即只有根节点，也可以是一棵树
* 其中任何一个节点与下面所有节点构成的树称为子树
* 根节点没有父节点，而叶子节点没有子节点
* 除根节点外，任何节点有且仅有一个父节点
* 任何节点可以有 0 ～ n 个子节点

###### 树的编程实现

树的实现方式有很多种，常见是基于链表和数组。

*   基于链表的实现一般是每个节点类型维护一个子节点指针和一个指向兄弟节点的链表（左孩子兄弟链表法）

    ```java
    class TreeNode {
    	Data data;
    	LinkedList siblings;
    	TreeNode left_child;
    }
    ```

*   基于数组的实现方式是每个节点维护一个包含它所有子节点的数组（孩子数组法）

    ```java
    class TreeNode {
    	Data data;
    	ArrayList children;
    }
    ```

###### 二叉查找树

二叉查找树又称二叉搜索树二叉排序树

对任意节点说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的往左边走，大于节点值的往右边走，直到找到目标数据或者到达叶子节点还未找到

遍历所有节点的常用方式有三种：前序遍历、中序遍历、后序遍历

在任何递归子树中，左节点一定在右节点之前先遍历，前序、中序、后序仅指根节点在遍历时的位置顺序。

前序遍历的顺序是根节点，左节点，右节点；

中序遍历的顺序是左节点，根节点，右节点

后序遍历的顺序是左节点，右节点，根节点

###### AVL 树

平衡二叉树，增加和删除节点后通过树形旋转重新达到平衡。

右旋以某个节点为中心，将它沉人当前右子节点的位置，而让当前的左子节点作为新树的根节点，即顺时针旋转；

左旋是以某个节点为中，将它沉入当前左子节点的位置，而让当前右子节点作为新树的根节点，即逆时针旋转

AVL 树就是通过不断旋转来达到树平衡的

树的左右高度差不能超过 1

任何往下递归的左子树与右子树，必须符合第一条性质

没有任何节点的空树或只有根节点的树也是平衡二叉树

###### 红黑树

和 AVL 树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自身平衡的，从而获得较高的查找性能。红黑树并不追求所有递归子树的高度差不超过 1，而是保证从根节点到叶子节点的最长路径不超过最短路径的 2 倍，所以它的最坏运行时间也是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除操作后的自平衡调整。

红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件

1. 节点只能是红色或黑色
2. 根节点必须是黑色
3. 所有 NIL 节点都是黑色（NIL，即叶子节点下挂的两个虚节点）
4. 一条路径上不能出现相邻的两个红色节点
5. 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点

如果一个树的左子节点或右子节点不存在，则均认定为黑色。红黑树的任何旋转在 3 次内均可完成。

红黑树的平衡性并不如 AVL 树，它维持的只是一种大致上的平衡，并不严格保证左右子树的高度差不超过 1。在相同节点数的情况下，红黑树的高度可能更高，平均查找次数会高于相同情况下的 AVL 树，红黑树的高度可能更高，平均查找次数会高于相同情况下的 AVL 树。在插入时，红黑树和 AVL 树都能在至多两次旋转内恢复平衡。在删除时，由于红黑树只追求大致上的平衡，因此红黑树能在至多三次旋转内恢复平衡，而 AVL 树至多需要 O(logn) 次旋转。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差可能为 O(logn)，而红黑树每次向上回溯的步长为 2，回溯成本降低。面对频繁的插入和删除，红黑树更为合适；面对低频修改、大量查询时，AVL 树更为合适。

红黑树可以被理解成 order 为 4 的一种特殊 B 树，2-3-4 树（每个有子树的节点都只可能有两个，或者 3 个，或者 4 个子节点）

###### B 树

平衡树，B 树的每个节点可以存储多个数值，但是要求：

*   所有叶子节点的深度一样
*   非叶子节点只能存储 b - 1 到 2b - 1 个值
*   根节点最多存储 2b - 1 个值

##### 图结构

###### 图的定义

0 至 n 个直接前继和直接后继（n 不小于 2）

从数学规范上来讲一个图可以被定义成一个集合 G， G = (V,A) ，其中：

*   V 是图的节点集合

*   A ⊆ V × V 是节点与节点之间的连接的边，边可以是有向或者是无向的

图有两种常见的实现方式

*   邻接矩阵法

    基本思想是开一个超大的数组，用数组中间元素的 true/false 来表达边。存储的是边

*   邻接链表法

    把每一个节点所指向的点存储起来

###### 简单图

###### 多重图

###### 有向图

###### 无向图

##### 哈希结构

没有直接前继和直接后继。通过某种哈希函数将索引与存储的值关联起来。散列表用的是数组支持按照下标随机访问数据的特性，是数组的一种扩展，由数组演化而来，时间复杂度是 O(1)。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转为数组下标，从对应的数组下标的位置取数据

###### 散列冲突

当两个键通过散列函数求的值一致时即形成散列冲突，常用解决方法：

* 寻址法

  * 线性探测（Linear Probing）

    当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，寻找空闲位置插入

  * 二次探测（Quadratic Probing）

    类似线性探测，线性探测的步长为 1，二次探测的步长为原来的二次方；

  * 双重散列

    不仅要使用一个散列函数，使用一组散列函数，先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置

* 链表法  

  每个槽会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中，当插入的时候，只需要通过散列函数计算出对应散列槽位，将其插入到对应链表中

#### 递归

##### 编写递归代码

编写递归代码的关键在于**写出递推公式，找到终止条件**

违背以下三点都可能得到错误的结果或是低效的代码

* 递归总有一个最简单的情况--方法的第一条语句总是包含 return 的条件语句
* 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。

在实际的开发中，编写递归代码时：

* 要警惕堆栈溢出。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。但是这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性
* 可能会出现重复计算的问题。为了避免重复计算，可以通过一个数据结构（如散列表）来保存求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。

##### 理解递归

递归是一种应用非常广泛的算法，只要同时满足以下三个条件，就可以用递归来解决

* 一个问题的解可以分解为几个子问题的解

* 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

* 存在递归中止条件

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。

#### 复杂度分析

##### 什么是复杂度分析

* 数据结构和算法解决的是：如何让计算机以更快的时间、更省的空间来解决问题
* 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能
* 分别用时间复杂度和空间复杂度两个概念来描述性能问题，统称为复杂度
* 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系

##### 为什么要进行复杂度分析

* 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强
* 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本

##### 如何进行复杂度分析

###### 大 O 表示法

1. 来源，算法的执行时间与每行代码的执行次数成正比，用 T(n) = O(f(n)) 表示，其中 T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而 n 往往表示数据的规模

2. 时间复杂度，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，在做时间复杂度分析时忽略这些项

3. 常用分析法则

   1）单段代码看高频：比如循环

   2）多段代码取最大：一段代码中有单循环和多重循环，取多重循环的复杂度

   3）嵌套代码求乘积：比如递归、多重循环

   4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加

##### 复杂度级别

* 多项式量级

  O(1) 常数阶

  O(logn) 对数阶

  O(n) 线性阶

  O(nlogn) 线性对数阶：归并排序、快速排序时间复杂度都是 O(nlogn)

  O(n^2)   ：平方阶，O(n^3)：立方阶，O(n^k) k次方阶

* 非多项式量级

  O(2^n) 指数阶

  O(n!) 阶乘阶

##### 最好、最坏、平均、均摊情况时间复杂度

* 最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
* 最坏情况时间复杂福：在最糟糕的情况下，执行这段代码的时间复杂度
* 加权平均时间复杂度（期望时间复杂度）：用代码在所有情况下执行的次数的加权平均值表示
* 均摊时间复杂度：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度

