### 数据结构与算法概述

#### 算法与数据图谱

*数据结构与算法图谱*

![](../Images/DataStructures/数据结构和算法图谱.jpg)

* 数据结构是为算法服务的，算法要作用在特定的数据结构之上。无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构
* 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是无用的。

#### 数据结构分类

从直接前继和直接后继个数的维度来分：

##### 线性结构

0 至 1 个直接前继和直接后继。当线性结构非空时，有唯一的首元素和尾元素，其他所有元素都有唯一的直接前继和直接后继

###### 数组

用一组连续的内存空间，来存储一组具有相同类型的数据。数组能保证随机访问 O(1) 时间复杂度，查找的时间复杂度 O(logn)，修改为 O(n)

###### 队列

First-In First Out，先进先出，是一种访问受限的线性表结构，支持在队列尾部插入元素，在队列头部删除元素，入队出队时间复杂度为 O(1)

* 顺序队列

  用数组实现的队列

* 链式队列

  用链表实现的队列

* 循环队列

  收尾相连，形成一个环

* 双端队列

  队头队尾都支持入队出队的队列

###### 链表

不需要连续内存空间，通过指针将一组零散的内存块串联起来使用，随机访问时间复杂度为 O(n)，修改为 O(1)，链表本身没有大小限制，支持动态扩容。

* 单链表

  head 节点指针记录链表的基地址，通过 next 指针将节点串联起来，tail 节点的 next 指针指向 null

* 循环链表

  特殊的单链表，tail 节点 next 指针指向 head 节点

* 双向链表

  节点新增了 prev 指针指向上一个节点

哨兵机制

对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。引入哨兵节点，在任何时候，不管链表是否为空，head 指针都会一直指向这个哨兵节点。这个带有哨兵节点的链表为带头链表，没有哨兵结点的链表为不带头链表

###### 栈

Last-In First-Out，后进者先出，先进者后出，是一种访问受限的线性表结构，只允许在一端插入和删除数据，只涉及一端几个数据，时间空间复杂度均为 O(1)

##### 树性结构

0 至 1 个直接前继和 0 至 n 个直接后继（n 不小于 2）

##### 图结构

0 至 n 个直接前继和直接后继（n 不小于 2）

###### 简单图

###### 多重图

###### 有向图

###### 无向图

##### 哈希结构

没有直接前继和直接后继。通过某种哈希函数将索引与存储的值关联起来。散列表用的是数组支持按照下标随机访问数据的特性，是数组的一种扩展，由数组演化而来，时间复杂度是 O(1)。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转为数组下标，从对应的数组下标的位置取数据

###### 散列冲突

当两个键通过散列函数求的值一致时即形成散列冲突，常用解决方法：

* 寻址法

  * 线性探测（Linear Probing）

    当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，寻找空闲位置插入

  * 二次探测（Quadratic Probing）

    类似线性探测，线性探测的步长为 1，二次探测的步长为原来的二次方；

  * 双重散列

    不仅要使用一个散列函数，使用一组散列函数，先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置

* 链表法  

  每个槽会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中，当插入的时候，只需要通过散列函数计算出对应散列槽位，将其插入到对应链表中

#### 递归

##### 编写递归代码

编写递归代码的关键在于**写出递推公式，找到终止条件**

违背以下三点都可能得到错误的结果或是低效的代码

* 递归总有一个最简单的情况--方法的第一条语句总是包含 return 的条件语句
* 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。

在实际的开发中，编写递归代码时：

* 要警惕堆栈溢出。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。但是这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性
* 可能会出现重复计算的问题。为了避免重复计算，可以通过一个数据结构（如散列表）来保存求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。

##### 理解递归

递归是一种应用非常广泛的算法，只要同时满足以下三个条件，就可以用递归来解决

* 一个问题的解可以分解为几个子问题的解

* 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

* 存在递归中止条件

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。

#### 复杂度分析

##### 什么是复杂度分析

* 数据结构和算法解决的是：如何让计算机以更快的时间、更省的空间来解决问题
* 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能
* 分别用时间复杂度和空间复杂度两个概念来描述性能问题，统称为复杂度
* 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系

##### 为什么要进行复杂度分析

* 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强
* 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本

##### 如何进行复杂度分析

###### 大 O 表示法

1. 来源，算法的执行时间与每行代码的执行次数成正比，用 T(n) = O(f(n)) 表示，其中 T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而 n 往往表示数据的规模

2. 时间复杂度，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，在做时间复杂度分析时忽略这些项

3. 常用分析法则

   1）单段代码看高频：比如循环

   2）多段代码取最大：一段代码中有单循环和多重循环，取多重循环的复杂度

   3）嵌套代码求乘积：比如递归、多重循环

   4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加

##### 复杂度级别

* 多项式量级

  O(1) 常数阶

  O(logn) 对数阶

  O(n) 线性阶

  O(nlogn) 线性对数阶：归并排序、快速排序时间复杂度都是 O(nlogn)

  O(n^2)   ：平方阶，O(n^3)：立方阶，O(n^k) k次方阶

* 非多项式量级

  O(2^n) 指数阶

  O(n!) 阶乘阶

##### 最好、最坏、平均、均摊情况时间复杂度

* 最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
* 最坏情况时间复杂福：在最糟糕的情况下，执行这段代码的时间复杂度
* 加权平均时间复杂度（期望时间复杂度）：用代码在所有情况下执行的次数的加权平均值表示
* 均摊时间复杂度：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度

