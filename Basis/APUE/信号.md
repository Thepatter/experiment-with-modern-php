## 信号

每个信号以 3 个字符 `SIG` 开头，信号是软件中断。信号提供了一种处理异步事件的方法。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量（如 `errno`)来判断是否发送了一个信号，而是必须告诉内核：在此信号发生时，请执行下列操作。

在某个信号出现时，可以告诉内核按下列 3 种方式进行处理

* 忽略此信号：大多数信号都可以使用这种方式进行处理，但有两种信号却决不能被忽略 （`SIGKILL`, `SIGSTOP`),这两种信号不能被忽略是：它们向内核和超级用户提供了使进程终止或停止地可靠方法。另外，如果忽略某些由硬件异常产生地信号（非法内存引用或除0），则进程的运行行为是未定义
* 捕捉信号：通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行地处理，不能捕捉 `SIGKILL` 和 `SIGSTOP` 信号
* 执行系统默认动作，大多数信号地系统默认动作时终止该进程

### core 文件

在系统默认动作列，"终止+core" 表示在进程当前工作目录地 `core` 文件中复制了该进程地内存映像。大多数 `UNIX` 系统调试程序都使用 `core` 文件检查进程终止时地状态

下列条件下不产生 `core` 文件

* 进程是设置用户 ID 的，而且当前用户并非程序文件的所有者
* 进程是设置组 ID 的，而且当前用户并非该程序文件的组所有者
* 用户没有写当前工作目录的权限
* 文件已存在，而且用户对该文件设有写权限
* 文件太大。`core` 文件的权限通常是用户读/写

`unix` 系统信号

![](./apueImages/系统信号.png)

### 信号术语及语义

* **产生:** 当造成信号的事件发生时，为进程产生一个信号（或向一个进程发送一个信号）事件可以是硬件异常（如除0），软件条件（如 `alarm` 定时器超时），终端产生的信号或调用 `kill` 函数。当一个信号产生时，内核通常在进程表中以某种形式设置一个标志
* **递送:** 当对信号采取了这种动作（内核在进程表设置标志），即向进程递送了一个信号
* **未决的:** 在信号产生和递送之间的时间间隔内，即信号是未决的

进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时（而不是在产生该信号时），才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用 `sigpending` 函数来判定那些信号是设置为阻塞并处于未决状态的如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，`posix.1` 允许系统递送该信号一个或多次。如果递送该信号多次，即信号进行了排队。大多数UNIX系统只递送一次。

每个进程都有一个信号屏蔽字，它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则它当前是被阻塞的。进程可以调用 `sigprocmask` 来检测和更改当前信号屏蔽字。使用 `sigset_t` 数据类型表示

### kill 和 raise

`kill` 函数将信号发送给进程或进程组。`raise` 函数则允许进程向自身发送信号。进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户，其基本规则是发送者的实际用户 ID 或有效用户 ID必须等于接收者的实际用户 ID 或有效用户 ID。如果实现支持 `_POSIX_SAVED_IDS` 则检查接收者的保存设置用户ID（而不是有效用户 ID)，如果被发送的信号是 `SIGCONT`,则进程可将它发送给属于同一会话的任一其他进程。

```c
#include <signal.h>
int kill(pid_t pid, int signo);
int raise(int signo);		// 两个函数返回值，成功返回0，出错，返回 -1
```

`raise(signo)` 等价于 `kill(getpid(), signo)`

`kill` 的 `pid` 参数有以下 4 种不同的情况

* `pid > 0` 	将该信号发送给进程 ID 为 `pid` 的进程
* `pid == 0`    将该信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组 ID 等于发送进程的进程组 ID），而且发送进程具有权限向这些进程发送信号。
* `pid < 0`   将该信号发送给其进程组 ID 等于 `pid` 的绝对值，而且发送进程具有权限向其发送信号的所有进程。
* `pid == -1` 将该信号发送给发送进程有权限向它们发送信号的所有进程

### alarm 和 pause

使用 alarm 函数可以设置一个定时器（闹钟时间），在将来的某个时刻决定该定时器会超时。当定时器超时时，产生 `SIGALRM` 信号。如果忽略或不捕捉此信号，则其默认动作是终止调用该 `alarm` 函数的进程

```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds) // 返回值：0或以前设置的闹钟时间的余留秒数
```

参数 `seconds` 的值是产生 `SIGALRM` 需要经过的时钟秒数。当这一时刻到达时，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。每个进程只能有一个闹钟时间。如果在调用 `alarm` 时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次 `alarm` 函数调用的值返回。以前注册的闹钟时间则被新值代替。如果有以前注册的尚未超过的闹钟时间，而且本次调用的 `seconds` 值是 0，则取消以前的闹钟时间，其余留值仍作为 `alarm` 函数的返回值

虽然 `SIGALRM` 的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。如果此时进程要终止，则在终止之前它可以执行所需的清理操作。如果想捕捉 `SIGALRM` ,则必须在调用 `alarm` 之前安装该信号的处理程序。如果我们先调用 `alarm` ，然后在我们能够安装 `SIGALRM` 处理程序之前已接到该信号，那么进程将终止。

`pause` 函数使调用进程挂起直至捕捉到一个信号

```c
#include <unistd.h>
int pause(void)			// 返回值： -1，errno 设置为 ETNTR
```

只有执行了一个信号处理程序并从其返回时，`pause` 才返回。在这种情况下，`pause` 返回 -1，`errno` 设置为 `EINTR`

### `sleep`, `nanosleep` `clock_nanosleep`

```c
#include <unistd.h>
unsigned int sleep(unisgned int seconds);
```

此函数使调用进程被挂起直到满足下面两个条件之一

* 已经过了 `seconds` 所指定的墙上时钟时间。返回值 0
* 调用进程捕捉到一个信号并从信号处理程序返回，返回未休眠完的秒数（所要求的时间减去实际休眠时间）

### `sinqueue`

通常一个信号带有一个位信息：信号本身。除了对信号排队以外，这些扩展允许应用程序在递交信号时传递更多的信息。这些信息嵌入在 `siginfo` 结构中。除了系统提供的信息，应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针。使用排队信号必须做以下几个操作：

* 使用 `sigaction` 函数安装信号处理程序时指定 `SA_SIGINFO` 标志。如果没有给出这个标志，信号会延迟，但信号是否进入队列要取决于具体实现

* 在 `sigaction` 结构的 `sa_sigaction` 成员中（而不是普通的 `sa_handler` 字段）提供信号处理程序。实现可能允许用户使用 `sa_handler` 字段，但不能获取 `sigqueue` 函数发送出来的额外信息

* 使用 `sigqueue` 函数发送信号

  ```c
  # include <signal.h>
  // 返回值：若成功，返回 0； 若出错，返回 -1
  int sigqueue(pid_t pid, int signo, const union sigval value);
  ```

  `sigqueue` 函数只能把信号发送给单个进程，可以使用 `value` 参数向信号处理程序传递整数和指针值，除此之外，`sigqueue` 函数与 `kill` 函数类似。信号不能被无限排队。到达相应的限制后，`sigqueue` 就会失败，将 `error` 设为 `EAGAIN`

### 作业控制信号

`POSIX.1` 认为以下 6 个与作业控制有关

* `SIGCHLD`  子进程已停止或终止
* `SIGCONT`   如果进程已停止，则使其继续运行
* `SIGSTOP`    停止信号（不能被捕捉或忽略）
* `SIGTSTP`     交互式停止信号
* `SIGTTIN`     后台进程组成员读控制终端
* `SIGTTOU`     后台进程组成员写控制终端

除 `SIGCHLD` 以外，大多数应用程序并不处理这些信号，交互式 `shell` 则通常会处理这些信号的所有工作。当键入挂起字符（通常是 `Ctrl+Z`) 时，`SIGTSTP` 被送至前台进程组的所有进程。当我们通知 `shell` 在前台或后台恢复运行一个作业，`shell` 向该作业中的所有进程发送 `SIGCONT` 信号。与此类似，如果向一个进程递送了 `SIGTTIN` 或 `SIGTTOU` 信号，则根据系统默认的方式，停止此进程，作业控制 `shell` 了解这一点后就通知我们。在作业控制信号间有某些交互。当对一个进程产生 4 种停止信号 （`SIGTSTP`, `SIGSTOP`, `SIGTTIN`, `SIGTTOU`) 中的任意一种时，对该进程的任一未决 `SIGCONT` 信号就被丢弃。与此类似，当对一个进程产生 `SIGCONT` 信号时，对同一进程的任一未决停止信号被丢弃。如果进程是停止的，则 `SIGCONT` 的默认动作是继续该进程；否则忽略此信号。通常，对该信号无需做任何事情。当对一个停止的进程产生一个 `SIGCONT` 信号时，该进程就继续，即使该信号是被阻塞或忽略的也是如此。