## 文件 I/O

### 文件描述符

对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读写一个文件时，使用 open 或 create 返回的文件描述符标识该文件，将其作为参数传送给 read 和 write,文件描述符的变化范围是 `0-OPEN_MAX-1` 

### 文件共享

`unix` 系统支持在不同进程间共享打开文件。内核使用 3 种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程产生的影响

1.每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每个描述符占用一项。与每个文件描述符相关联的是

a.文件描述符标志

b.指向一个文件表项的指针

2.内核为所有打开文件维持一张文件表。每个文件表项包含

a.文件状态标志（读，写，添写，同步和非阻塞）

b.当前文件偏移量

c.指向该文件 v 节点表项的指针

3.每个打开文件（或设备）都有一个 （v-node) 结构。包含文件类型和对此文件进行各种操作函数的指针。对于大多少文件，v 节点还包含该文件的 i 节点（i-node).这些信息是在打开文件时从磁盘读入内存的

进程对应的三张表之间的关系。（该进程有两个不同的打开文件，一个文件从标准输入打开，另一个从标准输出打开）

![](打开文件的内核数据结构.png)

两个独立进程各自打开了同一文件

![](两个独立进程打开同一文件.png)

### 文件类型

`unix` 系统大多数文件时普通文件或目录。文件类型包含

- **普通文件：**这种数据是文本还是二进制数据，对 `unix` 内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行
- **目录文件:**这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。
- **块特殊文件:**这种类型的文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行
- **字符特殊文件：**这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件
- **FIFO:** 命名管道。用于进程间通信
- **套接字：**用于进程间的网络通信，也可以用于在一台主机上进程之间的非网络通信
- **符号连接：**这种类型的文件指向另一个文件。

### 设置用户 ID 和设置组 ID

与一个进程相关联的 ID有６个

- **实际用户 ID 和实际组 ID：**取自口令文件中的登录项，标识我们究竟是谁。通常在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们。
- **有效用户ID，有效组ID，附属组ID：**决定了我们的文件访问权限
- **保存的设置用户ID和保存的设置组ID:** 在执行一个程序时包含了有效用户ID和有效组ID的副本

### 新文件和目录的所有权

- 新文件或目录的用户 ID 设置为进程的有效用户 ID。
- 新文件或目录的组 ID 可以是它所在目录的组 ID
- 新文件或目录的组 ID 可以是它所在目录的组 ID

### 流和 FILE 对象

对于 I/O 函数是围绕文件描述符的，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的 I/O 操作。而对于标准 I/O 库，它们的操作时围绕流（stream) 进行的。当用标准 I/O 库打开或创建一个文件时，就已使一个流与一个文件相关联。

对于 ASCII 字符集，一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准 I/O 文件流可用于单字节或多字节字符集。流的定向决定了所读，写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。若在未定向的流上使用一个多字节 I/O 函数，则将该流定义设置未宽定向的。若在未定向的流上使用一个单字节 I/O 函数，则将该流的定向设未字节定向的。

### 缓冲

标准 I/O 库提供缓冲的目的是尽可能减少使用 read 和 write 调用的次数。它也对每个 `I/O` 流自动地进行缓冲管理，标准 I/O 提供 3 种类型地缓冲

* **全缓冲：**在这种情况下，在填满标准 I/O 缓冲区后才进行实际 I/O 操作。对于驻留在磁盘上的文件通常是由标准 I/O 库实施全缓冲。在一个流上执行第一次 I/O 操作时，相关标准 I/O 函数通常调用 `malloc` 获得需使用的缓冲区
* **行缓冲:** 在这种情况下，当在输入和输出种遇到换行符时，标准 I/O 库执行 I/O 操作。这允许我们一次输出一个字符（用标准I/O 函数 `fputc`）但只有在写了一行之后才进行实际 I/O 操作。当流涉及一个终端时，通常使用行缓冲。行缓冲有两个限制。第一，因为标准 I/O 库用来收集每一行的缓冲区的长度时固定的。只要填满了缓冲区，即使还没有写一个换行符，也进行 I/O 操作。第二，任何时候只要通过标准 I/O 库要求从一个不带缓冲的流，或者一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流。
* **不带缓冲：**标准 I/O 库不对字符进行缓冲存储。

### 缓冲特征

* 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的

* 标准错误决不会时全缓冲的

* 标准错误是不带缓冲的

* 若是指向终端设备的流，则是行缓冲；否则是全缓冲
