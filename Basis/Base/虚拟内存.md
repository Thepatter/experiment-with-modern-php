# 虚拟内存

一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要大多的内存，那么它们中的一些根本就无法运行。当一个程序没有空间可用时，那就是它运气不好了，内存还很容易被破坏。如果某个进程不小心写了另一个进程使用的内存，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。

为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：

1. 它将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送，通过这种方式，它高效地使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏

虚拟内存是计算机系统最重要的概念之一。它成功的一个主要原因是它是沉默地、自动地工作，不需要应用程序员的任何干涉。

* 虚拟内存是核心的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。
* 虚拟内存是强大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片，将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。
* 虚拟内存是危险的。每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如 `malloc` 这样的动态分配程序时，它就会和虚拟内存发生交互。如果虚拟内存使用不当，应用将遇到复杂危险的与内存有关的错误。

### 物理和虚拟地址

计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address PA)。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，依次类推。给定这种简单的结构， CPU 访问内存的最自然的方式就是使用物理地址。即物理寻址。

早期的 PC 使用物理寻址，而且诸如数字信号处理器、嵌入式微控制器以及 Cray 超级计算机这样的系统仍然继续使用这种寻址方式。然而，现代处理器使用的是一种称为虚拟寻址的寻址形式。

*虚拟寻址流程*

![使用虚拟寻址](./Images/使用虚拟寻址.png)

使用虚拟寻址，CPU 通过生成一个虚拟地址（Virtual Address）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译（address translation)。就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上的内存管理单元（Memory Management Unit）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理

### 地址空间

地址空间（address space）是一个非负整数地址的有序集合：

如果地址空间中的整数是连续的，那么说它是一个线性地址空间。假设使用的是线性地址空间。在一个带虚拟内存的系统中，CPU 从一个有 N = 2 的 n 次方个地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space)

一个地址空间的大小是由表示最大地址所需要的位数来描述的。一个包含 N = 2 的 n 次方个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统通常支持 32 位或者 64 位虚拟地址空间

一个系统还有一个物理地址空间（physical address space)，对应于系统中物理内存的 M 个字节。M 不要求是 2 的幂。

地址空间的概念很重要，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种差别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个物理地址空间的物理地址

## Linux 虚拟内存系统

Linux 为每个进程维护了一个单独的虚拟地址空间，如下图

![Linux进程的虚拟内存](./Images/Linux进程的虚拟内存.png)

* 内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。每个进程共享内核的代码和全局数据结构。有趣的是，`lunux` 也将一组连续的虚拟页面（大小等于系统 DRAM 的总量）映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法来访问物理内存中任何特定的位置。