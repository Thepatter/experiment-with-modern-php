####寄存器
一个 x86-64 的 cpu 包含一组 16 个存储 64 位值的**通用目的的寄存器,这些寄存器用来存储整数数据和指针,以 %r 开头 16位寄存器 %ax 到 %bp, 32位寄存器
 %eax 到 % ebp,64位寄存器标号为 %rax 到 %rbp,64位还新增 8 个寄存器: %r8 到 %r15!栈指针 %rsp,用来指明运行时候栈的结束位置**
 ####压入和弹出栈数据
 栈在处理过程中起到至关重要的作用.栈是一种数据结构,可以添加或者删除值,遵循"后进先出"的原则,通过 push 操作把数据压入栈中,通过 pop 操作删除数据.弹出的
 值永远是最近被压入而且仍然在栈中的值,栈可以实现位一个数组,总是从数组的一端插入和删除元素,这一端为栈顶,在 x86-64 中,程序栈存放在内存中某个区域.栈向下
 增长,栈顶元素的地址是所有栈中元素地址中最低的,栈指针 %rsp 保存着栈顶元素的地址,在 x86-64 中,栈向低地址方向增长,所以压栈是减少栈指针(寄存器 %rsp)的值,
 并将数据存放到内存中,而出栈是从内存中读数据,并增加栈指针的值.
 ####数据对齐
 计算机系统对基本数据类型的合法地址做出了一些限制,要求某种类型对象的地址必须是某个值 k (通常是2,4或8)的倍数.这种对齐限制简化了形成处理器和内存系统之间
 接口的硬件设计.对齐原则是任何 k 字节的基本对象的地址必须是 k 的倍数.
####过程
过程是软件中一种很重要的抽象，提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。然后，可以在程序中不同的地方调用这个函数。设计良
好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是那些值。过程的形式包括，函数，方法，子例程，处理函数。共同
特性有：
P 调用过程 Q， Q 执行后返回到 P。这个动作包括下面一个或多个机制。 
**传递控制**：在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址。然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
**传递数据**：P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
**分配和释放内存**：在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。
C 语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。在过程 p 调用过程 Q 中，当 Q 在执行时，P 以及所有在向上追朔到
P 的调用链中的过程，都是暂时被挂起的。当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。当 Q
返回时，任何它所分配的局部存储空间都可以被释放。程序可以用栈来管理它的过程所需要的存储空间,栈和程序寄存器存放着传递控制和数据，分配内存所需的信息。当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会被释放掉。**x86-64 的栈向低地址方向增长。栈指针 %rsp 指向栈顶元素。可以用 pushq 和 popq 指令将数据存入栈中或是从栈中取出。将栈指针减少一个适当的量可以为没有指定初始值的数据在栈上分配空间。增加栈指针来释放空间。当 x86-64 过程需要的存储空间超出寄存器能哦存放的大小时，就会在栈上分配空间。这个部分为过程的栈帧**

转移控制：将控制从函数 P 转移到函数 Q 只需把程序计数器(PC)设置为 Q 的代码的起始位置。当从 Q 返回的时候，处理器必须记录好它需要继续 P 的执行的代码位置。在 x86-64 机器中，这个信息是用指令 call Q 调用过程 Q 来记录的。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令 ret 会从栈中弹出地址 A，并把 PC 设置为 A。

数据传送，当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能返回一个值。x86-64 中，大部分过程间的数据传送是通过寄存器实现的。x86-64中，可以通过寄存器最多传递 6个整型(整数或指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。

根据参数在参数列表中的顺序分配寄存器，如果第一个参数是32位，可以用 %edi 来访问。超出6个部分要通过栈来传递。

| 操作数大小 | 参数数量 |                   |      |      |      |      |
| :---: | :--: | :---------------: | :--: | :--: | :--: | :--: |
|       |  1   |         2         |  3   |  4   |  5   |  6   |
|  64   | %rdi |       %rsi        | %rdx | %rcx | %r8  | %r9  |
|  32   | %edi |       %esi        | %edx | %ecx | %r8d | %r9d |
|  16   | %di  |        %si        | %dx  | %cx  | %r8w | %r9w |
|   8   | %dil | $sil | %dl  | $cl | %r8b | %r9b |      |      |

栈上局部存储。有些时候，局部数据必须存放在内存中。常见的情况包括：

**寄存器不足够存放所有的本地数据**

**对一个局部变量使用地址运算符 '&' ,因此必须能够为它产生一个地址。**

**某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。**

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，**x86-64采用了一组统一的寄存器使用惯例，所有的过程包括程序库都必须遵循**

寄存器%rbx, %rbp 和 %r12~%r15被划分为被调用者保存寄存器。当过程 p 调用过程 q 时，q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的，过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为 “保存的寄存器” 的一部分。P 的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上),调用 Q,然后继续使用寄存器中值，不用担心值被破坏。**除了栈指针%rsp,都分类为调用者保存寄存器,意味着任何函数都能修改他们。过程 P 在某个此类寄存器中有局部数据，然后调用过程 Q。因为 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 p (调用者)的责任。x86-64过程能够递归的调用它们自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。**递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间，如果需要，它还可以提供局部变量的存储。

##### 数组分配和访问

C语言中数组是一种将标量数据聚集成更大数据类型的方式。C 语言可以产生指向数组中元素的指针，并对这些指针进行运算，在机器代码中，这些指针会被翻译成地址计算。对于数据类型 T 和整型常数 N，声明：T A[N]';

起始位置表示为 x.这个声明有两个效果。它在内存中分配一个 L · N 字节的连续区域，这里 L 是数据类型 T 的大小（单位为字节）。引入了标识符 A，可以用 A 来作为指向数组开头的指针，这个指针的值就是x。可以用0~N-1的整数索引来访问该数组元素。数组元素 i 会被存放在地址为 x + L · i 的地方。

x86-64的内存引用指令可以用来简化数组访问。假设 E 是一个 int 型的数组，而计算 E[i],E 的地址存放在寄存器 %rdx中，而 i 存放在寄存器 %rcx 中。指令 movl (%rdx,%rcx,4),%eax。会执行地址计算 x + 4i.读这个内存的值，并将结果存放到寄存器 %eax中。

**指针运算**

C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。如果 p 是一个指向类型为 T 的数据的指针，p 的值为 x, 那么表达式 p+i 的值为 x+ L · i，这里 L 是数据类型 T 的大小。**单操作数操作符 & 和 * 可以产生指针和间接指针。对于一个表示某个对象的表达式 Expr，&Expr 是给出该对象地址的一个指针。对于一个表示地址的表达式 AExpr, *AExpr 给出该地址处的值。表达式 Expr 与 * &Expr 是等价的。可以对数组和指针应用数组下标操作，数组引用 A[i] 等同于表达式 * (A + i),它计算第 i 个数组元素的地址，然后访问这个内存位置。计算同一个数据结构中的两个指针之差，结果的数据类型为 long,值等于两个地址之差除以该数据类型的大小。

嵌套的数组，`int A[5][3]` 等价于 `typedef int row3_t[3] row3_t A[5]` 数据类型 row3_t 被定义为一个 3 个整数的数组。数组 A 包含 5个这样的元素。 

变长数组。C 语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）程序员需要变长数组时不得不用 malloc 或 calloc 这样的函数为这些数组分配存储空间，而且不得不显示地编码，用行优先索引将多维数组映射到一维数组，ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。 

变长数组的 C 版本中，我们可以将一个数组声明如下：`int A[expr1][expr2]` 它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式 expr1 和 expr2 求值来确定数组的维度。要访问 n X n 数组的元素i，j的函数：

```
int var_ele(long n, int A[n][n], long i, long j) {
  	return A[i][j];
}
```

#### 异质的数据结构

C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：结构(structure) ，用关键字struct 来声明，将多个对象集合到一个单位中；联合(union)，用关键字 union 来声明，允许用几种不同的类型来引用一个对象。

__结构__：C 语言的 struct 声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，知识每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

```c
struct rect {
  	long llx;
  	long lly;
  	unsigned long width;
  	unsigned long height;
  	unsigned color;
}
```

声明一个 struct rect 类型的变量 r,并将它的字段值设置如下：

```c
struct rect r;
r.llx = r.lly = 0;
r.color = 0xFFOOFF;
r.width = 10;
r.height = 20;
```

既声明变量又初始化它的字段

`struct rect r = {0, 0, 10, 20, 0xFFOOFF}`

将指向结构的指针从一个地方传递到另一个地方，而不是复制它们

```
long area(struct rect *rp) {
  	return (*rp).width * (*rp).height;
}
```

表达式 (*rp).width 间接引用了这个指针，并且选取所得结构的 width 字段。

**联合**:联合提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象，联合声明的语法与结构的语法一样，只不过语义相差比较大，它们是用不同的字段来引用相同的内存块。一个联合的总的大小等于它最大字段的大小。

### 指针

指针是 C 语言的一个核心特色。它们以一种统一的方式，对不同数据结构中的元素引用。指针映射到机器代码的原则：

**每个指针都对应一个类型。这个类型表明指针指向的是哪一类对象** `int *ip char **cpp` 变量 ip 是一个指向 int 类型对象的指针，而 cpp 指针的对象自身就是一个指向 char 类型对象的指针。如果对象类型为 T,那么指针的类型为 T * 。特殊的 void * 类型代表通用指针。malloc 函数返回一个通用指针，然后通过显示强制类型转换或者赋值操作那样的 隐式强制类型转换，将它转换成一个有类型的指针。指针类型不是机器代码中的一部分。它们是 C 语言提供的一种抽象，帮组程序员避免寻址错误。

**每个指针都有一个值** 这个值是某个指定类型的对象的地址。特殊的 NULL(0)值表示该指针没有指向任何地方。

指针用 '&' 运算符创建。这个运算符可以应用到任何 lvalue 类的 C 表达式（lvalue 指可以出现在赋值语句左边的表达式，包括变量以及结构，联合和数组的元素), leaq 指令是设计用来计算内存引用的地址，& 运算符的机器代码实现常常用这条指令来计算表达式的值。

*操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致，间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么从指定的地址读取。

* 数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用(例如a[3])与指针运算和间接引用(* (a+3))有一样的效果。数组引用和指针运算都要对对象大小偏移量伸缩。`p + i` 指针 p 的值为 p, 得到的地址计算为 P + L · i，这里 L 是 P 相关联的数据类型的大小。
* 将指针从一种类型强制转为成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。例如，如果 P 是一个 char * 类型的指针，它的值为 p,那么