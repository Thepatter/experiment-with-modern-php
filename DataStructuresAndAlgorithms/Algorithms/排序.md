## 常用数组排序

### 分析排序算法

#### 排序算法的执行效率

对于排序算法执行效率的分析，一般会从这几个方面来衡量：

* 最好情况、最坏情况、平均情况时间复杂度
  对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定有影响的，要考虑排序算法在不同数据下的性能表现

* 时间复杂度的系数、常数、低阶
  时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，在对同一阶时间复杂度的排序算法性能对比的时候，要把系数、常数、低阶也考虑进来

* 比较次数和交换次数
  基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交互或移动。在分析排序算法的执行效率的时候，应该把比较次数和交换次数也考虑进去

#### 排序算法的内存消耗

针对排序算法的空间复杂度，有一个新的概念，原地排序（Sorted in place)。原地排序算法，是特指空间复杂度是 `O(1)` 的排序算法

#### 排序算法的稳定性

针对排序算法，还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

如果有一组数据：2，9，3，4，8，3。按照大小排序之后就是：2，3，3，4，8，9。这组数据里有两个三。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那么这种排序算法即是**稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法即是**不稳定的排序算法**

#### 有序度

有序度是数组中具有有序关系的元素对的个数。有序元素对用数据表达式是：
```
如果 i < j，则有序元素对：a[i] <= a[j]
```
完全有序的数组的有序度叫做满有序度，计算公式：`n*(n-1)/2`
逆序度：满有序度 - 有序度
排序的过程即增加有序度，减少逆序度的过程，最后达到满有序度，即排序完成

### 冒泡排序 （Bubble Sort)

#### 概述

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元数移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作

* 冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 `O(1)`，是一个原地排序算法
* 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序。是稳定的排序算法
* 冒泡排序的时间复杂度是：最好情况下，待排序的数据已经是有序的，只需要进行一次冒泡操作，就可以结束。即最好是 `O(n)`。而最坏的情况是，要排序的数据刚好是倒序排列的，需要进行 n 次冒泡操作，即最坏情况时间复杂度是 `O(n^2)`。平均情况下：假定有序度为一半， 需要 `n*(n-1)/4` 次交换操作，比较操作肯定比交换操作多，而复杂度的上限是 `O(n^2)`，所以平均情况下的时间复杂度是 `O(n^2)`

*冒泡排序*

```java
public void bubbleSort(int[] ints) {
    if (ints.length <= 1) {
        return;
    }
    for (int i = 0; i < ints.length; ++i) {
        boolean isExchange = false;
      	for (int l = i + 1; l < ints.length; ++l) {
            if (ints[i] > ints[l]) {
                int tmp = ints[i];
                ints[i] = ints[l];
                ints[l] = tmp;
                isExchange = true;
            }
        }
        if (!isExchange) {
            break;
        }
    }
}
```



### 插入排序 （Insertion Sort)

首先将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束

插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素往后移动一位，这样才能腾出位置给元素 a 插入。对于不同的查找插入点方法（从头到尾，从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

*插入排序*

```java
public void insertionSort(int[] ints) {
    if (ints.length <= 1) {
        return;
    }
    for (int i = 1; i < ints.length; ++i) {
        int tmp = ints[i];
        int j = i - 1;
        while (j >= 0) {
            if (ints[j] < tmp) {
                ints[j + 1] = ints[j];
            }
            --j;
        }
        ints[j + 1] = tmp;
    }
}
```
* 插入排序是原地排序，空间复杂度是 `O(1)`

* 插入排序是稳定排序，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变

* 插入排序的时间复杂度：如果要排序的数据已经是有序的，并不需要搬移任何数据。如果从尾到头在有序数据组里查找插入位置，每次只需要比较一个数据就能确定插入的位置。在这种情况下，最好是时间复杂度 `O(n)`; 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度 `O(n^2)`; 对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度 `o(n^2)`

冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，实现上，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要一个。

### 选择排序 （Selection Sort)

选择排序算法的实现思路类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾

* 选择排序空间复杂度为 `O(1)`，是一种原地排序算法。
* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 `O(n^2)`.
* 选择排序不是稳定的排序算法。如一组数据：`5,8,5,2,9`，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个  5 和中间的 5 顺序就变了，所以就不稳定了。正是如此，相对于冒泡排序和插入排序，选择排序应用较少

*选择排序*

```java
public static void selectionSort(int[] a) {
	if (a.length <= 1) {
        return;
    }
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[minIndex]) {
                minIndex = j;
            }
        }
        int tmp = a[i];
        a[i] = a[minIndex];
        a[minIndex] = tmp;
    }
}
```

### 归并排序 (Merge Sort)

如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了



