## 递归

### 编写递归代码

编写递归代码的关键在于**写出递推公式，找到终止条件**

违背以下任意三点都可能得到错误的结果或是低效的代码

* 递归总有一个最简单的情况--方法的第一条语句总是包含 `return` 的条件语句
* 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。

在实际的开发中，编写递归代码时，要警惕堆栈溢出。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。但是这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性; 使用递归时还会出现重复计算的问题。为了避免重复计算，可以通过一个数据结构（如散列表）来保存求解过的 `f(k)`。当递归调用到 `f(k)` 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。

*伪代码获取最终推荐人*

```java
long findRootReferrerId(long actorId) {
    Long referrerId = select referrer_id from table where actor_id = actorId;
    if (referrerId == null) {
		return actorId;
    }
    return findRootReferrerId(referrerId);
}
```

### 理解递归

递归时一种应用非常广泛的算法（或编程技巧），递归需要满足的三个条件。只要同时满足以下三个条件，就可以用递归来解决

* 一个问题的解可以分解为几个子问题的解

* 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

* 存在递归中止条件

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。


