## 散列

### 散列表

散列表用的是数组支持按照下标随机访问数据的特性，是数组的一种扩展，由数组演化而来，时间复杂度是 O(1)。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转为数组下标，从对应的数组下标的位置取数据

#### 散列函数

`hash(key)`，其中 key 表示元素的键值，`hash(key)` 的值表示经过散列函数计算得到的散列值，散列函数设计一般需要满足：

* 散列函数计算得到的散列值是一个非负整数
* 如果 key1 = key2，hash(key1) == hash(key2)
* 如果 key1 != key2，hash(key1) != hash(key2)

#### 散列冲突

再好的散列函数也无法避免散列冲突。常用的散列冲突解决方法有：

* 开放寻址法

  如果出现了散列冲突，重写探测一个空闲位置，将其插入。**线性探测（Linear Probing）**：当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，寻找空闲位置插入；**二次探测（Quadratic Probing）** 类似线性探测，线性探测的步长为 1，二次探测的步长为原来的二次方；**双重散列（Double hashing）**，不仅要使用一个散列函数，使用一组散列函数，先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。当散列表中空闲位置不多时，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位，用**装载因子（load factor）**来表示空位的多少。装载因子的计算公式："散列表的装载因子 = 填入表中元素个数 / 散列表的长度"，装载因子越大，空闲位置越少，散列表的性能会下降。

* 链表法

  链表法是更加常用的散列冲突解决办法，相比开放寻址法，它更加简单，在散列表中，每个桶（bucket）或槽（slot）会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 `O(1)`。查找、删除一个元素跟链表的长度 k 成正比。对于散列比较均匀的散列函数，理论上，k = n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数

  

