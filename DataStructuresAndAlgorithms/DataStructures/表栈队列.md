### 表、栈和队列

#### 抽象数据类型

ADT(abstract data type) 是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象；在 ADT 的定义中没有地方提到关于这组操作是如何实现的任何解释。诸如表、集合、图以及于它们各自的操作一起形成的这些对象都可以被看作是是抽象数据类型。

#### 表

形如：`A0，A1，A2，。。。，An-1` 。这个表大小是 N。大小为 0 的表为空表（empty list）。对于除空表外的任何表：元素都是连续的、元素 `Ai` 在表中位置为 `i+1`。

要在表 ADT 上进行操作的集合：

* `printList` 

  打印表

* `makeEmpty`

  创建一个空表

* `find`

  返回某一项首次出现的位置

* `insert`

  从表的某个位置插入

* `remove`

  从表的某个位置删除

* `findKth`

  返回指定位置的元素

##### 表的数组实现

对表的所有操作都可以通过使用数组来实现：`print` 以线性时间被执行；`findKth` 以常数时间执行，而插入和删除平均需要线性时间。

##### 简单链表

为了避免插入和删除的线性开销，需要保证表可以不连续存储，否则表的每个部分可能都需要整体移动。链表由一系列节点组成，这些节点不必在内存中相连。每一个节点均含有表元素和包含该元素后继元的节点的链（link），即 next 链，最后一个单元的 next 链引用 null。insert 和 remove 只需要常数时间，printList，find 需要线性时间。

##### Java Collections API 中的表

Java 语言包含有一些普通数据结构的实现。表 ADT 是在 Collection API 中实现的数据结构之一。

`Collections API` 位于 `java.util` 包中。集合（collection）的概念在 Collection 接口中得到抽象，它存储一组类型相同的对象。`Collection` 接口扩展了 `Iterable` 接口。实现 `Iterable` 接口的那些类可以拥有增强的 for 循环，该循环施于这些类之上以观察它们的所有项。

实现 `Iterator` 接口的集合必须提供一个称为 `iterator` 方法，该方法返回一个 `Iterator` 类型的对象。该 `Iterator` 是一个在 `java.util` 包中定义的接口。

当直接使用 `Iterator`（而不是通过一个增强的 for 循环间接引用）时：如果对正在被迭代的集合进行结构上的改变（即对该集合使用 add、remove、clear），那么迭代器就不再合法（并且在其后使用该迭代器时将会有 `ConcurrentModificationException` 异常被抛出），只有在需要立即使用一个迭代器的时候，才应该获取迭代器。如果迭代器调用了它自己的 `remove` 方法，那么这个迭代器仍然合法。

`List` 是由 `java.util` 包中的 `List` 接口指定，`List` 接口继承了 `Collection` 接口。List ADT 有两种流行的实现方式。`ArrayList` 类提供 List ADT 的一种可增长数组的实现，`ArrayList` 的优点在于，对 `get` 和 `set` 的调用花费常数时间。缺点是新项的插入和现有项的删除代价昂贵，除非变动是在 `ArraryList` 的末端进行。`LinkedList` 类则提供了 `List ADT` 的双链表实现。优势是，新项的插入和现有项的删除均开销很小，这里假设变动项的位置是已知的。缺点是不容器作索引，因此对 `get` 的调用是昂贵的，除非调用非常接近表

