# 交给子类

## Template Method 模式(将具体处理交给子类)

__组成模版的方法被定义在父类中.由于这些方法是抽象方法,所有只查看父类的代码是无法知道这些方法最终会进行何种具体处理的,唯一能知道的就是父类是如何调用这些方法的.只要在不同的子类中实现不同的具体处理,当父类的模版方法被调用时程序行为也会不同.但不论子类中的具体实现如何,处理的流程都会按照父类中所定义的那些进行__

### Template Method 模式中的登场角色

* `AbstractClass` 抽象类: 负责实现模版方法,还负责声明在模版方法中所使用的抽象方法.这些抽象方法由子类

  `ConcreteClass` 角色负责实现

* `ConcreteClass` 具体类: 该角色负责具体实现 `AbstractClass` 角色中定义的抽象方法.这里实现的方法将会在 `AbstractClass` 角色的模版方法中被调用.

### Template Method 模式类图

![](C:\Users\work\IdeaProjects\some_book\DesignPatterns\ClassDiagram\TemplateMethod模式.png)

### 优点

父类的模版方法中编写了算法,因此无需在每个子类中再编写算法

父类与子类之间的协作.父类与子类的一致性,使用父类类型的变量保存子类实例.里氏替换,处理的流程被定义在父类中,而具体的处理则交给了子类

## Factory Method 模式(将实例的生成交给子类)

__父类决定实例的生成方式,但并不决定所要生成的具体的类,具体的处理全部交给子类负责.这样可以将实例的框架和实际负责生成实例的类解耦,父类这一方的 `Creator` 角色和 `Product` 角色的关系与子类这一方的 `ConcreteCreator` 角色和 `ConcreteProduct` 角色的关系是平行的__

### Factory Method 模式的类图

![](C:\Users\work\IdeaProjects\some_book\DesignPatterns\ClassDiagram\FactoryMethod.png)

### Factory Method 模式中的登场角色

* `Product` 产品角色属于父类这一方,是一个抽象类,定义了在 `Factory Method` 模式中生成的那些实例所持有的接口.但具体的处理则由子类 `ConcreteProduct` 角色决定
* `Create` 创建者角色属于父类这一方,它是负责生成 `Product` 角色的抽象类,但具体的处理则由子类 `ConcreteCreator` 角色决定
* `ConcreteProduct` 具体的产品角色属于具体加工这一方,它决定了具体的产品
* `ConcreteCreator` 具体的创建者角色属于具体加工的这一方,它负责生成具体的产品

### 生成实例的三种实现方式

* 指定其为抽象方法

  ```java
  abstract class Factory {
      public abstract Product createProduct(String name);
  }
  ```

* 为其实现默认处理(不能将 `product` 类定义为抽象类)

  ```java
  class Factory {
      public Product createProduct(String name) {
          return new Product(name);
      }
  }
  ```

* 在其中抛出异常,`createProduct` 方法的默认处理为抛出异常,这样,如果未在子类中实现该方法,程序会在运行时出错,需另外编写 `FactoryMethodRuntimeException` 异常类

  ```java
  class Factory {
      public Product createProduct(String name) {
          throw new FactoryMethodRuntimeException();
      }
  }
  ```
