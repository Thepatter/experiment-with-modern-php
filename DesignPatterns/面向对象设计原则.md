## 面向对象设计六大原则

### 单一职责原则 Single Responsibility Principle

单一职责原则最难划分的就是职责。一个职责一个接口，但问题时“职责”没有一个量化的标准，一个类到底要负责那些职责？这些职责应该怎么细化？细化后是否都要有一个接口或类？

单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因“都是不可度量得，因项目而异，因项目而异

**对于接口，在设计得时候一定要做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类得剧增，给维护带来非常多得麻烦，而且过分细分类得职责也会人为的增加系统的复杂性**

单一职责适用于接口，类，同时也适用方法，即一个方法尽可能做一件事情。

**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**

### 里氏替换原则 Liskov Substitution Principle

里氏替换定义：如果每一个类型为  S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型

所有引用基类的地方必须能透明的使用其子类型

里氏替换原则为良好的继承定义了一个规范

1.子类必须完全实现父类的方法：在类中调用其他类时，使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了 LSP 原则，如果子类不能实现父类的方法，或者父类的某些方法在子类中已经发生”畸变“，则建议断开继承关系，采用依赖、聚集、组合等关系替代继承

### 依赖倒置原则 Dependence Inversion Principle

高层模块不应该依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象

每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。

依赖倒置原则在 Java 中的表现为：

* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
* 接口或抽象类不依赖于实现类
* 实现类依赖接口或抽象类

依赖的三种写法

对象的依赖关系有三种方式来传递

* 构造函数传递依赖对象即构造函数注入
* Setter 方法传递依赖对象
* 接口声明依赖对象即接口注入

依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。依赖倒置最佳实践

* 每个类尽量都有接口或抽象类，或者抽象类接口两者具备（这种依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置
* 变量的表面类型尽量是接口或者抽象类
* 实现类尽量不从具体类派生
* 尽量不要覆写基类的方法（如果基类是一个抽象类，而且这个方法已经实现了，字类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响
* 结合里氏替换使用（通俗实现：接口负责定义 `public` 属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化

**面向接口编程是依赖倒置的核心**

### 接口隔离原则

客户端不应该依赖它不需要的接口（类之间的依赖关系应该建立在最小的接口上），即不要建议一个庞大的臃肿的接口，容纳所有客户端访问，保证接口的纯洁性：

* 接口要尽量小。根据接口隔离原则拆分接口时，首先必须满足单一职责原则
* 接口要高内聚，减少对外的交互。具体到接口隔离原则就是，在接口中尽量少公布 public 方法，接口是对外的承诺，承诺的越少对系统的开发越有利，变更的风险就越少。

接口隔离最佳实践：

接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。

一个接口只服务于一个子模块或一个业务逻辑，通过业务逻辑压缩接口中的 `public` 方法。已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。

### 迪米特原则 Least Knowledge Principle

一个对象应该对其他对象有最少的了解。即类或对象只了解交互部分。核心即弱耦合

### 开闭原则

一个实体应对扩展开放，对修改关闭。即应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。

开闭原则实践方式

* 抽象约束

  通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放：通过接口或抽象类约束扩展边界（即不能超出约定抽象范围）；参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；抽象层尽量保持稳定，一旦确定即不许修改；

* 元数据控制模块行为

  通过配置参数控制行为，控制反转

* 对改变封装

  将相同的改变封装到一个接口或抽象类中；将不同的改变封装到不同的接口或抽象类中，不应该有两个不同的改变出现在同一个接口或抽象类中。即为改变创建稳定的抽象边界