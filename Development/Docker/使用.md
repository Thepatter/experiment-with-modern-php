## 使用

### 容器

#### 运行容器

```shell
docker run --name <container.nam> -i -t <image> /bin/bash
```

`-i` 标志保证容器中 STDIN 是开启的

`-t` 标志为要创建的容器分配一个伪 tty 终端

`-d` 会将容器放到后台运行

`-e`  环境变量

`-u` 设置用户

`-w` 指定工作目录

`—name` 指定容器名称

`-p` 端口映射

`-P` 对外公开在 `Dockerfile` 中通过 `EXPOSE` 指令公开的所有端口，随机绑定到宿主机的一个随机端口上。

```shell
# 随机选择32768~61000映射
-p 80
# 指定映射
-p 80:80
# 指定 ip 端口
-p 127.0.0.1:80:80
# 绑定到特定的网络接口的随机端口
-p 127.0.0.1::80
```

`—name` 为容器指定一个名称 `[a-zA-Z0-9_.-]`，容器的命名必须是唯一的。如果试图创建两个名称相同的容器，则命令将会失败

#### 重新启动已经停止的容器

```shell
docker start <container.name/id>
```

#### 附着到容器上

```shell
docker attach <container.name/id>
```

#### 获取日志

```shell
# 获取容器日志
docker logs <container.name/id>
# 获取日志的最后 10 行内容
docker logs -tail 10 <container.name/id>
# 跟踪某个容器的最新日志，而不必读取整个日志文件
docker logs -tail 0 -f <container.name/id>
# 为每条日志加上时间戳
docker logs -ft <container.name/id>
```

##### 日志驱动

通过启动 `Docker` 守护进程或者执行 `docker run` 命令时使用  `—log-driver` 选项来控制 `docker` 守护进程和容器所用的日志驱动：默认的 `json-file`、`syslog`(该选项将禁用 `docker logs` 命令，并且将所有容器的日志输出都重定向到 `Syslog`)、`none`(这个选项将会禁用所有容器中的日志，导致 docker logs 命令也被禁用)

```shell
docker run —log-driver="syslog" —name daemon_dwayne -d ubuntu /bin/sh
```

#### 查看容器内的进程

```shell
docker top <container.name/id>
```

#### 查看容器统计信息

```shell
docker stats <container.name/id>
```

#### 在容器内部运行进程

```shell
docker exec -d <container.name/id> touch /etc/new_config_file
```

`docker exec` 命令在容器内部额外启动新进程。可以在容器内运行的进程类型：后台任务和交互式任务。后台任务在容器内运行且没有交互需求，而交互式任务则保持在前台运行。对于需要在容器内部打开 `shell` 的任务，交互式任务是很实用。

#### 停止守护式容器

```shell
# docker stop 命令会向 docker 容器进程发送 SIGTERM 信号
docker stop <container.name/id>
# 快速停止某个容器
docker kill <container.name/id>
```

#### 自动重启容器

```shell
docker run --restart=always --name daemon_dave -d ubuntu /bin/bash
```

如果由于某种错误而导致容器停止运行，还可以通过 `—restart` 标志，让 `docker` 自动重新启动该容器。`—restart` 标志会检查容器的退出代码，并据此来决定是否要重启容器。默认的行为是 `docker` 不会重启容器。`—restart` 标志可以设置为：

*  `always` ，无论容器的退出代码是什么，`docker` 都会自动重启该容器。

* `on-failure`，这样，只有当容器的退出代码非 0 值的时候，才会自动重启。`on-failure` 还接受一个可选的重启次数

   `--restart=on-failure:5`

#### 获取容器信息

```shell
# 深入容器
docker inspect <container.name/id>
# 格式化信息
docker inspect --format='{{ .State.Running}}' <container.name/id>
# 查看端口
docker port <container.name/id>
```

#### 删除容器

```shell
# 删除容器
docker rm <container.name/id>
# 删除运行中容器
docker rm -f <container.name/id>
```

### 镜像

#### 基本使用

```shell
# 下载镜像
docker pull <image>:<tag>
# 列出镜像
docker images [<image.name>]
# 查找镜像
docker search <image>
# 删除镜像
docker image rm <image>:<tag>
```

#### 构建镜像

##### docker commit 命令

在基础镜像中进行修改后，退出容器，使用 `docker commit` 命令生成新的 `image`

```shell
docker commit <container.name/id> <username/image>:<tag>
```

##### Dockerfile 文件

创建初始目录并在里面创建初始的 `Dockerfile` 这个目录即是：**构建环境build environment**，docker 称此环境为上下文或者构建上下文。`docker` 会在构建镜像时将构建上下文该上下文中的文件和目录上传到 `Docker` 守护进程。这样 `Docker` 守护进程就能直接访问用户想在镜像中存储的任何代码、文件或者其他数据。

`Dockerfile` 由一系列指令和参数组成。每条指令必须是大写字母，而且后面要跟随一个参数。`Dockerfile` 中的指令会按顺序从上到下执行。`Dockerfile` 也支持注释。以 `#` 开头的行都会被认为是注释。

* `FROM` 

  每个 `Dockerfile` 的第一条指令必须是 `FROM`，`FROM` 指令指定一个已经存在的镜像，后续指令都将基于该镜像运行，这个镜像被称为基础镜像

  ```dockerfile
  FROM <image>
  # 或者
  FROM <image>:<tag>
  ```

* `MAINTAINER` 

  指令会告诉 `Docker` 该镜像的作者是谁，以及作者的电子邮件地址

  ```dockerfile
  MAINTAINER <name>
  ```

* `RUN`

  shell 形式，`command` 作为 `/bin/sh -c` 的参数执行，即为 `shell` 的子进程

  ```dockerfile
  RUN <command>
  ```

  exec 形式，直接执行

  ```dockerfile
  RUN ["executable", "paraml", "param2"]
  ```

  RUN 指令是在当前镜像上执行命令，并且提交执行之后的结果，最为最新的一层 `layer`，并且后续的 `Dockerfile` 指令会在 `RUN` 指令执行完生成的最新镜像上继续执行

* `CMD`

  用于指定一个容器启动时要运行的命令。类似于 RUN 命令，只是 RUN 指令是指定镜像被构建时要运行的命令，而 CMD 是指定容器被启动时要运行的命令。和使用 `docker run` 命令启动容器时指定要运行的命令非常类似。`docker run` 命令可以覆盖 CMD 指令

  exec 形式，直接执行，推荐使用该形式

  ```dockerfile
  CMD ["executable", "param1", "param2"]
  ```

  作为 `ENTRYPOINT` 指令的默认参数

  ```dockerfile
  CMD ["param1", "param2"]
  ```

  shell 形式，作为 `/bin/sh -c` 的参数执行，即为 shell 的子进程

  ```dockerfile
  CMD command param1 param2
  ```

* `LABEL`

  `LABEL` 指令给一个镜像增加元信息 `metadata`。一个 `LABEL` 是一个键值对。如果 `LABEL` 值中需要包含空格或者换行符，使用双引号 `"` 或者反斜杠 `\`

  ```dockerfile
  LABEL <key>=<value> <key>=<value> <key>=<value>...
  ```

  eg

  ```dockerfile
  LABEL "com.example.vendor"="ACME Incorporated"
  LABEL com.example.label-with-value="foo"
  LABEL version="1.0"
  LABEL description="This text illustrates \
  that label-values can span multiple lines."
  ```

* `EXPOSE`

  `EXPOSE` 指令设置 `Docker` 容器在运行时监听指定网络端口。`EXPOSE` 指令并不会使得容器所在的主机可以访问容器的端口。为了使主机可以访问容器端口，必须使用 `-p` 或者 `-P` 参数

  ```dockerfile
  EXPOSE <port> [<port>...]
  ```

* `ENV`

  `ENV` 指令设置镜像的环境变量，可在实际启动容器时使用 `docker run —env <key>=<value>` 进行覆盖

  ```dockerfile
  ENV <key> <value>
  ENV <key>=<value>
  ```

* `ADD`

  如果 `src` 是文件路径，则必须是相对于构建上下文 `context` 的相对路径，且不能引用构建上下文目录之外的内容。`dest` 必须是绝对路径，或者是工作路径 `WORKDIR` 的相对路径。如果 `dest` 不存在，则将自动创建，如果 `dest` 不以 `/` 结尾，则将被认为是一个文件，而不是目录

  ```dockerfile
  ADD <src>...<dest>
  # 用于路径或者文件名包含空格情况
  ADD ["<src>",... "<dest>"]
  ```

* `COPY`

  与 `ADD` 类似，区别在于 `src` 不能是网络链接 URL 

  ```dockerfile
  COPY <src>...<dest>
  # 用于路径或者文件名包含空格
  COPY ["<src>",..."<dest>"]
  ```

* `ENTRYPOINT`

  ENTRYPOINT 指令与 CMD 指令非常类似，ENTRYPOINT 指令提供的命令则不容易在启动时被覆盖。实际上，`docker run` 命令行中指定的任何参数都会被当做参数再次传递给 `ENTRYPOINT` 指令中指定的命令。

  指定容器启动时的启动进程

  exec 形式，推荐

  ```dockerfile
  ENTRYPOINT ["executable", "param1", "param2"]
  ```

  eg：

  ```dockerfile
  ENTRYPOINT ["/usr/sbin/nginx", "g", "daemon off"]
  ```

  shell 形式，`command` 作为 `/bin/sh -c` 的参数进行执行，即为 `shell` 的子进程

  ```dockerfile
  ENTRYPOINT command param1 param2
  ```

* `VOLUME`

  VOLUMN 指令用来向基于镜像创建的容器添加卷，一个卷是可以存在于一个或者多个容器内的特定的目录，这个目录可以绕过联合文件系统，并提供如下共享数据或者对数据进行持久化的功能：

  卷可以在容器间共享和重用

  一个容器可以不是必须和其他容器共享卷

  对卷的修改是立即生效的

  对卷的修改不会对更新镜像产生影响

  卷会一直存在直到没有任何容器再使用它

  卷功能让可以将数据（如源代码）、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中，并且允许在多个容器间共享这些内容。

  指定了一个挂载点，并给该挂载点明明，表明该挂载点的数据卷来自于主机的某个目录或者共享了其他容器的目录，该挂载点的内容不会随镜像的分发而分发。

  ```dockerfile
  VOLUMN ["/data"]
  ```

* `USER`

  设置启动镜像时的用户或者 UID，随后所有在 `Dockerfile` 文件内的 `RUN`，`CMD` 以及 `ENTRYPOINT` 指令都将该用户作为执行用户。如果不指定默认为 `root` 

  ```dockerfile
  USER daemon
  ```

* `WORKDIR`

  用来在从镜像创建一个新容器时，在容器内部设置一个工作目录，`ENTRYPOINT` 和 `/` 或 `CMD` 指定的程序会在这个目录下执行。

  设置工作目录，随后所有在 `Dockerfile` 文件内的 `RUN`，`CMD` 以及 `ENTRYPOINT` 指令都将该目录作为当前目录，并执行相应的命令。`-w` 参数会覆盖该指令

* `STOPSIGNAL`

  用来设置停止容器时发送什么系统调用信号给容器。这个信号必须是内核系统调用表中合法的数。

* `ARG`

  用来定义在 `docker build` 命令运行时传递给构建运行时的变量，只需要在构建时使用 `—build-arg` 标志即可。用户只能在构建时指定在 `Dockerfile` 文件中定义过的参数

* `ONBUILD`

  为镜像添加触发器`trigger`，当一个镜像被用做其他镜像的基础镜像时，该镜像中的触发器将会被执行

使用 `docker build` 命令来构建新镜像。通过 `-t` 为新镜像设置仓库和名称，如果没有指定任何标签，Docker 将会自动为镜像设置一个 `latest` 标签

```dockerfile
# 从本地 . 目录构建
docker build -t="<username>/<image>:<tag>"
# 从 git 仓库,假设在这个 Git 仓库的根目录下存在 Dockerfile 文件
docker build -t="<username>/<image>:<tag> git@github.com:<username><dir>"
```









