## 容器

### 定义容器 `Dockerfile`

使用 `Dockerfile` 定义容器内环境中发生的事情。对网络接口和磁盘驱动器等资源的访问在此环境中进行虚拟化，该环境与系统的其他部分隔离，因此需要将端口映射到外部世界，并具体说明要 “复制” 到哪些文件那个环境。执行此操作后，可以预期 `Dockerfile` 在此处定义的应用程序的构建在其运行的任何位置都完全相同

#### Dockerfile

在本地计算机上创建一个空目录，进入该目录，创建一个名为 `Dockerfile` 的文件，内容如下

```dockerfile
# 使用官方python运行时作为父 images
FROM python:2.7-slim
# 设置工作目录
WORKDIR /app
# 将当前工作目录复制到容器的 /app 目录
COPY . /app
# 从 requirements.txt 获取需要的包
RUN pip install --trusted-host pypi.python.org -r requirements.txt
# 将端口 80 可用于此容器之外的世界
EXPOSE 80
# 定义环境变量
ENV NAME World
# 运行 app.py 当这个容器启动时
CMD ["python", "app.py"]
```

#### 应用程序本身

创建 `requirements.txt` 和 `app.py` 将它们与 `Dockerfile` 放在同一个的文件夹。这完成了应用程序。当上面的 `Dockerfile` 内置到映像中时，由于 `Dockerfile` 的 `COPY` 命令，`app.py` 和 `requirements.txt` 存在，并且由于 `EXPOSE` 命令，`app.py` 的输出可通过 HTTP 访问

* `requirements.txt`

  ```
  Flask
  Redis
  ```

* `app.py`

  ```python
  from flask import Flask
  from redis import Redis, RedisError
  import os
  import socket
  redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)
  app = Flask(__name__)
  @app.route("/")
  def hello():
      try:
          visits = redis.incr("counter")
      except RedisError:
          visits = "<i>cannot connect to Redis, counter disabled</i>"
          
      html = "<h3>Hello {name}!</h3>" \
      		"<b>Hostname:</b> {hostname}<br/>" \
          	"<b>Visits:</b> {visits}"
      return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)
  
  if __name__ == "__main__":
      app.run(host='0.0.0.0', port=80)
  ```

#### 构建容器

* 运行 `build` 命令，这将创建一个 `Docker` 镜像，使用 `--tag` 选项命名。

  ```shell
  docker build --tag=friendlyhello .
  ```

  标签默认为 `latest`，标签选项的完整语法类似于 `--tag=friendlyhello:v0.0.1`

* 构建完成后，位于机器的本地  `Docker` 镜像注册表中

  ```shell
  docker image ls
  ```

  



