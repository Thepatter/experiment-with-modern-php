## 容器

### 定义容器 `Dockerfile`

使用 `Dockerfile` 定义容器内环境中发生的事情。对网络接口和磁盘驱动器等资源的访问在此环境中进行虚拟化，该环境与系统的其他部分隔离，因此需要将端口映射到外部世界，并具体说明要 “复制” 到哪些文件那个环境。执行此操作后，可以预期 `Dockerfile` 在此处定义的应用程序的构建在其运行的任何位置都完全相同

#### Dockerfile

在本地计算机上创建一个空目录，进入该目录，创建一个名为 `Dockerfile` 的文件，内容如下

```dockerfile
# 使用官方python运行时作为父 images
FROM python:2.7-slim
# 设置工作目录
WORKDIR /app
# 将当前工作目录复制到容器的 /app 目录
COPY . /app
# 从 requirements.txt 获取需要的包
RUN pip install --trusted-host pypi.python.org -r requirements.txt
# 将端口 80 可用于此容器之外的世界
EXPOSE 80
# 定义环境变量
ENV NAME World
# 运行 app.py 当这个容器启动时
CMD ["python", "app.py"]
```

#### 应用程序本身

创建 `requirements.txt` 和 `app.py` 将它们与 `Dockerfile` 放在同一个的文件夹。这完成了应用程序。当上面的 `Dockerfile` 内置到映像中时，由于 `Dockerfile` 的 `COPY` 命令，`app.py` 和 `requirements.txt` 存在，并且由于 `EXPOSE` 命令，`app.py` 的输出可通过 HTTP 访问

* `requirements.txt`

  ```
  Flask
  Redis
  ```

* `app.py`

  ```python
  from flask import Flask
  from redis import Redis, RedisError
  import os
  import socket
  redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)
  app = Flask(__name__)
  @app.route("/")
  def hello():
      try:
          visits = redis.incr("counter")
      except RedisError:
          visits = "<i>cannot connect to Redis, counter disabled</i>"
          
      html = "<h3>Hello {name}!</h3>" \
      		"<b>Hostname:</b> {hostname}<br/>" \
          	"<b>Visits:</b> {visits}"
      return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)
  
  if __name__ == "__main__":
      app.run(host='0.0.0.0', port=80)
  ```

#### 构建Image

* 运行 `build` 命令，这将创建一个 `Docker` 镜像，使用 `--tag`  或 `-t` 选项命名

  ```shell
  docker build --tag=friendlyhello .
  ```

  标签默认为 `latest`，标签选项的完整语法类似于 `--tag=friendlyhello:v0.0.1`

  查看容器

  ```shell
  docker container ls
  ```

* 构建完成后，位于机器的本地  `Docker` 镜像注册表中

  ```shell
  docker image ls
  ```

* 删除 `image`

  ```
  # 使用 repository 和 tag 删除
  docker image rm <repository>:<tag>
  # 使用 image id 删除
  docker image rm <image id>
  ```

  

* DNS 设置

  DNS 配置错误可能会产生问题 `pip`。可能需要设置自己的 DNS 服务器地址才能正常工作，可以更改 `Docker` 守护进程的 DNS 设置，在 `/etc/docker/daemon.json` 中进行 `dns` 选项编辑

  ```json
  {
      "dns": ["your_dns_address", "8.8.8.8"]
  }
  ```

### 运行应用程序

运行应用程序，使用以下方法将计算机的端口 4000 映射到容器的已发布端口 80 

```shell
docker run -p 4000:80 friendlyhello
```

在后台以分离模型运行

```shell
docker run -d -p 4000:80 friendlyhello
```

返回应用程序的长容器 ID，然后返回终端，容器正在后台运行，使用 `docker container ls` 查看运行的容器，使用 `docker container stop <container_id>` 来退出

### 标记图像

将本地映像与注册表上的存储库相关联的表示法是 `username/repository:tag`。标签是可选的，但建议使用，因为它是注册管理结构用来为 `Docker` 镜像提供版本的机制。为存储库提供存储库和标记有意义的名称，如 `get-started:part2`。这会将图像放入 `get-started` 存储库并将其标记为 `part2`。现在，把它们放在一起来标记图像。`docker tag image` 使用您的用户名，存储库和标记名称运行，以便将图像上传到所需的目标位置，该命令的语法是：

```shell
docker image tag <image-name> <username>/<repository:tag>
```

如：

```shell
docker image tag friendlyhello yewandeyu/test:0.0.1
```

### 发布图像到个人仓库

* 登录

  ```shell
  docker login
  ```

* 发布

  ```shell
  docker push <username>/<repository>:<tag>
  ```

  如：

  ```shell
  docker image push yewandeyu/test:0.0.1
  ```

### 拉取并运行

可以直接使用 `docker run` 命令运行

```shell
docker run -p 4000:80 yewandeyu/test:0.0.1
```

无论在哪里执行 `docker run`，它都会提取图像，`python` 和所有依赖项 `requirements.txt`，并运行代码。它们都在一个整洁的小包中一起旅行，不需要在主机上安装任何东西

### 常用命令

```shell
# Create image using this directory's Dockerfile
docker build -t friendlyhello .  
# Run "friendlyname" mapping port 4000 to 80
docker run -p 4000:80 friendlyhello  
# Same thing, but in detached mode
docker run -d -p 4000:80 friendlyhello    
 # List all running containers
docker container ls      
# List all containers, even those not running
docker container ls -a     
# Gracefully stop the specified container
docker container stop <hash>   
# Force shutdown of the specified container
docker container kill <hash>      
# Remove specified container from this machine
docker container rm <hash>       
# Remove all containers
docker container rm $(docker container ls -a -q)   # List all images on this machine      
docker image ls -a    
# Remove specified image from this machine
docker image rm <image id>      
# Remove all images from this machine
docker image rm $(docker image ls -a -q)   
# Log in this CLI session using your Docker credentials
docker login   
# Tag <image> for upload to registry
docker tag <image> username/repository:tag  
# Upload tagged image to registry
docker push username/repository:tag     
# Run image from a registry
docker run username/repository:tag
```





