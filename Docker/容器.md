## 容器

### 使用 `Dockerfile`定义容器

#### 概述

`Dockerfile` 将在容器内定义环境中执行的操作。对网络接口和磁盘驱动器等资源的访问在环境内实现虚拟化，这将独立于系统的其余部分，因此必须将端口映射到外部，并具体说明要复制到该环境的文件。

#### `Dockerfile`

* 初始化 `Dockerfile`

  在本地计算机上创建一个空目录，进入该目录，创建一个名为 `Dockerfile` 的文件，内容如下

  *`Dockerfile`典型配置*

  ```dockerfile
  # 使用官方python运行时作为父 images
  FROM python:2.7-slim
  # 设置工作目录
  WORKDIR /app
  # 将当前工作目录复制到容器的 /app 目录
  COPY . /app
  # 从 requirements.txt 获取需要的包
  RUN pip install --trusted-host pypi.python.org -r requirements.txt
  # 将端口 80 暴露给外部环境
  EXPOSE 80
  # 定义环境变量
  ENV NAME World
  # 这个容器启动时运行 app.py
  CMD ["python", "app.py"]
  ```

#### 应用程序本身

 创建 `requirements.txt` 和 `app.py` 将它们与 `Dockerfile` 放在同一个的文件夹。这完成了应用程序。当上面的 `Dockerfile` 内置到映像中时，由于 `Dockerfile` 的 `COPY` 命令，`app.py` 和 `requirements.txt` 存在，并且由于 `EXPOSE` 命令，`app.py` 的输出可通过 HTTP 访问

* `requirements.txt`

  ```
  Flask
  Redis
  ```

* `app.py`

  ```python
  from flask import Flask
  from redis import Redis, RedisError
  import os
  import socket
  redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)
  app = Flask(__name__)
  @app.route("/")
  def hello():
      try:
          visits = redis.incr("counter")
      except RedisError:
          visits = "<i>cannot connect to Redis, counter disabled</i>"
          
      html = "<h3>Hello {name}!</h3>" \
      		"<b>Hostname:</b> {hostname}<br/>" \
          	"<b>Visits:</b> {visits}"
      return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)
  
  if __name__ == "__main__":
      app.run(host='0.0.0.0', port=80)
  ```

#### 构建Image

* 运行 `build` 命令，这将创建一个 `Docker` 镜像，使用 `--tag`  或 `-t` 选项命名

  ```shell
  docker build --tag=friendlyhello .
  ```

  标签默认为 `latest`，标签选项的完整语法类似于 `--tag=friendlyhello:v0.0.1`

  查看容器

  ```shell
  docker container ls
  ```

* 构建完成后，位于机器的本地  `Docker` 镜像注册表中

  ```shell
  docker image ls
  ```

* 删除 `image`

  ```
  # 使用 repository 和 tag 删除
  docker image rm <repository>:<tag>
  # 使用 image id 删除
  docker image rm <image id>
  ```

* DNS 设置

  DNS 配置错误可能会产生问题 `pip`。可能需要设置自己的 DNS 服务器地址才能正常工作，可以更改 `Docker` 守护进程的 DNS 设置，在 `/etc/docker/daemon.json` 中进行 `dns` 选项编辑

  ```json
  {
      "dns": ["your_dns_address", "8.8.8.8"]
  }
  ```

### 运行应用程序

* 运行应用程序，使用以下方法将计算机的端口 4000 映射到容器的已发布端口 80 

  ```shell
  docker run -p 4000:80 friendlyhello
  ```

* 在后台以分离模型运行

  ```shell
  docker run -d -p 4000:80 friendlyhello
  ```

  返回应用程序的长容器 ID，然后返回终端，容器正在后台运行，使用 `docker container ls` 查看运行的容器，使用 `docker container stop <container_id>` 来退出

### 标记图像

* 将本地映像与注册表上的存储库相关联的表示法是 `username/repository:tag`。标签是可选的，但建议使用，因为它是注册管理结构用来为 `Docker` 镜像提供版本的机制。为存储库提供存储库和标记有意义的名称，如 `get-started:part2`。这会将图像放入 `get-started` 存储库并将其标记为 `part2`。现在，把它们放在一起来标记图像。`docker tag image` 使用您的用户名，存储库和标记名称运行，以便将图像上传到所需的目标位置，该命令的语法是：

  ```shell
  # 标记图像并设置 tag
  docker image tag <image-name> <username>/<repository:tag>
  ```

  如：

  ```shell
  docker image tag friendlyhello yewandeyu/test:0.0.1
  ```

### 发布图像到个人仓库

* 登录

  ```shell
  docker login
  ```

* 发布

  ```shell
  docker push <username>/<repository>:<tag>
  ```

  如：

  ```shell
  docker image push yewandeyu/test:0.0.1
  ```

### 拉取并运行

* 拉取图像到本地

  ```shell
  docker pull mysql:8.0.15
  ```

* 拉取并运行

  ```shell
  docker run -p 4000:80 yewandeyu/test:0.0.1
  ```

  无论在哪里执行 `docker run`，它都会提取图像，`python` 和所有依赖项 `requirements.txt`，并运行代码。它们都在一个整洁的小包中一起旅行，不需要在主机上安装任何东西

### 常用命令

```shell
# 使用此目录的 Dockerfile 创建镜像
docker build -t friendlyhello .  
# 运行 <image>:<tag> 容器，外部端口 4000，映射为内部端口 80
docker run -p 4000:80 <image>:<tag>  
# 分离模式下运行容器
docker run -d -p 4000:80 <image>:<tag>
# 列出所有容器
docker container ls      
# 列出所有容器包含未运行容器
docker container ls -a     
# 停止指定hash的容器
docker container stop <hash>   
# 强制关闭指定hash的容器
docker container kill <hash>      
# 删除指定容器
docker container rm <hash>       
# 删除所有容器
docker container rm $(docker container ls -a -q)
# 列出所有图像
docker image ls -a    
# 删除指定图像
docker image rm <image id>      
# 删除所有图像
docker image rm $(docker image ls -a -q)   
# 命令行登录 docker
docker login   
# 标记图像
docker tag <image> <username>/<repository>:<tag>  
# 推送图像到仓库
docker push <username>/<repository>:<tag>
# 运行镜像库中镜像
docker run <username>/<repository>:<tag>
```





