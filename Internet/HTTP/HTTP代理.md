## HTTP 代理

### 代理服务

代理服务本身不生产内容，而是处理中间位置转发上下游的请求和响应，具有双重身份：面向下游用户时，表现为服务器，代表源服务器响应客户端的请求；面向上游源服务器时，表现为客户端，代表客户端发送请求

#### 代理作用

代理最基本的功能是负载均衡，面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器有多少台，是那些 IP 地址都不知道。代理服务器在做负载均衡时还可以执行：

* 健康检查：使用心跳等机制监控后端服务器，发现有故障就及时踢出集群，保证服务高可用
* 安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载
* 加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本
* 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应
* 内容缓存：暂存、复用服务器响应

#### 代理头字段

* Via

  代理服务器需要用 **`Via` ** 标明代理身份。`Via` 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，如果通信链路中有很多中间代理，就会在 `Via` 里形成一个链表。Via 追加的是代理主机名（或域名）。有的服务器返回的响应报文会使用 `X-Via` 含义一致

* X-Forwarded-For

  每经过一个代理节点就会在字段里追加一个信息。追加的是请求方的 IP 地址

* X-Real-IP

  记录客户端 IP 地址，没有中间的代理信息

#### 代理协议

通过 `X-Forwarded-For` 操作代理信息必须要解析 HTTP 报文头，成本较高，且 HTTPS 下无法修改。代理协议作为事实标准简化协议：`v1` 为明文，在 HTTP 报文前再增加一行 ASCII  码文本（开头必须是 PROXY ，然后是 TCP4 或者 TCP6，表示客户端的 IP  地址类型，后面是请求方地址、应答方地址、请求方端口、应答方端口，最后用一个回车换行\r\n 结束）；v2 为二进制格式

```http
PROXY TCP4 1.1.1.1 2.2.2.2 11111 80\r\n
```

代理协议并不支持 `X-Forwarded-For` 的链式地址格式，拿到客户端地址后再如何处理需要代理服务器与后端协商

### HTTP 缓存代理

HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然有各种缓存（`Memcache`，`Redis` 等），但与 HTTP 没有太多关系。没有缓存时，代理服务器每次都是直接转发客户端和服务器的报文，中间不会存储任何数据，只有简单的中转功能。加入缓存后，代理服务器收到源服务器发来的响应数据后需要做两件事：将报文转发给客户端；把报文存入自己的 Cache 里。下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源 服务器哪里获取，可以降低客户端的等待时间，节约带宽。

在 HTTP 缓存体系中，缓存代理**既是客户端，又是服务端**，它面向源服务器时是客户端，面向客户端时是服务器，它既可以用客户端的缓存控制策略也可用服务器的缓存控制策略；但缓存代理只是数据中转站，并不是真正的数据消费者或生产者，需要一些新的 `Cache-Control` 属性对它做特别的约束。

* 代理在响应报文里还额外加了 `X-Cache`，`X-Hit`，`X-Accel` 表示缓存是否命中和命中率。

* 同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本，缓存代理必须要存储这些不同的版本。当再收到相同的请求时，代理就读取缓存里 `Vary` ，对比请求头里 `Vary` 的相应的值，如果和上一个请求完全匹配，即版本一致，可以返回缓存的数据

* Purge：缓存清理，清理缓存比较常用的一种做法是使用**自定义请求方法 `PURGE`**，发给代理服务器，要求删除 URI 对应的缓存数据

#### 源服务器的缓存控制

![](../Images/服务器完整缓存控制策略.png)

代理服务器缓存控制字段 `Cache-Control` 新属性：

* private 和 public

  private 表示缓存只能在客户端保存，是用户私有的，不能放在代理上与别人分享。public 即缓存时完全开放，谁都可以用

* proxy-revalidate

  只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节即可

* `s-maxage`

  缓存只限定在代理上能够存多久，而客户端仍然用 `max-age`

* no-transform

  不能对源数据进行操作

```http
# 缓存在客户端，生成时间为 5s
Cache-Control: private,max-age=5
# 缓存在代理服务器生存时间为 10s，在客户端生存 5s，过期后直接请求缓存服务器
Cache-Control: public,max-age=5,s-maxage=10
# 代理和客户端都缓存 5s，过期后 缓存去服务器请求并且不允许改变数据
Cache-Control: public, max-age=5,proxy-revalidate,no-transform
```

源服务器设置完 `Cache-Control` 后必须要为报文加上 `Last-modified` 或 `ETag` 字段

#### 客户端的缓存控制

客户端在 HTTP 缓存体系里要面对的是代理和源服务器，也必须区别对待

![](../Images/客户端完整缓存策略.png)

关于缓存的生存时间，多了两个新属性 **`max-stale`** 和 **`min-fresh`**

* max-stale

  如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。即使用 max-age + max-stale 计算缓存有效时间

* min-fresh

  缓存必须有效，而且必须在 x 秒后依然有效，即缓存存在时间 + min-fresh 必须小于 max-age

有时候客户端会发出一个特别的 `only-if-cached` 属性，即只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或缓存过期，会响应 `504 (Gateway Timeout)`

### CDN

#### Content Delivery Network

外部加速 HTTP 协议的服务。CDN 的核心原则是『就近访问』。主要适用缓存代理技术，使用『推』或『拉』的手段，把源站的内容逐级缓存到网络的每一个节点上。用户在上网的时候就不直接访问源站，而是访问离他最近的一个 CDN 节点（边缘节点）即缓存了源站内容的代理服务器。

在 CDN 领域里，『内容』即 HTTP 协议的『资源』，比如超文本、图片、视频、应用程序安装包。资源按照是否可缓存分为：

* 静态资源

  数据内容静态不变，任何时候来访问都是一样的，如图片、音频

* 动态资源 

  由服务器实时计算生成的。每次访问不一样。

只有静态资源才能被缓存加速、就近访问，而动态资源只能由源站实时生成，即使缓存了也没有意义。不过，如果动态资源指定了 Cache-Control，允许缓存短暂的时候，那它在这段时间里就变成了『静态资源』，可以被 CDN 缓存加速

#### CDN 负载均衡

CDN 有两个关键组成部分：**全局负载均衡**和**缓存系统**，对应的是 DNS 和缓存代理技术。

全局负载均衡（Global Server Load Balance）GSLB，它是 CDN 的大脑，主要职责是当用户接入网络的时候在 CDN 专网中挑选出一个最佳节点提供服务，解决的是用户如何找到最近的边缘节点，对整个 CDN 网络进行“负载均衡”。

GSLB 最常见的实现方式是 “DNS负载均衡”，原来没有 CDN 的时候，权威 DNS 返回的是网站自己服务器的实际 IP 地址，浏览器收到 DNS 解析结果后直连网站。但加入 CDN 后，权威 DNS 返回的不是 IP 地址，而是一个 CNAME（Canonical Name）别名记录，指向的就是 CDN 的 GSLB。因为没能获取 IP 地址，于是本地 DNS 就会向 GSLB 再发起请求，这样就进入了 CDN 的全局负载均衡系统，开始调度，依据：

* 看用户的 IP 地址，查表得到地理位置，找相对最近的边缘节点
* 看用户所在的运营商网络，找相同网络的边缘节点
* 检查边缘节点的负载情况，找负载较轻的节点
* 检查节点的服务能力，带宽，响应时间等

GSLB 会根据这些因素，用算法，找出一个最合适的边缘节点。把这个节点的 IP 地址返回给用户，用户就可以就近访问 CDN 的缓存代理

#### CDN 缓存代理

缓存系统是 CDN 的另一个关键组成部分，衡量 CDN 服务质量的指标：“命中率”和“回源率”

* 命中

  指用户访问的资源恰好在缓存系统里，可以直接返回给用户

* 回源

  缓存里没有，必须使用代理的方式回源站取



