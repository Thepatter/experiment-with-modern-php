## HTTP 代理

### 代理服务

代理服务本身不生产内容，而是处理中间位置转发上下游的请求和响应，具有双重身份：面向下游用户时，表现为服务器，代表源服务器响应客户端的请求；面向上游源服务器时，表现为客户端，代表客户端发送请求

#### 代理作用

代理最基本的功能是负载均衡，面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器有多少台，是那些 IP 地址都不知道。代理服务器在做负载均衡时还可以执行：

* 健康检查：使用心跳等机制监控后端服务器，发现有故障就及时踢出集群，保证服务高可用
* 安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载
* 加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本
* 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应
* 内容缓存：暂存、复用服务器响应

#### 代理头字段

* Via

  代理服务器需要用 **`Via` ** 标明代理身份。`Via` 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，如果通信链路中有很多中间代理，就会在 `Via` 里形成一个链表。Via 追加的是代理主机名（或域名）。有的服务器返回的响应报文会使用 `X-Via` 含义一致

* X-Forwarded-For

  每经过一个代理节点就会在字段里追加一个信息。追加的是请求方的 IP 地址

* X-Real-IP

  记录客户端 IP 地址，没有中间的代理信息

#### 代理协议

通过 `X-Forwarded-For` 操作代理信息必须要解析 HTTP 报文头，成本较高，且 HTTPS 下无法修改。代理协议作为事实标准简化协议：`v1` 为明文，在 HTTP 报文前再增加一行 ASCII  码文本（开头必须是 PROXY ，然后是 TCP4 或者 TCP6，表示客户端的 IP  地址类型，后面是请求方地址、应答方地址、请求方端口、应答方端口，最后用一个回车换行\r\n 结束）；v2 为二进制格式

```http
PROXY TCP4 1.1.1.1 2.2.2.2 11111 80\r\n
```

代理协议并不支持 `X-Forwarded-For` 的链式地址格式，拿到客户端地址后再如何处理需要代理服务器与后端协商

### HTTP 缓存代理

HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理），而源服务器系统内部虽然有各种缓存（`Memcache`，`Redis` 等），但与 HTTP 没有太多关系。没有缓存时，代理服务器每次都是直接转发客户端和服务器的报文，中间不会存储任何数据，只有简单的中转功能。加入缓存后，代理服务器收到源服务器发来的响应数据后需要做两件事：将报文转发给客户端；把报文存入自己的 Cache 里。下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源 服务器哪里获取，可以降低客户端的等待时间，节约带宽。

在 HTTP 缓存体系中，缓存代理**既是客户端，又是服务端**，它面向源服务器时是客户端，面向客户端时是服务器，它既可以用客户端的缓存控制策略也可用服务器的缓存控制策略；但缓存代理只是数据中转站，并不是真正的数据消费者或生产者，需要一些新的 `Cache-Control` 属性对它做特别的约束。

* 代理在响应报文里还额外加了 `X-Cache`，`X-Hit`，`X-Accel` 表示缓存是否命中和命中率。

* 同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本，缓存代理必须要存储这些不同的版本。当再收到相同的请求时，代理就读取缓存里 `Vary` ，对比请求头里 `Vary` 的相应的值，如果和上一个请求完全匹配，即版本一致，可以返回缓存的数据

* Purge：缓存清理，清理缓存比较常用的一种做法是使用**自定义请求方法 `PURGE`**，发给代理服务器，要求删除 URI 对应的缓存数据

#### 源服务器的缓存控制

![](../Images/服务器完整缓存控制策略.png)

代理服务器缓存控制字段 `Cache-Control` 新属性：

* private 和 public

  private 表示缓存只能在客户端保存，是用户私有的，不能放在代理上与别人分享。public 即缓存时完全开放，谁都可以用

* proxy-revalidate

  只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节即可

* `s-maxage`

  缓存只限定在代理上能够存多久，而客户端仍然用 `max-age`

* no-transform

  不能对源数据进行操作

```http
# 缓存在客户端，生成时间为 5s
Cache-Control: private,max-age=5
# 缓存在代理服务器生存时间为 10s，在客户端生存 5s，过期后直接请求缓存服务器
Cache-Control: public,max-age=5,s-maxage=10
# 代理和客户端都缓存 5s，过期后 缓存去服务器请求并且不允许改变数据
Cache-Control: public, max-age=5,proxy-revalidate,no-transform
```

源服务器设置完 `Cache-Control` 后必须要为报文加上 `Last-modified` 或 `ETag` 字段

#### 客户端的缓存控制

客户端在 HTTP 缓存体系里要面对的是代理和源服务器，也必须区别对待

![](../Images/客户端完整缓存策略.png)

关于缓存的生存时间，多了两个新属性 **`max-stale`** 和 **`min-fresh`**

* max-stale

  如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。即使用 max-age + max-stale 计算缓存有效时间

* min-fresh

  缓存必须有效，而且必须在 x 秒后依然有效，即缓存存在时间 + min-fresh 必须小于 max-age

有时候客户端会发出一个特别的 `only-if-cached` 属性，即只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或缓存过期，会响应 `504 (Gateway Timeout)`



