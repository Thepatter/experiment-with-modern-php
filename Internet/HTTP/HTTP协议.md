### HTTP 相关概念

#### 组成部分

##### 资源定位符

###### URI

URI Uniform Resource Identifier 统一资源标识符，使用它能够唯一地标记互联网上资源，URI 主要有三个基本的部分构成：

![](../Images/完整URI组成.png)

* 身份信息 (不推荐)

  表示登录主机时的用户名和密码，但现在不推荐使用这种形式了，它会将敏感信息以明文形式暴露出来

* 协议名 Scheme

  即访问该资源应当使用的协议，如 http、ftp

* 主机名 authority

  即互联网上的标记，可以是域名或 IP 地址，表示资源所在的主机名，通常为 host:port

* 路径 path

  即资源在主机上的位置，使用 `/` 分割多级目录。URI 的 path 部分必须以 `/` 开始，即必须包含 `/`

* 查询参数 query

  URL 查询参数 query，它在 path 之后，用一个 ? 开始，但不包含 ?，表示对资源附加的额外要求。查询参数是多个 key=value 的字符串，使用 & 连接

* 片段标识符 #fragment

  它是 URI 所定位的资源内部的一个『锚点』，浏览器可以在获取资源后直接跳转到它指示的位置。仅能由浏览器这样的客户端使用，服务器是看不到的，浏览器永远不会把带  #fragment 的 URI 发送给服务器，服务器也永远不会用这种方式处理资源的片段

URI 本质上是一个字符串，这个字符串的作用是唯一的标记资源的位置或者名字。它不仅能标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。

客户端和服务器看到的 URI 是不一样的，客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。

<u>在 nginx 中，它的 location、rewrite 等指令操作的 URI 指的是真正 URI 里的 path 和后续的部分</u>

###### URL

* URL Uniform Resource Locator 统一资源定位符，即网址，它是 URI 的一个子集

###### URN

统一资源名称，包括名字，但不包括访问方式

##### URI 转义

包含一个百分号（%），后面跟着两个表示字符 ASCII 码的十六进制数。

*保留及受限字符*

|    字符    |                          保留/受限                           | ASCII | HEX  |
| :--------: | :----------------------------------------------------------: | :---: | :--: |
|     %      |                  保留作为编码字符的转义标志                  |  37   |  25  |
|     /      |                    保留作为路径分隔定界符                    |  47   |  2F  |
|     .      |                     保留在路径组件中使用                     |  46   |  2E  |
|     #      |                    保留作为分段定界符使用                    |  35   |  23  |
|     ？     |                  保留为查询字符串定界符使用                  |  63   |  3F  |
|     ；     |                    保留作为参数定界符使用                    |  59   |  3B  |
|     ：     |       保留为方案，用户/口令，主机/端口组件的定界符使用       |  58   |  3A  |
|     $      |                             保留                             |  36   |  24  |
|     ，     |                             保留                             |  39   |  27  |
|     +      |                             保留                             |  43   |  2B  |
|     @      |                        特殊上下文保留                        |  64   |  40  |
|     &      |                        特殊上下文保留                        |  38   |  26  |
|     =      |                        特殊上下文保留                        |  61   |  3D  |
| {}\|\^~[]` |  由于各种传输 Agent 代理，如各种网关的不安全处理，使用受限   |       |      |
|    <>"     | 不安全，这些字符在 URL 范围之外通常是有意义的，比如在文档中对 URL 自身进行定界，所以应该对其进行编码 |       |      |
| 0x00-0x1F  | 受限，这些十六进制范围内的字符都在 US-ASCII 字符集的不可打印区间内 |       |      |
|   >0x7F    | 受限，十六进制值在此范围内的字符都不在 US-ASCII 字符集的 7 比特范围内 |       |      |

#### 代理

##### 代理服务

###### 分类

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为『中转站』，既可以转发客户端的请求，也可以转发服务器的应答。常见代理：

* 匿名代理

  完全『隐匿』了被代理的机器，外界看到的只是代理服务器

* 透明代理

  传输过程是『透明开发』的，外界既知道代理，也知道客户端

* 正向代理

  靠近客户端，代表客户端向服务器发送请求

* 反向代理

  靠近服务器端，代表服务器响应客户端的请求

###### 作用

由于代理在传输过程中插入了一个『中间层』，所以可以在这个环节做很多有意义的事情：

* 负载均衡

  把访问请求均匀分散到多台机器，实现访问集群化

* 内容缓存

  暂存上下行的数据，减轻后端的压力

* 安全防护

  隐匿 IP，使用 WAF 等工具抵御网络攻击，保护被代理的机器

* 数据处理

  提供压缩，加密等额外的功能
  
* 健康检查

  使用心跳等机制监控后端服务器，发现有故障就及时踢出集群，保证服务高可用

* 加密卸载

  对外网使用 SSL/TLS 加密通信验证，而在内网不加密，消除加解密成本

###### 头字段

* Via

  Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾。如果通信链路中有很多中间代理，会在 Via 里形成一个链表。

  Via 追加的是代理主机名（或域名）

* X-Via

  等同于 Via

* X-Forwarded-For

  每经过一个代理节点就会在该字段里追加一个信息，追加的是请求方的 IP 地址

* X-Real-IP

  记录客户端 IP地址，没有中间的代理信息

###### 代理协议

通过 X-Forwarded-For 操作代理信息必须要解析 HTTP 报文头，且 HTTPS 下无法修改。代理协议作为事实标准简化协议

* v1

  明文，在 HTTP 报文前再增加一行 ASCII 码文本

  ```
  # PROXY 开头，然后是 TCP4 或 TCP6 表示客户端 IP 地址类型，后面是请求方地址，应答方地址，请求方端口，应答方端口，以缓冲换行 \r\n 结束
  PROXY TCP4 127.0.0.1 127.0.0.1 11123 80\r\n
  ```

* v2

  为二进制格式

代理协议并不支持 X-Forwarded-For 的链式地址格式，拿到客户端地址后再如何处理，需要代理服务器与后端协商

##### HTTP 缓存代理

###### HTTP 缓存代理服务器

HTTP 的服务器缓存功能主要由代理服务器来实现，而源服务器系统内部各种缓存（Memecache，redis）与 HTTP 没有关系。

没有缓存时，代理服务器每次都是直接转发客户端和服务器的报文，中间不会存储任何数据，只有简单的中转功能。加入缓存后，代理服务器收到源服务器发来的响应数据后需要：

1. 将报文转发给客户端
2. 把报文存入自己的 Cache 里，下一次再有相同的请求，代理服务器就直接发送 304 或者缓存数据

在 HTTP 缓存体系中，缓存代理即是客户端，也是服务端，可以用客户端的缓存控制策略也可用服务器的缓存控制策略。

###### HTTP 缓存代理控制

缓存代理是数据中转站，使用 Cache-Control 属性约束

* X-Cache、X-Hit、X-Accel

  代理在响应报文中增加以上 Cache-Control 属性表示是否命中和命中率
  
* Very

  同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本，缓存代理必须要存储这些不同的版本。当再接收到相同的请求时，代理就读取缓存里的 Vary，对比请求头李的 Vary 的相应的值，如果和上一个请求完全匹配，即版本一致，可以返回缓存的数据

* Purge

  缓存清理，比较常用的做法是使用自定义请求方法 PURGE，发给代理服务器，要求删除 URI 对应的缓存数据

###### 源服务器缓存控制

*服务器完整缓存控制策略*

<img src="../Images/服务器完整缓存控制策略.png" style="zoom:65%;" />

Cache-Control 属性控制：

* private

  缓存只能在客户端保存，是用户私有的，不能放在代理上与别人分享

* public

  即缓存是完全开放的，谁都可以用

* proxy-revalidate

  要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节

* s-maxage

  缓存只限定在代理上能够存多久，而客户端仍然使用 max-age

* no-transform

  不能对源数据进行操作

```http
# 缓存在客户端，生成时间为 5s
Cache-Control: private,max-age=5
# 缓存在代理服务器生存时间为 10s，在客户端生存 5s，过期后直接请求缓存服务器
Cache-Control: public,max-age=5,s-maxage=10
# 代理和客户端都缓存 5s，过期后 缓存去服务器请求并且不允许改变数据
Cache-Control: public, max-age=5,proxy-revalidate,no-transform
```

源服务器设置万 Cache-Control 后必须要为报文加上 Last-modified 或 ETag 字段

###### 客户端的缓存控制

客户端在 HTTP 缓存体系里要面对的是代理和源服务器，必须区别对待

*客户端完整缓存策略*

<img src="../Images/客户端完整缓存策略.png" style="zoom:60%;" />

Cache-Control 中控制属性：

* max-stale

  如果代理上的缓存过期了也可以接受，但不能过期太多，即使用 max-age + max-stale 计算缓存有效时间

* min-fresh

  缓存必须有效，而且必须在 x 秒后依然有效，即缓存存在时间 + min-fresh 必须小于 max-age

* Only-if-cached

  只接受代理缓存的数据，不接受源服务器的响应，如果代理上没有缓存或缓存过期，会响应 504

#### 域名

域名是一个有层次的结构，是一串用 . 分隔的多个单词，最右边的被称为『顶级域名』，然后是『二级域名』，层级关系向左依次降低。最左边的是主机名，通常用来表明主机的用途，如 www 表示提供万维网服务，mail 表示提供邮件服务。在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由那个虚拟主机来对外提供服务。

##### 域名解析

DNS 核心系统是一个三层的树状、分布式服务，基本对应域名的结构：

* 根域名服务器 Root DNS Server

  管理顶级域名服务器，返回 com 、net、cn 等顶级域名服务器的 IP 地址

* 顶级域名服务器 Top-level DNS Server

  管理各自域名下的权威域名服务器，如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址

* 权威域名服务器 Authoritative DNS Server

  管理自己域名下主机的 IP 地址，如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址

<u>nginx 中的 resolver 指令，就是用来配置 DNS 服务器的，如果没有它，那么 nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站</u>

```nginx
# 指定 Google 的 DNS，缓存 30s
resolver 8.8.8.8 valid = 30s
```

#### 报文

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成

* 起始行（start line）

  描述请求或响应的基本信息

* 头部字段集合（header）

  使用 key-value 形式更详细地说明报文

* 消息正文（entity）

  实际传输的数据，可能是文本，图片，视频等二进制数据

HTTP 协议规定报文必须有 header ，但可以没有 body，而且 header 之后必须要有一个『空行』，即 CRLF，十六进制 0D0A

##### 起始行

###### 请求行 request line

描述了**客户端想要如何操作服务端的资源**，请求行由三部分构成：

* 请求方法

  是一个动词，如 GET/POST，表示对资源的操作

* 请求目标

  通常是一个 URI，标记了请求方法要操作的资源

* 版本号

  表示报文使用的 HTTP 协议版本

这三部分通常使用空格来分隔，最后用 CRLF 换行表示结束

###### 响应状态行 status line

即服务器响应的状态

* 版本号

  表示报文使用的 HTTP 协议版本

* 状态码

  数字，表示处理结果

* 原因

  数字状态码的补充

请求头和响应头的结构基本一样，唯一的区别是起始行。头部字段是 key-value 的形式，key 和 value 之间用 : 分隔，最后用 CRLF 换行表示字段结束。HTTP 头部字段非常灵活，可以任意添加自定义头，使用头字段

* 字段名不区分大小写，但首字母大写的可读性更好
* 字段名里不允许出现空格，可以使用连字符 -，但不能使用下划线 _
* 字段名后面必须紧接着 :，不能有空格，而 : 后字段值前可有有多个空格
* 字段的属性没有意义，可以任意排列不影响语义
* 字段原则上不能重复，除非这个字段本身的语义允许，如 Set-Cookie

##### HTTP 头部字段

###### 字段划分

HTTP 协议规定了非常多的头部字段，实现各种功能：

* 通用字段

  在请求头和响应头里都可以出现

* 请求字段

  仅能出现在请求头里，进一步说明请求信息或者额外的附加条件

* 响应字段

  仅能出现在响应头里，补充说明响应报文的信息

* 实体字段

  实际属于通用字段，但专门描述 body 的额外信息

###### 常用字段

|   类型   |      key       |                             含义                             | 必须出现 |
| :------: | :------------: | :----------------------------------------------------------: | :------: |
| request  |      Host      | 告诉服务器这个请求应该由那个主机来处理，当一台计算机托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择 |   true   |
| request  |   User-Agent   |                     描述 HTTP 请求客户端                     |          |
| general  |      Date      | 通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略 |          |
| response |     Server     |             正在提供 Web 服务器的软件名和版本号              |          |
|  entity  | Content-Length | 表示报文 body 的长度，即请求头或请求行空行后面的数据长度，如果没有该字段，那么 body  就是不定长的，需要使用 chunked 方式分段传输 |          |

##### 实体

###### 数据类型 MIME

在 TCP/IP 协议栈里，传输数据基本上都是 header + body 的格式。但 TCP、UDP 是传输层协议，不会关心 body 数据是什么，只要把数据发送到对方就算完成任务。而 HTTP 是应有层协议，数据到达之后还需要告诉上层应用这是什么数据才行，即数据类型

Multipurpose Internet Mail Extensions 是一个很大的标准规范，但 HTTP 只取了其中的一部分，用来标记 body 的数据类型，即 MIME type，MIME 把数据分成了八大类，每个大类下再细分多个子类，形式是 type/subtype 的字符串。HTTP 里经常遇到的类别

* text

  文本格式的可读数据，text/html（超文本），text/plain（纯文本），text/css（样式表）

* image

  即图像文件，image/gif，image/jpeg，image/png

* audio/video

  音视频数据，audio/mpeg，video/mp4

* application

  数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来结束，application/octet-stream（不透明二进制数据）

###### 数据压缩编码

HTTP 在传输时为了节约带宽，有时会压缩数据，使用 Encoding type 来指定编码格式

* gzip

  GNU zip 压缩格式

* deflate

  zlib 压缩格式

* br

  专门为 HTTP 优化的新压缩算法

###### 实体内容协商

HTTP 协议定义了用于客户端和服务器进行内容协商的头字段（Accept 头告诉服务器希望接收什么数据，Content 头告诉客户端实际发送了什么数据）：

* Accept

  请求字段标记的是客户端可理解的 MIME type，可以用逗号分隔出多个类型，让服务器选择

* Accept-Encoding

  请求字段标记的是客户端支持的压缩格式，可以用逗号分隔

* Content-Type

  通用字段，实体数据的真实类型，对应 Accept，如 POST 请求的实体类型，或响应的 body 类型

* Content-Encoding

  实际使用的压缩格式，对应 Accept-Encoding

* Accept-Language

  语言类型，即自然语言，en-US 美式英语，zh-CN 简体中文

* Accept-Charset

  字符集，客户端能接受的字符集

在 HTTP 协议里用 Accept，Accept-Encoding，Accept-Language 等请求头字段进行内容协商，还可以用 q 参数表示权重来设定优先级，q 即 quality factor，权重的最大值是 1，最小值是 0.01 ，默认值是 1，如果值是 0 就表示拒绝。在数据类型或语言代码后面加分号，后接 q=value

```
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

内容协商的过程是不透明的，每个 web 服务器使用的算法都不一样，但有时，服务器会在响应头里多加一个 **Vary** 字段，记录服务器在内容协商时参考的请求头字段

```
# 服务器依据 Accept-Encoding,User-Agent,Accept 三个头字段决定了发回的响应报文
Vary: Accept-Encoding,User-Agent,Accept
```

#### 文件传输

##### 数据压缩

传输数据时开启压缩，但 gzip 等压缩算法通常只对文本有较好的压缩率，而图片、音视频等多媒体数据本身已经是高度压缩，再用 gzip 处理也不会变小（甚至还有可能会增大一点）

在 Nginx 里会使用 gzip on 指令，启用压缩

##### 分块传输

###### 分块头

HTTP 协议就是 chunked 分块传输编码，在响应报文里用头字段 **Transfer-Encoding: chunked** 来表示，即报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

分块传输也可以用于『流式数据』，这种情况下 body 数据的长度是未知的，无法在头字段 **Content-Length **里给出具体长度。

Transfer-Encoding: chunked 和 Contenting-Length 字段是**互斥**的，即响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知的，要么是长度未知（chunked）。

分块传输采用了明文的方式，类似响应头

###### 分块头结构

* 每个分块包含两部分，分块长度和分块数据
* 长度头是以 CRLF（回车换行，\r\n）结尾的一行明文，用 16 进制数字表示长度
* 数据块紧跟在长度头之后，最后也用 CRLF 结尾，但数据不包括 CRLF
* 最后用一个长度为 0 的块表示结束，即 0\r\n\r\n

*分块传输数据结构*

<img src="../Images/分块传输数据结构.png" style="zoom:50%;" />



#### 请求

##### 请求方法

*HTTP 请求方法*

![](../Images/HTTP请求方法.jpg)

目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式

* GET

  获取资源，读取或下载数据

* HEAD

  获取资源的元数据

* POST

  向资源提交数据，相当于写入或上传数据

* PUT

  类 POST

* DELETE

  删除资源

* CONNECT

  建立特殊的连接隧道

* OPTIONS

  列出可对资源实行的方法

* TRACE

  追踪请求 - 响应的传输路径

##### 安全和幂等

在 HTTP 协议里，安全是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源造成实质的修改。即只有 HEAD 和 GET 是安全的。**幂等**：多次执行相同的操作，结果也是相同的，即多次『幂』后结果『相等』

##### 范围请求

###### HTTP 范围请求

range requests，允许客户端在请求头里使用专用字段来表示只获取文件的一部分。

范围请求不是 Web 服务器必备的技能，可以实现也可以不实现，服务器必须在响应头里使用字段

* Accept-Ranges: bytes 明确告诉客户端，支持范围请求
* Accept-Range: none 或不发送 Accept-Range 字段来表示不支持范围请求

请求头 Range 是 HTTP 范围请求的专用字段，格式是 bytes=x-y，其中 x 和 y 是以字节为单位的数据范围，x 和 y 表示的是『偏移量』，范围必须从 0 计数，如前 10 个字节表示 0-9，第二个 10 字节表示 10-19。Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或倒数的范围，假设文件是 100 个字节，那么：

* 0- 表示从文档起点到文档终点，相当于 0-99，即整个文件
* 10- 表示从第 10 个字节开始到文档末尾，相当于 10-99
* -1 是文档的最后一个字节，相当于 99-99
* -10 是从文档末尾倒数 10 个字节，相当于 90-99

服务器收到 Range 字段后，需要做四件事

* 它必须检查范围是否合法，比如文件只有 100 个字节，但请求 200 ～ 300，这就是范围越界。服务器就会返回状态码 **416**，即『范围请求有误，无法处理，请再检查一下』
* 如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段，返回状态码 **206 Partial Content**
* 服务器要添加一个响应头字段 Content-Range，告诉片段实际偏移量和资源的总大小，格式是 **bytes x-y/length**，与 Range 头区别在于没有 =，范围后多了总长度。

常用视频进度条拖拽，多段下载、断点续传也是基于它实现的，要点是：

* 发送 HEAD，看服务器是否支持范围请求，同时获取文件的大小
* 开启多个线程，每个线程用 Range 字段划分出各自负责下载的片段，发送请求
* 即使意外中断，只要根据上次的下载记录，用 Range 请求剩下的一部分即可

###### 多段数据

范围请求一次只获取一个片段，它还支持在 Range 头里使用多个 x-y，一次性获取多个片段数据。

这种情况需要使用一种特殊的 MIME 类型 **multipart/byteranges**，表示报文的 body 是由多段字节列组成的，并且还要用一个参数 **boundary=xxx** 给出段之间的分隔标记。多段数据的格式与分块传输类似，但需要用分隔标记 boundary 来区分不同的片段

*多段数据格式*

<img src="../Images/多段数据格式.png" style="zoom:50%;" />

每一个分段必须以**- - boundary** 开始（前面加两个 -），之后要用 **Content-Type** 和 **Content-Range** 标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个 **-- boundary --** (前后各有两个 -)，表示所有的分段结束

##### 状态码

###### 1xx

属于提升信息，是协议处理的中间状态

* 101 Switching Protocols 是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，如 WebSocket。而服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了

###### 2xx

* 200 OK

  成功，如果非 HEAD 请求，通常在响应头后都会有 body 数据

* 204 No Content

  与 200 基本相同，但响应头后没有 body 数据

* 206 Partial Content

  是 HTTP 分块下载或断点续传的基础，在客户端发送『范围请求』，要求获取资源的部分数据时出现，与 200 一样，是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。206 通常还会伴随头字段 Content-Range，表示响应报文里 body 数据的具体范围，供客户端确认，Content-Range: bytes 0-99/2000 ，意思是此次获取的是总计 2000 个字节的前 100 个字节

###### 3xx

表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，即重定向

* 301 Moved Permanently

  永久重定向，即此次请求的资源已经不存在了，需要该用新的 URI 再次访问。

* 302 Found

  曾经的描述短语是 Moved Temporarily，即临时重定向，资源存在，但暂时需要用另一个 URI 来访问

* 304 Not Modified

  用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制，不具有通常的跳转含义，但可以理解成『重定向到已缓存的文件』，即缓存重定向

###### 4xx

表示客户端发送的请求报文有误，服务器无法处理

* 400 Bad Request

  请求报文错误

* 403 Forbidden

  服务器禁止访问资源

* 404 Not Found

  资源未找到

* 405 Method Not Allowed

  不允许使用某些方法操作资源

* 406 Not Acceptable

  资源无法满足客户端请求的条件

* 408 Request Timeout

  请求超时，服务器等待了过长的时间

* 409 Conflict

  多个请求发生了冲突，多线程并发时的竞争状态

* 413 Request Entity Too Large

  请求报文里的 body 太大

* 414 Request-URI Too Long

  请求行里的 URI 太大

* 429 Too Many Requests

  客户端发送了太多的请求，通常是由于服务器的限连策略

* 431 Request Header Fields Too Large

  请求头某个字段或总体太大

###### 5xx

表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法响应应有的响应数据，是服务器端的错误码

* 500 Internal Server Error

  通用错误码

* 501 Not Implemented

  客户端请求的功能还不支持

* 502 Bad Gateway

  服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因不知

* 503 Service Unavailable

  服务器忙，暂时无法响应服务，503 是一个临时状态，很可能几秒钟后服务器就正常，一般 503 响应报文里通常会有一个 Retry-After 字段，指示客户端可以在多久以后再次发送请求

#### HTTP 连接

##### 短连接

HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程采用了简单的『请求-应答』方式。底层数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为**短连接**（short-lived connections）。早期的 HTTP 协议也被称为是**无连接**的协议

短连接的缺点很严重，因为在 TCP 协议里，建立连接和关闭连接都是非常昂贵的操作。TCP 建立连接要**三次握手**，发送 3 个数据包，需要 1 个 RTT；关闭连接时**四次挥手**，4 个数据包需要 2 个 RTT。而 HTTP 的一次简单『请求 - 响应』通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。

##### 长连接

针对短连接暴露出的缺点，HTTP 协议就提出了**长连接**的通信方式，即**持久连接**（persistent connections）、**连接保活**（keep alive）、**连接复用**（connection reuse）。

##### 连接相关的头字段

由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。也可以在请求头里明确地要求使用长连接机制，使用的字段是 **Connection**，值为：**keep-alive**

因为 TCP 连接的长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连接不发送数据，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。所以长连接也需要在恰当的时候关闭，不能永远保持与服务器的连接，这在客户端或服务器都可以做到：

* 在客户端，可以在请求头里加上**Connection: close** 字段，即这次通信后关闭连接。

* 服务器通常不会主动关闭连接，但可以使用一些策略控制，如使用 nginx 服务器

  1.使用 **keepalive_timeout** 指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源

  2.使用**keepalive_requests** 指令，设置长连接上可发送的最大请求次数。当 nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接

客户端和服务器都可以在报文里附加通用头字段**Keep-Alive: timeout=value**，限定长连接的超时时间。但这个字段的约束力并不强，通信双方可能并不会遵守，一般不使用

在长连接中的一个重要问题是如何正确地区分多个报文的开始和结束，最好总使用 Content-Length 头明确响应实体的长度，正确标记报文结束。如果是流式传输，body 长度不能立即确定，必须用分块传输编码

###### DDos 攻击

利用 HTTP 的长连接特性对服务器发起大量请求，导致服务器最终耗尽资源『拒绝服务』

#### 重定向

重定向是服务器发起的跳转，要求客户端该用新的 URI 重新发送请求，通常会自动进行，用户是无感知的。**Location** 字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它**标记了服务器要求重定向的 URI**。浏览器收到 301/302 报文，会检查响应头里有没有 Location。如果有，就从字段里提取出 URI，发出新的请求。在 Location 里 URI 既可以使用绝对 URI，也可以使用相对 URI。与跳转有关的还有一个 Referer 和 Referrer-Policy 字段表示浏览器跳转的来源，即引用地址，可用于统计分析和防盗链。

##### 重定向的相关问题

* 性能损耗

  重定向的机制决定了一个跳转会有两次请求-应答，比正常的访问多了一次

* 循环跳转

  如果重定向的策略设置欠考虑，可能出现 A=>B=>C=>A 的无限循环，HTTP 协议规定，浏览器必须具有检测『循环跳转』的能力，在发现这种情况时应答停止发送请求并给出错误提示

#### Cookie 工作机制

当用户通过浏览器第一次访问服务器的时候，服务器会创建一个独特的身份标识数据，格式是 key=value，使用 ;分隔，然后放入 Set-Cookie 字段里，随着响应报文一同发送给浏览器。浏览器收到响应报文，看到里面有 Set-Cookie，保存起来，下次请求时自动把这个值放进 Cookie 字段里发送给服务器。

##### Cookie 的属性

* 有效期

  **Expires** 和 **Max-Age** 两个属性来设置。

  * Expires 过期时间，用的是绝对时间点，可以理解为『截止日期』。
  * Max-Age 用的是相对时间，单位为秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。

  两者可以同时出现，两者值也可以不一致，浏览器优先采用 Max-Age 计算失效期。如果不指定 Expires 或 Max-Age 属性，那么 Cookie 仅在浏览器运行时有效，一旦浏览器关闭就会失效，这被称为会话 Cookie（session cookie）或内存 Cookie 在 Chrome 里过期时间会显示为 Session 或 N/A

* 作用域

  让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。使用 **Domain** 和 **Path** 指定 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。

* HttpOnly

  属性 HttpOnly 会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，浏览器的 JS 引擎就会禁用 document.cookie 等相关 API。可以防止 XSS 跨站脚步攻击

* SameSite

  可以防范跨站请求伪造 XSRF 工具，设置 SameSite=Strict 可以严格限定 Cookie 不能随着跳转链接跨站发送，而 SameSite=Lax ，允许 GET/HEAD 等安全发送，但禁止 POST 跨站发送

* Secure

  表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器还是以明文的形式存在

#### 缓存控制

#####  Cache-Control

服务器标记资源有效期使用的头字段是 **Cache-Control**：

*服务器缓存控制*

![](../Images/服务器缓存控制.png)

* max-age

  即资源的有效时间。max-age 是生存时间，时间的计算点是响应报文的创建时间，即 **Date** 字段，离开服务器的时刻。而不是客户端收到报文的时刻，包含了在链路传输过程中所有节点所停留的时间。在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存。

* no-store

  不允许缓存，用于某些变化非常频繁的数据

* no-cache

  可以缓存，但在使用之前必须去服务器验证是否过期，是否有最新的版本

* must-revalidate

  缓存不过期就可以继续使用，但过期了必须去服务器验证

服务器客户端都可以使用 **Cache-Control**，来进行缓存控制，互相协商缓存的使用策略。除了使用 Cache-Control，服务器可以用 Expires 字段来标记资源的有效期，但优先级低于 Cache-Control

##### 条件请求

浏览器用 Cache-Control 做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。

浏览器可以用两个连续的请求组成『验证动作』，先是一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一个 GET 请求，获取最新的版本，为了规避两个请求网络成本。

HTTP 协议定义了一系列 **If** 开头的 **条件请求** 字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里，而且验证责任也交给服务器。条件请求一共有 5 个头字段

* If-Modified-Since:<date>

  需要第一次的响应报文预先提供 Last-modified，后第二次请求带上缓存里的原值，验证资源是否是最新的。如果资源没有变化，服务器就响应 304 Not Modifed，表示缓存依然有效，浏览器可以更新一下有效期，然后使用缓存。**Last-modified 即资源最后修改时间**。

  如果自指定日期后，文档没有被修改过，条件位真，通常 GET 就会成功执行携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含一个新的过期日期

* If-None-Match:<tags>

  需要第一次的响应报文预先提供 **Etag** 字段，第二次再请求时带上该值，服务器验证该值与当前实体 Etag 是否相同。**ETag 是 Entity Tag 实体标签，资源唯一标识**。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个 W/ 标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变。
  
* If-Unmodified-Since

  在进行部分文件的传输时，获取文件的其余部分之前要确保文件未发生变化

* If-Range

  支持对不完整文件的缓存

* If-Match

  用于与 Web 服务器打交道时的并发控制

