### HTTP 相关概念

#### URI/URL

##### URI

URI Uniform Resource Identifier 统一资源标识符，使用它能够唯一地标记互联网上资源，URI 主要有三个基本的部分构成：

![](../Images/完整URI组成.png)

* 身份信息 (不推荐)

  表示登录主机时的用户名和密码，但现在一句不推荐使用这种形式了，它会将敏感信息以明文形式暴露出来

* 协议名 `Scheme`

  即访问该资源应当使用的协议，如 `http`、`ftp`

* 主机名 `authority`

  即互联网上的标记，可以是域名或 IP 地址，表示资源所在的主机名，通常为 `host:port`

* 路径 `path`

  即资源在主机上的位置，使用 `/` 分割多级目录。URI 的 path 部分必须以 `/` 开始，即必须包含 `/`

* 查询参数 `query` 

  URL 查询参数 `query`，它在 `path` 之后，用一个 `?` 开始，但不包含 `?`，表示对资源附加的额外要求。查询参数是多个 `key=value` 的字符串，使用 `&` 连接

* 片段标识符 `#fragment`

  它是 URI 所定位的资源内部的一个 “锚点”，浏览器可以在获取资源后直接跳转到它指示的位置。仅能由浏览器这样的客户端使用，服务器是看不到的，浏览器永远不会把带 `#fragment` 的 URI 发送给服务器，服务器也永远不会用这种方式处理资源的片段

URI 本质上是一个字符串，这个字符串的作用是唯一的标记资源的位置或者名字。它不仅能标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。

客户端和服务器看到的 URI 是不一样的，客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。

在 `nginx` 中，它的 `location`、`rewrite` 等指令操作的 URI 指的是真正 URI 里的 path 和后续的部分

##### URL

* URL Uniform Resource Locator 统一资源定位符，即网址，它是 URI 的一个子集

#### 代理

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。常见代理：

* 匿名代理

  完全“隐匿”了被代理的机器，外界看到的只是代理服务器

* 透明代理

  传输过程是“透明开发”的，外界既知道代理，也知道客户端

* 正向代理

  靠近客户端，代表客户端向服务器发送请求

* 反向代理

  靠近服务器端，代表服务器响应客户端的请求

由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意义的事情：

* 负载均衡

  把访问请求均匀分散到多台机器，实现访问集群化

* 内容缓存

  暂存上下行的数据，减轻后端的压力

* 安全防护

  隐匿 IP，使用 WAF 等工具抵御网络攻击，保护被代理的机器

* 数据处理

  提供压缩，加密等额外的功能

#### 域名

域名是一个有层次的结构，是一串用 `.` 分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。最左边的是主机名，通常用来表明主机的用途，如 `www` 表示提供万维网服务，`mail` 表示提供邮件服务。在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由那个虚拟主机来对外提供服务。

##### 域名解析

DNS 核心系统是一个三层的树状、分布式服务，基本对应域名的结构：

* 根域名服务器 Root DNS Server

  管理顶级域名服务器，返回 `com` 、`net`、`cn` 等顶级域名服务器的 IP 地址

* 顶级域名服务器 Top-level DNS Server

  管理各自域名下的权威域名服务器，如 `com` 顶级域名服务器可以返回 `apple.com` 域名服务器的 IP 地址

* 权威域名服务器 Authoritative DNS Server

  管理自己域名下主机的 IP 地址，如 `apple.com` 权威域名服务器可以范围 `www.apple.com` 的 IP 地址

nginx 中的 `resolver` 指令，就是用来配置 DNS 服务器的，如果没有它，那么 `nginx` 就无法查询域名对应的 IP，也就无法反向代理到外部的网站

```nginx
# 指定 Google 的 DNS，缓存 30s
resolver 8.8.8.8 valid = 30s
```

#### HTTP 报文

HTTP 协议的请求报文和响应报文的机构基本相同，由三大部分组成

* 起始行（start line）

  描述请求或响应的基本信息

* 头部字段集合（header）

  使用 `key-value` 形式更详细地说明报文

* 消息正文（entity）

  实际传输的数据，可能是文本，图片，视频等二进制数据

HTTP 协议规定报文必须有 header ，但可以没有 body，而且 header 之后必须要有一个“空行”，即 `CRLF`，十六进制 `0D0A`.

##### 请求行 request line

描述了**客户端想要如何操作服务端的资源**，请求行由三部分构成：

* 请求方法

  是一个动词，如 GET/POST，表示对资源的操作

* 请求目标

  通常是一个 URI，标记了请求方法要操作的资源

* 版本号

  表示报文使用的 HTTP 协议版本

这三部分通常使用空格来分隔，最后用 CRLF 换行表示结束

##### 状态行 status line

即服务器响应的状态

* 版本号

  表示报文使用的 HTTP 协议版本

* 状态码

  数字，表示处理结果

* 原因

  数字状态码的补充

请求头和响应头的结构基本一样，唯一的区别是起始行。头部字段是 `key-value` 的形式，key 和 value 之间用 `:`  分隔，最后用 `CRLF` 换行表示字段技术。HTTP 头部字段非常灵活，可以任意添加自定义头，使用头字段：

* 字段名不区分大小写，但首字母大写的可读性更好
* 字段名里不允许出现空格，**可以使用连字符 `-`，但不能使用下划线 `_`**
* 字段名后面必须紧接着 `:`，不能有空格，而 `:` 后字段值前可有有多个空格
* 字段的属性没有意义，可以任意排列不影响语义
* 字段原则上不能重复，除非这个字段本身的语义允许，如 `Set-Cookie`

##### HTTP 头部字段

HTTP 协议规定了非常多的头部字段，实现各种功能：

* 通用字段

  在请求头和响应头里都可以出现

* 请求字段

  仅能出现在请求头里，进一步说明请求信息或者额外的附加条件

* 响应字段

  仅能出现在响应头里，补充说明响应报文的信息

* 实体字段

  实际属于通用字段，但专门描述 body 的额外信息

|   类型   |      key       |                             含义                             | 必须出现 |
| :------: | :------------: | :----------------------------------------------------------: | :------: |
| request  |      Host      | 告诉服务器这个请求应该由那个主机来处理，当一台计算机托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择 |   true   |
| request  |   User-Agent   |                     描述 HTTP 请求客户端                     |          |
| general  |      Date      | 通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略 |          |
| response |     Server     |             正在提供 Web 服务器的软件名和版本号              |          |
|  entity  | Content-Length | 表示报文 body 的长度，即请求头或请求行空行后面的数据长度，如果没有该字段，那么body就是不定长的，需要使用 chunked 方式分段传输 |          |

#### 请求方法

*HTTP 请求方法*

![](../Images/HTTP请求方法.jpg)

目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式

* GET

  获取资源，读取或下载数据

* HEAD

  获取资源的元数据

* POST

  向资源提交数据，相当于写入或上传数据

* PUT

  类 POST

* DELETE

  删除资源

* CONNECT

  建立特殊的连接隧道

* OPTIONS

  列出可对资源实行的方法

* TRACE

  追踪请求 - 响应的传输路径

##### 安全和幂等

在 HTTP 协议里，安全是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源造成实质的修改。即只有 HEAD 和 GET 是安全的。**幂等**：多次执行相同的操作，结果也是相同的，即多次“幂”后结果“相等”

#### 状态码

##### 1xx

属于提升信息，是协议处理的中间状态

* `101 Switching Protocols` 是客户端使用 `Upgrade` 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，如 `WebSocket`。而服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了

##### 2xx

* `200 OK`

  成功，如果非 HEAD 请求，通常在响应头后都会有 body 数据

* `204 No Content`

  与 200 基本相同，但响应头后没有 body 数据

* `206 Partial Content`

  是 HTTP 分块下载或断点续传的基础，在客户端发送 ”范围请求“，要求获取资源的部分数据时出现，与 200 一样，是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。206 通常还会伴随头字段 `Content-Range`，表示响应报文里 `body` 数据的具体范围，供客户端确认，`Content-Range: bytes 0-99/2000` ，意思是此次获取的是总计 2000 个字节的前 100 个字节

##### 3xx

表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，即重定向

* `301 Moved Permanently`

  永久重定向，即此次请求的资源已经不存在了，需要该用新的 URI 再次访问。

* `302 Found`

  曾经的描述短语是 `Moved Temporarily`，即临时重定向，资源存在，但暂时需要用另一个 URI 来访问

* `304 Not Modified`

  用于 `If-Modified-Since` 等条件请求，表示资源未修改，用于缓存控制，不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”，即缓存重定向

##### 4xx

表示客户端发送的请求报文有误，服务器无法处理

* `400 Bad Request`

  请求报文错误

* `403 Forbidden`

  服务器禁止访问资源

* `404 Not Found`

  资源未找到

* `405 Method Not Allowed`

  不允许使用某些方法操作资源

* `406 Not Acceptable`

  资源无法满足客户端请求的条件

* `408 Request Timeout`

  请求超时，服务器等待了过长的时间

* `409 Conflict`

  多个请求发生了冲突，多线程并发时的竞争状态

* `413 Request Entity Too Large`

  请求报文里的 body 太大

* `414 Request-URI Too Long`

  请求行里的 URI 太大

* `429 Too Many Requests`

  客户端发送了太多的请求，通常是由于服务器的限连策略

* `431 Request Header Fields Too Large`

  请求头某个字段或总体太大

##### 5xx

表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法响应应有的响应数据，是服务器端的错误码

* `500 Internal Server Error`

  通用错误码

* `501 Not Implemented`

  客户端请求的功能还不支持

* `502 Bad Gateway`

  服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因不知

* `503 Service Unavailable`

  服务器忙，暂时无法响应服务，503 是一个临时状态，很可能几秒钟后服务器就正常，一般 503 响应报文里通常会有一个 `Retry-After` 字段，指示客户端可以在多久以后再次发送请求

#### HTTP 连接

##### 短连接

HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程采用了简单的“请求-应答”方式。底层数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为**短连接**（short-lived connections）。早期的 HTTP 协议也被称为是**无连接**的协议

短连接的缺点很严重，因为在 TCP 协议里，建立连接和关闭连接都是非常”昂贵“的操作。TCP 建立连接要**三次握手**，发送 3 个数据包，需要 1 个 RTT；关闭连接时**四次挥手**，4 个数据包需要 2 个 RTT。而 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。

##### 长连接

针对短连接暴露出的缺点，HTTP 协议就提出了**长连接**的通信方式，即**持久连接**（persistent connections）、**连接保活**（keep alive）、**连接复用**（connection reuse）。

##### 连接相关的头字段

由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。也可以在请求头里明确地要求使用长连接机制，使用的字段是 **`Connection`**，值为：**`keep-alive`**

因为 TCP 连接的长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连接不发送数据，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。所以长连接也需要在恰当的时候关闭，不能永远保持与服务器的连接，这在客户端或服务器都可以做到：

* 在客户端，可以在请求头里加上**Connection: close** 字段，即这次通信后关闭连接。

* 服务器通常不会主动关闭连接，但可以使用一些策略控制，如 nginx：

  1.使用 **keepalive_timeout** 指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源

  2.使用**keepalive_requests** 指令，设置长连接上可发送的最大请求次数。当 nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接

客户端和服务器都可以在报文里附加通用头字段**Keep-Alive: timeout=value**，限定长连接的超时时间。但这个字段的约束力并不强，通信双方可能并不会遵守，一般不使用

在长连接中的一个重要问题是如何正确地区分多个报文的开始和结束，最好总使用 `Content-Length` 头明确响应实体的长度，正确标记报文结束。如果是流式传输，`body` 长度不能立即确定，就必须用分块传输编码

利用 HTTP 的长连接特性对服务器发起大量请求，导致服务器最终耗尽资源“拒绝服务”，这就是常说的 DDoS

