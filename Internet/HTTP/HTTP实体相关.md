## HTTP Body

### 数据类型与编码

在 TCP/IP 协议栈里，传输数据基本上都是 `header + body` 的格式。但 TCP、UDP 因为是传输层协议，不会关心 body 数据是什么，只要把数据发送到对方就算完成任务。而 HTTP 是应有层协议，数据到达之后还需要告诉上层应用这是什么数据才行，即数据类型。

#### 多用途互联网邮件扩展 MIME

MIEM（Multipurpose Internet Mail Extensions）是一个很大的标准规范，但 HTTP 只取了其中的一部分，用来标记 `body` 的数据类型，即 `MIME type`。MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是 `type/subtype` 的字符串。HTTP 里经常遇到的类别

* **text**

  即文本格式的可读数据，如超文本文档（text/html），纯文本（text/plain），样式表（text/css）

* **image**

  即图像文件，如 `image/gif`、`image/jpge`、`image/png`

* **audio/video**

  音视频数据，如 `audio/mpeg`、`video/mp4`

* **application**

  数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。如 `application/json`，`application/javascript`，`application/pdf`等。`application/octet-stream` ：不透明的二进制数据

但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不让浏览器继续猜，还需要一个 `Encoding type`，告诉数据时用什么编码格式。常用的 Encoding type

* `gzip`

  GNU zip 压缩格式

* `deflate`

  zlib 压缩格式

* `br`

  一种专门为 HTTP 优化的新压缩算法

#### 数据类型使用的头字段

HTTP 协议定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行**内容协商**，即客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 `Content` 头告诉客户端实际发送了什么样的数据

* Accept

  请求字段标记的是客户端可理解的 MIME type，可以用 `,` 分隔列出多个类型，让服务器有更多的选择余地。

* Accept-Encoding

  请求字段标记的是客户端支持的压缩格式，可以用 `,` 分隔

* Content-Type

  通用字段，实体数据的真实类型，对应 Accpet，如 POST 请求的实体类型，或响应的 body 类型

* Content-Encoding

  实际使用的压缩格式

#### 语言类型和编码

HTTP 为解决国际化的问题，引入了：语言类型和字符集

* 语言类型

  即自然语言，分隔符是 `-`，如 `en` 表示任意的英语，`en-US` 表示美式英语，`en-GB` 表示英式语言，`zh-CN` 汉语

* 字符集

  如 UTF-8

##### 语言类型使用的头字段

HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言和编码进行“内容协商”

* Accept-Language

  请求字段标记了客户端可理解的自然语言，用 `,` 做分隔符列出多个类型

* Accept-Charset

  请求字段指定字符集

##### 内容协商的质量值

在 HTTP 协议里用 `Accept`，`Accept-Encoding`，`Accept-Language` 等请求头字段进行内容协商，还可以用 `q` 参数表示权重来设定优先级，`q` 即 `quality factor`，权重的最大值是 1，最小值是 `0.01` ，默认值是 1，如果值是 0 就表示拒绝。在数据类型或语言代码后面加 `;`，后接 `q=value`

```http
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

##### 内容协商的结果

内容协商的过程是不透明的，每个 web 服务器使用的算法都不一样，但有时，服务器会在响应头里多加一个 **Vary** 字段，记录服务器在内容协商时参考的请求头字段

```HTTP
# 服务器依据 Accept-Encoding,User-Agent,Accept 三个头字段决定了发回的响应报文
Vary: Accept-Encoding,User-Agent,Accept
```

### 大文件传输

#### 数据压缩

传输数据时开启压缩，但 gzip 等压缩算法通常只对文本有较好的压缩率，而图片、音视频等多媒体数据本身已经是高度压缩，再用 gzip 处理也不会变小（甚至还有可能会增大一点）。在 Nginx 里会使用 `gzip on` 指令，启用对 `text/html` 压缩

#### 分块传输

HTTP 协议就是 `chunked` 分块传输编码，在响应报文里用头字段 **`Transfer-Encoding: chunked`** 来表示，即报文里的 `body` 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

分块传输也可以用于“流式数据”，这种情况下 body 数据的长度是未知的，无法在头字段 **`Content-Length `**里给出具体长度。

`Transfer-Encoding: chunked` 和 `Contenting-Length` 字段是**互斥**的，即响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知的，要么是长度未知（chunked）。

分块传输采用了明文的方式，类似响应头

*分块传输数据结构*

![](../Images/分块传输数据结构.png)

* 每个分块包含两个部分，长度头和数据库
* 长度头是以 `CRLF` （回车换行，即 `\r\n`）结尾的一行明文，用 16 进制数字表示长度
* 数据块紧跟在长度头之后，最后也用 CRLF 结尾，但数据不包括 CRLF
* 最后用一个长度为 0 的块表示结束，即 `0\r\n\r\n`

#### 范围请求

range requests，允许客户端在请求头里使用专用字段来表示只获取文件的一部分。范围请求不是 Web 服务器必备的技能，可以实现也可以不实现，所以服务器必须在响应头里使用字段 `Accept-Ranges: bytes` 明确告诉客户端：支持范围请求，或 `Accept-Range: none` 或不发送 `Accept-Range` 字段来表示不支持范围请求

请求头 Range 是 HTTP 范围请求的专用字段，格式是 `bytes=x-y` ，其中 `x` 和 `y` 是以字节为单位的数据范围，x 和 y 表示的是 “偏移量”，范围必须从 0 计数，如前 10 个字节表示 `0-9`，第二个 10 字节表示 `10-19`。Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或倒数的范围，假设文件是 100 个字节，那么：

* `0-` 表示从文档起点到文档终点，相当于 `0-99`，即整个文件
* `10-` 表示从第 10 个字节开始到文档末尾，相当于 `10-99`
* `-1` 是文档的最后一个字节，相当于 `99-99`
* `-10` 是从文档末尾倒数 10 个字节，相当于 `90-99`

服务器收到 Range 字段后，需要做四件事

* 它必须检查范围是否合法，比如文件只有 100 个字节，但请求 200 ～ 300，这就是范围越界。服务器就会返回状态码 **416**，即 “范围请求有误，无法处理，请再检查一下“
* 如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段，返回状态码 **206 Partial COntent**
* 服务器要添加一个响应头字段 `Content-Range`，告诉片段实际偏移量和资源的总大小，格式是 **`bytes x-y/length`**，与 `Range` 头区别在于没有 `=`，范围后多了总长度。

常用视频进度条拖拽，多段下载、断点续传也是基于它实现的，要点是：

* 发送 HEAD，看服务器是否支持范围请求，同时获取文件的大小
* 开启多个线程，每个线程用 Range 字段划分出各自负责下载的片段，发送请求
* 即使意外中断，只要根据上次的下载记录，用 Range 请求剩下的一部分即可

#### 多段数据

范围请求一次只获取一个片段，它还支持在 Range 头里使用多个 `x-y`，一次性获取多个片段数据。这种情况需要使用一种特殊的 MIME 类型 **multipart/byteranges**，表示报文的 body 是由多段字节列组成的，并且还要用一个参数**`boundary=xxx`** 给出段之间的分隔标记。多段数据的格式与分块传输类似，但需要用分隔标记 `boundary` 来区分不同的片段

*多段数据格式*

![](../Images/多段数据格式.png)

每一个分段必须以**` - - boundary`** 开始（前面加两个 `-`），之后要用 **`Content-Type`** 和 **`Content-Range`** 标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个 **`- - boundary - -`** (前后各有两个 `-`)，表示所有的分段结束



