### HTTP 相关

#### WebSocket

##### 特点

* WebSocket 是一个真正的“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，
* 采用二进制帧结构，算法，语义与 HTTP 完全不兼容
* 服务器发现方面，WebSocket 采用了 URI 格式：`ws` 和 `wss`，对应端口 80 和 443

##### 帧格式

*WebSocket帧结构定义*

![](../Images/WebSocket帧结构.png)

*长度不固定，最少2个字节，最多14字节*

* 开头两个字节是必须的

  第一个字节的第一位 `FIN` 是消息结束的标志位，相当于 HTTP/2 里的 `END_STREAM`，表示数据发送完毕。一个消息可以拆成多个帧，接收方看到 `FIN` 后，就可以把前面的帧拼起来，组成完整的消息

* FIN 后三位是保留位，目前没有任何意义，必须是 0

* 第一个字节的后 4 位是 `Opcode`，操作码，即帧类型，1 即纯文本，2 是二进制数据，8 关闭连接，9 和 10 分别是连接保活的 PING 和 PONG

* 第二个字节后 7 位是 `Payload len`，即帧内容长度，它是一种变长编码，最少 7 位，最多 7 + 64 位，即额外增加 8 字节，一个 WebSocket 帧最大是 2^64

* Masking-key，掩码密钥，由标志位 `MASK` 决定的，如果掩码就是 4 个字节的随机数，否则就不存在

##### WebSocket 的握手

和 TCP、TLS 一样，WebSocket 也要有一个握手过程，然后才能正式收发数据。WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：

* `Connection: Upgrade`，表示要求协议升级
* `Upgrade: websocket`，表示要升级成 WebSocket 协议

为了防止普通的 HTTP 消息被意外识别成 WebSocket，握手消息还增加了两个额外的认证用头字段

* `Sec-WebSocket-key`：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥
* `Sec-WebSocket-Version`：协议的版本号，当前必须 13

*websocket握手*

![](../Images/websocket握手.png)

服务器收到 HTTP 请求报文，看到上面几个字段，就知道这是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的 `101 Switching Protocols` 响应报文，通知客户端。

WebSocket 的握手响应报文也有特殊格式，要用字段 `Sec-WebSocket-Accept` 验证客户端请求报文，同样也是为了防止误连接。流程是将请求头里的 `Sec-WebSocket-Key` 的值，加上一个专用 UUID  `258EAFA5-E914-47DA-95CA-C5AB0DC85B11`，再计算 SHA-1 摘要

```java
encode_base64(
  sha1( 
    Sec-WebSocket-Key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11' ))
```

客户端收到响应报文，就可以用同样的算法，比较值是否相等，如果相等，说明返回的报文确实是刚才握手时连接的服务器，认证成功，握手完成，后续传输数据即为 WebSocket 格式二进制帧

#### CDN

##### Content Delivery Network

外部加速 HTTP 协议的服务。CDN 的核心原则是『就近访问』。主要适用缓存代理技术，使用『推』或『拉』的手段，把源站的内容逐级缓存到网络的每一个节点上。用户在上网的时候就不直接访问源站，而是访问离他最近的一个 CDN 节点（边缘节点）即缓存了源站内容的代理服务器。

在 CDN 领域里，『内容』即 HTTP 协议的『资源』，比如超文本、图片、视频、应用程序安装包。资源按照是否可缓存分为：

* 静态资源

  数据内容静态不变，任何时候来访问都是一样的，如图片、音频

* 动态资源 

  由服务器实时计算生成的。每次访问不一样。

只有静态资源才能被缓存加速、就近访问，而动态资源只能由源站实时生成，即使缓存了也没有意义。不过，如果动态资源指定了 Cache-Control，允许缓存短暂的时候，那它在这段时间里就变成了『静态资源』，可以被 CDN 缓存加速

##### CDN 负载均衡

CDN 有两个关键组成部分：**全局负载均衡**和**缓存系统**，对应的是 DNS 和缓存代理技术。

全局负载均衡（Global Server Load Balance）GSLB，它是 CDN 的大脑，主要职责是当用户接入网络的时候在 CDN 专网中挑选出一个最佳节点提供服务，解决的是用户如何找到最近的边缘节点，对整个 CDN 网络进行“负载均衡”。

GSLB 最常见的实现方式是 “DNS负载均衡”，原来没有 CDN 的时候，权威 DNS 返回的是网站自己服务器的实际 IP 地址，浏览器收到 DNS 解析结果后直连网站。但加入 CDN 后，权威 DNS 返回的不是 IP 地址，而是一个 CNAME（Canonical Name）别名记录，指向的就是 CDN 的 GSLB。因为没能获取 IP 地址，于是本地 DNS 就会向 GSLB 再发起请求，这样就进入了 CDN 的全局负载均衡系统，开始调度，依据：

* 看用户的 IP 地址，查表得到地理位置，找相对最近的边缘节点
* 看用户所在的运营商网络，找相同网络的边缘节点
* 检查边缘节点的负载情况，找负载较轻的节点
* 检查节点的服务能力，带宽，响应时间等

GSLB 会根据这些因素，用算法，找出一个最合适的边缘节点。把这个节点的 IP 地址返回给用户，用户就可以就近访问 CDN 的缓存代理

##### CDN 缓存代理

缓存系统是 CDN 的另一个关键组成部分，衡量 CDN 服务质量的指标：“命中率”和“回源率”

* 命中

  指用户访问的资源恰好在缓存系统里，可以直接返回给用户

* 回源

  缓存里没有，必须使用代理的方式回源站取

