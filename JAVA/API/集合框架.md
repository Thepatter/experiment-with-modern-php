### 根集合接口  `java.util.Collection<E>`

* `Iterator<E> iterator()`

  返回一个用于访问集合中每个元素的迭代器

* `int size()`

  返回当前存储在集合中的元素个数

* `boolean isEmpty()`

  如果集合中没有元素，返回 `true`

* `boolean contains(Object obj)`

  如果集合中包含了一个与 `Obj` 相等的对象，返回 true

* `boolean containsAll(Collection<?> other)`

  如果这个集合包含 other 集合中的所有元素，返回 true

* `boolean addAll(Collection<? extends E> other)`

  将 other 集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回 true

* `boolean remove(Object obj)`

  从这个集合中删除等于 obj 的对象。如果有匹配的对象被删除，返回 true

* `boolean removeAll(Collection<?> other)`

  从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true

* `default boolean removeIf(Predicate<? super E> filter)`

  从这个集合删除 `filter` 返回 true 的所有元素。如果由于这个调用改变了集合，则返回 true

* `void clear()`

  从这个集合中删除所有的元素

* `boolean retainAll(Collection<?> other)`

  从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 true

* `Object[] toArray()`

  返回这个集合的对象数组

* `<T> T[] toArray(T[] arrayToFill)`

  返回这个集合的对象数组。如果 `arrayToFill` 足够大，就将集合中的元素填入这个数组中。剩余空间填补 null；否则，分配一个新数组，其成员类型与 `arrayToFill` 的成员类型相同，其长度等于集合的大小，并填充集合元素

### 迭代器接口 `java.util.Iterator`

* `boolean hasNext()`

  如果存在可访问的元素，返回 true

* `E next()`

  返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 `NoSuchElementException`

* `void remove()`

  删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`

### 列表`java.util.list<E>`

* `ListIterator<E> listIterator()`

  返回一个列表迭代器，以便用来访问列表中的元素

* `ListIterator<E> listIterator(int index)`

  返回一个列表迭代器，以便用来访问列表中的元素，这个元素是第一次调用 `next` 返回的给定索引的元素

* `void add(int i, E element)`

  在给定位置添加一个元素

* `void addAll(int i, Collection<? extends E> elements)`

  将某个集合中的所有元素添加到给定位置

* `E remove(int i)`

  删除给定位置的元素并返回这个元素

* `E set(int i, E element)`

  用新元素取代给定位置的元素，并返回原来那个元素

* `int indexOf(Object element)`

  返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回 -1.

* `int lastIndexOf(Object element)`

  返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回 -1

### 列表迭代器`java.util.ListIterator`

* `void add(E newElement)`

  在当前位置前添加一个元素

* `void set(E newElement)`

  用新元素取代 `next` 或 `previous` 上次访问的元素。如果在 `next` 或 `previous` 上次调用之后列表结构被修改了，将抛出一个 `IllegalStateException` 异常

* `boolean hasPrevious()`

  当反向迭代列表时，还有可供访问的元素，返回 true

* `E previous()`

  返回前一个对象。如果已经到达了列表的头部，就抛出一个 `NoSuchElementException` 异常

* `int nextIndex()`

  返回下一次调用 `next` 方法时将返回的元素索引

* `int previousIndex()`

  返回下一次调用 `previous` 方法时将返回的元素索引

### 链表`java.util.LinkedList<E>`

* `LinkedList()`

  构造一个空链表

* `LinedList(Collection<? extends E> elements)`

  构造一个链表，并将集合中所有的元素添加到这个链表中

* `void addFirst(E element)`

* `void addLast(E element)`

  将某个元素添加到列表的头部或尾部

* `E getFirst()`

* `E getLast()`

  返回列表头部或尾部的元素

* `E removeFirst()`

* `E removeLast()`

  删除并返回列表头部或尾部的元素

### 集合 `java.util.HashSet<E>`

* `HashSet()`

  构造一个空的散列表

* `HashSet(Collection<? extends E> element)`

  构造一个散列集，并将集合中的所有元素添加到这个散列集中

* `HashSet(int initialCapacity)`

  构造一个空的具有指定容量（桶数）的散列集

* `HashSet(int initialCapacity, float loadFactor)`

  构造一个具有指定容量和装填因子（一个0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列）的空散列集

### 树集合 `java.util.TreeSet<E>`

* `TreeSet()`

* `TreeSet(Comparator<? super E> comparator)`

  构造一个空的树集合

* `TreeSet(Collection<? extends E> elements)`

* `TreeSet(SortedSet<E> s)`

  构造一个树集合，并增加一个集合或有序集合中的所有元素（对于后一种情况，要使用同样的顺序）

### 有序集合 `java.util.SortedSet<E>`

* `Comparator<? super E> comparator()`

  返回用于对元素进行排序的比较器。如果元素用 `Comparable` 接口的 `comparaTo` 方法进行比较则返回 null

* `E first()`

* `E last()`

  返回有序集合中的最小或最大元素

### `java.util.NavigableSet<E>`

* `E higher(E value)`

* `E lower(E value)`

  返回大于 `value` 的最小元素或小于 `value` 的最大元素，如果没有这样的元素则返回 `null`

* `E ceiling(E value)`

* `E floor(E value)`

  返回大于等于 `value` 的最小元素或小于等于 `value` 的最大元素，如果没有这样的元素则返回 null

* `E pollFIrst()`

* `E pollLast()`

  删除并返回这个集中的最大元素或最小元素，这个集为空时返回 null

* `Iterator<E> descendlingIterator()`

  返回一个按照递减顺序遍历集中元素的迭代器

### 队列 `java.util.Queue<E>`

* `boolean add(E element)`

* `boolean offer(E element)`

  如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回 true。如果队列满了，第一个方法将抛出一个 `IllegalStateException`，而第二个方法返回 `false`

* `E remove()`

  `E poll()`

  假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出 `NoSuchElementException`，而第二个方法返回 null

* `E  element()`

* `E  peek()`

  如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法将抛出一个 `NoSuchElementException`，而第二个方法返回 null

### 双端队列 `java.util.Deque<E>`

* `void addFirst(E element)`

* `void addLast(E element)`

* `boolean offerFirst(E element)`

* `boolean offerLast(E element)`

  将给定的对象添加到双端队列的头部或尾部。如果队列满了，前面两个方法将抛出一个 `IllegalStateException` ，而后面两个方法返回 false

* `E removeFirst()`

* `E removeLast()`

* `E pollFIrst()`

* `E pollLast()`

  如果队列不空，删除并返回队列头部的元素。如果队列为空，前面两个方法将抛出 `NoSuchElementException` ，而后面两个方法返回 `null`

* `E getFirst()`

* `E getLast()`

* `E peekFirst()`

* `E peekLast()`

  如果队列非空，返回队列头部的元素，但不删除。如果队列空，前面两个方法将抛出一个 `NoSuchElementException` ，而后面两个方法返回 null

### `java.util.ArrayDeque<E>`

* `ArrayDeque()`

* `ArrayDeque(int initialCapacity)`

  用初始容量 16 或给定的初始容量构造一个无限双端队列

### 优先队列 `java.util.PriorityQueue`

* `PriorityQueue()`

* `PriorityQueue(int  initialCapacity)`

  构造一个用于存放 `Comparable` 对象的优先级队列

* `PriorityQueue(int initialCapacity, Comparator<? super  E> c)`

  构造一个优先级队列，并用指定的比较器对元素进行排序

### `java.util.Map<K, V>`

* `default V merge(k key, V value, BiFuntion<? super V, ? super V, ? extends V> remappingFunction)`

  如果 `key` 与一个非 `null` 值 v 关联，将函数应用到 `v` 和 `value`，将 `key` 与结果关联，或者如果结果为 null，则删除这个键。否则，将 `key` 与 `value` 关联，返回 `get(key)`

* `default V compute(K key, BiFunction<? super K, ? super V, ? extends V>remappingFunction)`

  将函数应用到 `key` 和 `get(key)`。将 `key` 与结果关联，或者如果结果为 null，则删除这个键。返回 `get(key)`

* `default V computeIfPresent(K key, BiFunction<? super K, ? super V,? extends V> remappingFunction)`

  如果 `key` 与一个非 `null` 值 `v` 关联，将函数应用到 `key` 和 `v`，将 `key` 与结果关联，或者如果结果为 null，则删除这个键。返回 `get(key)`

* `default V computeIfAbsent(K key, Function<? super K, ? extends V>mappingFunction)`

  将函数应用到 `key`，除非 `key` 与一个非 `null` 值关联。将 `key` 与结果关联，或者如果结果为 `null`，则删除这个键。返回 `get(key)`

* `Set<Map.Entry<K, V>> entrySet()`

  返回 `Map.Entry` 对象（映射中的键、值对）的一个集视图。可以从这个 集中删除元素，它们将从映射中删除，但是不能增加任何元素

* `Set<K> keySet()`

  返回映射中所有的键的一个集视图。可以从这个集中删除元素，键和相关的值将从映射中删除，但是不能增加任何元素

* `Collection<V> values()`

  返回映射中所有值的一个集合视图。可以从这个集合中删除元素，所删除的值及相应的键将从映射中删除，不过不能增加任何元素

### `java.util.Map.Entry<K, V>`

* `K getKey()`

* `V getValue()`

  返回这一条目的键或值

* `V setValue<V newValue)`

  将相关映射中的值改为新值，并返回原来的值

### 映射 `java.util.HashMap<K, V>`

* `HashMap()`

* `HashMap(int initialCapacity)`

* `HashMap(int initialCapacity, float loadFactor)`

  用给定的容量和装填因子构造一个空散列映射。默认装填因子是 0.75

### 有序映射 `java.util.TreeMap<K,V>`

* `TreeMap()`

  为实现 `Comparable` 接口的键构造一个空的树映射

* `TreeMap(Comparator<? super K> c)`

  构造一个树映射，并使用一个指定的比较器对键进行排序

* `TreeMap(Map<? extends k, ? extends V> entries)`

  构造一个树映射，将某个有序映射中的所有条目添加到树映射中。并使用与给定的有序映射相同的比较器

### `java.util.SortedMap<K, V>`

* `Comparator<? super K> comparator()`

  返回对键进行排序的比较器。如果键是用 `Comparable` 接口的 `compareTo` 方法进行比较的，返回 null

* `K firstKey()`

* `k lastKey()`

  返回映射中最小元素和最大元素

