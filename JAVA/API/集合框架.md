### 根集合接口  `java.util.Collection<E>`

* `Iterator<E> iterator()`

  返回一个用于访问集合中每个元素的迭代器

* `int size()`

  返回当前存储在集合中的元素个数

* `boolean isEmpty()`

  如果集合中没有元素，返回 `true`

* `boolean contains(Object obj)`

  如果集合中包含了一个与 `Obj` 相等的对象，返回 true

* `boolean containsAll(Collection<?> other)`

  如果这个集合包含 other 集合中的所有元素，返回 true

* `boolean addAll(Collection<? extends E> other)`

  将 other 集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回 true

* `boolean remove(Object obj)`

  从这个集合中删除等于 obj 的对象。如果有匹配的对象被删除，返回 true

* `boolean removeAll(Collection<?> other)`

  从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true

* `default boolean removeIf(Predicate<? super E> filter)`

  从这个集合删除 `filter` 返回 true 的所有元素。如果由于这个调用改变了集合，则返回 true

* `void clear()`

  从这个集合中删除所有的元素

* `boolean retainAll(Collection<?> other)`

  从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 true

* `Object[] toArray()`

  返回这个集合的对象数组

* `<T> T[] toArray(T[] arrayToFill)`

  返回这个集合的对象数组。如果 `arrayToFill` 足够大，就将集合中的元素填入这个数组中。剩余空间填补 null；否则，分配一个新数组，其成员类型与 `arrayToFill` 的成员类型相同，其长度等于集合的大小，并填充集合元素

* `default boolean removeIf(Predicate<? super E> filter)`

  删除所有匹配的元素

* `default void replaceAll(UnaryOperator<E> op)`

  对这个列表的所有元素应用这个操作

### 迭代器接口 `java.util.Iterator`

* `boolean hasNext()`

  如果存在可访问的元素，返回 true

* `E next()`

  返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 `NoSuchElementException`

* `void remove()`

  删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`

### 列表`java.util.list<E>`

* `ListIterator<E> listIterator()`

  返回一个列表迭代器，以便用来访问列表中的元素

* `ListIterator<E> listIterator(int index)`

  返回一个列表迭代器，以便用来访问列表中的元素，这个元素是第一次调用 `next` 返回的给定索引的元素

* `void add(int i, E element)`

  在给定位置添加一个元素

* `void addAll(int i, Collection<? extends E> elements)`

  将某个集合中的所有元素添加到给定位置

* `E remove(int i)`

  删除给定位置的元素并返回这个元素

* `E set(int i, E element)`

  用新元素取代给定位置的元素，并返回原来那个元素

* `int indexOf(Object element)`

  返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回 -1.

* `int lastIndexOf(Object element)`

  返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回 -1

* `List<E> subList(int firstIncluded, int firstExcluded)`

  返回给定位置范围内的所有元素的列表视图

* `default void sort(Comparator<? super T> comparator)`

  使用给定比较器对列表排序

### 列表迭代器`java.util.ListIterator`

* `void add(E newElement)`

  在当前位置前添加一个元素

* `void set(E newElement)`

  用新元素取代 `next` 或 `previous` 上次访问的元素。如果在 `next` 或 `previous` 上次调用之后列表结构被修改了，将抛出一个 `IllegalStateException` 异常

* `boolean hasPrevious()`

  当反向迭代列表时，还有可供访问的元素，返回 true

* `E previous()`

  返回前一个对象。如果已经到达了列表的头部，就抛出一个 `NoSuchElementException` 异常

* `int nextIndex()`

  返回下一次调用 `next` 方法时将返回的元素索引

* `int previousIndex()`

  返回下一次调用 `previous` 方法时将返回的元素索引

### 链表`java.util.LinkedList<E>`

* `LinkedList()`

  构造一个空链表

* `LinedList(Collection<? extends E> elements)`

  构造一个链表，并将集合中所有的元素添加到这个链表中

* `void addFirst(E element)`

* `void addLast(E element)`

  将某个元素添加到列表的头部或尾部

* `E getFirst()`

* `E getLast()`

  返回列表头部或尾部的元素

* `E removeFirst()`

* `E removeLast()`

  删除并返回列表头部或尾部的元素

### 集合 `java.util.HashSet<E>`

* `HashSet()`

  构造一个空的散列表

* `HashSet(Collection<? extends E> element)`

  构造一个散列集，并将集合中的所有元素添加到这个散列集中

* `HashSet(int initialCapacity)`

  构造一个空的具有指定容量（桶数）的散列集

* `HashSet(int initialCapacity, float loadFactor)`

  构造一个具有指定容量和装填因子（一个0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列）的空散列集

### 树集合 `java.util.TreeSet<E>`

* `TreeSet()`

* `TreeSet(Comparator<? super E> comparator)`

  构造一个空的树集合

* `TreeSet(Collection<? extends E> elements)`

* `TreeSet(SortedSet<E> s)`

  构造一个树集合，并增加一个集合或有序集合中的所有元素（对于后一种情况，要使用同样的顺序）

### 有序集合 `java.util.SortedSet<E>`

* `Comparator<? super E> comparator()`

  返回用于对元素进行排序的比较器。如果元素用 `Comparable` 接口的 `comparaTo` 方法进行比较则返回 null

* `E first()`

* `E last()`

  返回有序集合中的最小或最大元素

* `SortedSet<E> subSet(E firstIncluded, E firstExcluded)`

* `SortedSet<E> headSet(E firstExcluded)`

* `SortedSet<E> tailSet(E firstIncluded)`

  返回给定范围内的元素视图

### `java.util.NavigableSet<E>`

* `E higher(E value)`

* `E lower(E value)`

  返回大于 `value` 的最小元素或小于 `value` 的最大元素，如果没有这样的元素则返回 `null`

* `E ceiling(E value)`

* `E floor(E value)`

  返回大于等于 `value` 的最小元素或小于等于 `value` 的最大元素，如果没有这样的元素则返回 null

* `E pollFIrst()`

* `E pollLast()`

  删除并返回这个集中的最大元素或最小元素，这个集为空时返回 null

* `Iterator<E> descendlingIterator()`

  返回一个按照递减顺序遍历集中元素的迭代器

* `NavigableSet<E> subSet(E from, boolean fromIncluded, E to, boolean toIncluded)`

* `NavigableSet<E> headSet(E to, boolean toIncluded)`

* `NavigableSet<E> tailSet(E from, boolean fromInclued)`

  返回给定范围内的元素视图。`boolean` 标志决定视图是否包含边界

### 队列 `java.util.Queue<E>`

* `boolean add(E element)`

* `boolean offer(E element)`

  如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回 true。如果队列满了，第一个方法将抛出一个 `IllegalStateException`，而第二个方法返回 `false`

* `E remove()`

  `E poll()`

  假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出 `NoSuchElementException`，而第二个方法返回 null

* `E  element()`

* `E  peek()`

  如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法将抛出一个 `NoSuchElementException`，而第二个方法返回 null

### 双端队列 `java.util.Deque<E>`

* `void addFirst(E element)`

* `void addLast(E element)`

* `boolean offerFirst(E element)`

* `boolean offerLast(E element)`

  将给定的对象添加到双端队列的头部或尾部。如果队列满了，前面两个方法将抛出一个 `IllegalStateException` ，而后面两个方法返回 false

* `E removeFirst()`

* `E removeLast()`

* `E pollFIrst()`

* `E pollLast()`

  如果队列不空，删除并返回队列头部的元素。如果队列为空，前面两个方法将抛出 `NoSuchElementException` ，而后面两个方法返回 `null`

* `E getFirst()`

* `E getLast()`

* `E peekFirst()`

* `E peekLast()`

  如果队列非空，返回队列头部的元素，但不删除。如果队列空，前面两个方法将抛出一个 `NoSuchElementException` ，而后面两个方法返回 null

### `java.util.ArrayDeque<E>`

* `ArrayDeque()`

* `ArrayDeque(int initialCapacity)`

  用初始容量 16 或给定的初始容量构造一个无限双端队列

### 优先队列 `java.util.PriorityQueue`

* `PriorityQueue()`

* `PriorityQueue(int  initialCapacity)`

  构造一个用于存放 `Comparable` 对象的优先级队列

* `PriorityQueue(int initialCapacity, Comparator<? super  E> c)`

  构造一个优先级队列，并用指定的比较器对元素进行排序

### `java.util.Map<K, V>`

* `default V merge(k key, V value, BiFuntion<? super V, ? super V, ? extends V> remappingFunction)`

  如果 `key` 与一个非 `null` 值 v 关联，将函数应用到 `v` 和 `value`，将 `key` 与结果关联，或者如果结果为 null，则删除这个键。否则，将 `key` 与 `value` 关联，返回 `get(key)`

* `default V compute(K key, BiFunction<? super K, ? super V, ? extends V>remappingFunction)`

  将函数应用到 `key` 和 `get(key)`。将 `key` 与结果关联，或者如果结果为 null，则删除这个键。返回 `get(key)`

* `default V computeIfPresent(K key, BiFunction<? super K, ? super V,? extends V> remappingFunction)`

  如果 `key` 与一个非 `null` 值 `v` 关联，将函数应用到 `key` 和 `v`，将 `key` 与结果关联，或者如果结果为 null，则删除这个键。返回 `get(key)`

* `default V computeIfAbsent(K key, Function<? super K, ? extends V>mappingFunction)`

  将函数应用到 `key`，除非 `key` 与一个非 `null` 值关联。将 `key` 与结果关联，或者如果结果为 `null`，则删除这个键。返回 `get(key)`

* `Set<Map.Entry<K, V>> entrySet()`

  返回 `Map.Entry` 对象（映射中的键、值对）的一个集视图。可以从这个 集中删除元素，它们将从映射中删除，但是不能增加任何元素

* `Set<K> keySet()`

  返回映射中所有的键的一个集视图。可以从这个集中删除元素，键和相关的值将从映射中删除，但是不能增加任何元素

* `Collection<V> values()`

  返回映射中所有值的一个集合视图。可以从这个集合中删除元素，所删除的值及相应的键将从映射中删除，不过不能增加任何元素

### `java.util.Map.Entry<K, V>`

* `K getKey()`

* `V getValue()`

  返回这一条目的键或值

* `V setValue<V newValue)`

  将相关映射中的值改为新值，并返回原来的值

### 映射 `java.util.HashMap<K, V>`

* `HashMap()`

* `HashMap(int initialCapacity)`

* `HashMap(int initialCapacity, float loadFactor)`

  用给定的容量和装填因子构造一个空散列映射。默认装填因子是 0.75

### 有序映射 `java.util.TreeMap<K,V>`

* `TreeMap()`

  为实现 `Comparable` 接口的键构造一个空的树映射

* `TreeMap(Comparator<? super K> c)`

  构造一个树映射，并使用一个指定的比较器对键进行排序

* `TreeMap(Map<? extends k, ? extends V> entries)`

  构造一个树映射，将某个有序映射中的所有条目添加到树映射中。并使用与给定的有序映射相同的比较器

### `java.util.SortedMap<K, V>`

* `SortedMap<K, V> subMap(K firstIncluded, K firstExcluded)`

* `SortedMap<K, V> headMap(K firstExcluded)`

* `SortedMap<K, V> tailMap(K firstIncluded)`

  返回在给定范围内的键条目的映射视图

* `Comparator<? super K> comparator()`

  返回对键进行排序的比较器。如果键是用 `Comparable` 接口的 `compareTo` 方法进行比较的，返回 null

* `K firstKey()`

* `k lastKey()`

  返回映射中最小元素和最大元素

### `java.util.WeakHashMap<K, V>`

* `WeakHashMap()`

* `WeakHashMap(int initialCapacity)`

* `WeakHashMap(int initialCapacity, float loadFactor)`

  用给定的容量和填充因子构造一个空的散列映射表

### `java.util.LinkedHashSet<E>`

* `LinkedHashSet()`

* `LinkedHashSet(int initialCapacity)`

* `LinkedHashSet(int initialCapacity, float loadFactor)`

  用给定的容量和填充因子构造一个空链接散列集

### `java.util.LinkedHashMap<K, V>`

* `LinkedHashMap()`

* `LinkedHashMap(int intialCapacity)`

* `LinkedHashMap(int initialCapacity, float loadFactor)`

* `LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)`

  用给定的容量、填充因子和顺序构造一个空的链接散列映射表。`accessOrder` 参数为 `true` 时表示访问顺序，为 `false` 表示插入顺序

* `protected boolean removeEldestEntry(Map.Entry<K, V> eldest)`

  如果想删除 `eldest` 元素，并同时返回 `true`，就应该覆盖这个方法。`eldest` 参数是预期要删除的条目。这个方法将在条目添加到映射中之后调用。其默认的实现将返回 `false`。即在默认情况下，旧元素没有被删除。

### `java.util.EnumSet<E extends Enum<E>>`

* `static <E extends Enum<E>> EnumSet<E> allOf(Class<E> enumType)`

  返回一个包含给定枚举类型的所有值的集

* `static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> enumType)`

  返回一个空集，并有足够的空间保存给定的枚举类型所有的值

* `static <E extends Enum<E>> EnumSet<E> range(E from, E to)`

  返回一个包含 from ~ to 之间的所有值（包括两个边界元素）的集

* `static <E extends Enum<E>> EnumSet<E> of(E value)`

* `static <E extends Enum<E>> EnumSet<E> of(E value, E... values)`

  返回包括给定值的集

### `java.util.EnumMap<K extends Enum<K>, V>`

* `EnumMap(Class<K> keyType)`

  构造一个键为给定类型的空映射

### `java.util.IdentityHashMap<K, V>`

* `IdentityHashMap()`

* `IdentityHashMap(int expectedMaxSize)`

  构造一个空的标识散列映射集，其容量是大于 1.5 * `expectedMaxSize` 的 2 的最小次幂 `expectedMaxSize` 默认是 21

### `java.util.Collections`

* `static <E> Collection unmodifiableCollection(Collection<E> c)`

* `static <E> List unmodifiableList(List<E> e)`

* `static <E> Set unmodifiableSet(Set<E> c)`

* `static <E> SortedSet unmodifiableSortedSet(SortedSet<E> c)`

* `static <E> SortedSet unmodifiableNavigableSet(NavigableSet<E> c)`

* `static <K, V> Map unmodifiableMap(Map<K, V> c)`

* `static <K, V> SortedMap unmodifiableSortedMap(SortedMap<K, V> c)`

* `static <K, V> SortedMap unmodifiableNavigableMap(NavigableMap<K, V> c)`

  构造一个集合视图：视图的更改器方法抛出一个 `UnsupportedOperationException`

* `static <E> Collection<E> synchronizedCollection(Collection<E> c)`

* `static <E> List synchronizedList(List<E> c)`

* `static <E> Set synchronizedSet(Set<E> c)`

* `static <E> SortedSet synchronizedSortedSet(SortedSet<E> c)`

* `static <E> NavigableSet synchronizedNavigableSet(NavigableSet<E> c)`

* `static <K, V> Map<K, V> synchronizedMap(Map<K, V> c)`

* `static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> c)`

* `static <K, V> NavigableMap<K, V> synchronizedNavigableMap(NavigableMap<K, V> c)`

  构造一个集合视图；视图的方法同步

* `static <E> Collection checkedCollection(Collection<E> c, Class<E> elementType)`

* `static <E> List checkedList(List<E> c, Class<E> elementType)`

* `static <E> Set checkedSet(Set<E> c, Class<E> elementType)`

* `static <E> SortedSet checkedSortedSet(SortedSet<E> c, Class<E> elementType)`

* `static <E> NavigableSet checkedNavigableSet(NavigableSet<E> c, Class<E> elementType)`

* `static <k, V> Map checkedMap(Map<K, V> c, Class<K> keyType, Class<V> valueType)`

* `static <k, v> SortedMap checkedSortedMap(SortedMap<K, V> c, Class<K> keyType, Class<V> valueType)`

* `static <K, V> NavigableMap checkedNavigableMap(NavigableMap<K, V>c, Class<K> keyType, Class<V> valueType)`

* `static <E> Queue<E> checkedQueue(Queue<E> queue, Class<E> elementType)`

  构造一个集合视图；如果插入一个错误类型的元素，视图的方法抛出一个 `ClassCastException`

* `static <E> List<E> nCopies(int n, E value)`

* `static <E> Set<E> singleton(E value)`

* `static <E> List<E> singletonList(E value)`

* `static <K, V> Map<K, V> singletonMap(K key, V value)`

* 构造一个对象视图。可以是一个包含 n 个相同元素的不可修改列表，也可以是一个单元素集、列表或映射

* `static <E> List<E> emptyList()`

* `static <T> Set<T> emptySet()`

* `static <E> SortedSet<E> emptySortedSet()`

* `static NavigableSet<E> emptyNavigableSet()`

* `static <K, V> Map<K, V> emptyMap()`

* `static <K, V> SortedMap<K, V> emptySortedMap()`

* `static <K, V> NavigableMap<K, V> emptyNavigableMap()`

* `static <T> Enumeration<T> emptyEnumeration()`

* `static <T> Iterator<T> emptyIterator()`

* `static <T> ListIterator<T> emptyListIterator()`

  生成一个空集合、映射或迭代器

* `static <T extends Comparable<? super T>> void sort(List<T> elements)`

  使用稳定的排序算法，对列表中元素进行排序。这个算法的时间复杂度是`O(n logn)`，其中 n 为列表的长度

* `static void shuffle(List<?> elements)`

* `static void shuffle(List<?> elements, Random r)`

  随机地打乱列表中的元素。这个算法的时间复杂度是 `O(n a(n))`，n 是列表的长度，`a(n)` 是访问元素的平均时间

* `static <T extends Comparable<? super T>> int binarySearch(List<T> elements, T key)`

* `static <T> int binarySearch(List<T> elements, T key, Comparator<? super T> c)`

  从有序列表中搜索一个键，如果元素扩展了 `AbstracSequentialList` 类，则采用线性查找，否则将采用二分查找。这个方法将返回这个键在列表中的索引，如果在列表中不存在这个键将返回负值 i。在这种情况下，应该将这个键插入到列表索引 `i-1` 的位置上，以保持列表的有序性

* `static <T extends Comparable<? super T>> T min(Collection<T> elements)`

* `static <T extends Comparable<? super T>> T max(Collection<T> elements)`

* `static <T> min(Collection<T> elements, Comparator<? super T> c)`

* `static <T> max(Collection<T> elements, Comparator<? super T> c)`

  返回集合中最小的或最大的元素

* `static <T> void copy(List<? super T> to, List<T> from)`

  将原列表中的所有元素复制到目标列表的相应位置上。目标列表的长度至少与原列表一样

* `static <T> void fill(List<? super T> l, T value)`

  将列表中的所有位置设置为相同的值

* `static <T> boolean addAll(Collection<? super T> c, T... values)`

  将所有的值添加到集合中。如果集合改变了，则返回 true

* `static <T> boolean replaceAll(List<T> l, T oldValue, T newValue)`

  用 `newValue` 取代所有值为 `oldValue` 的元素

* `static int indexOfSubList(List<?> l, List<?> s)`

* `static int lastIndexOfSubList(List<?> l, List<?> s)`

  返回 l 中第一个或最后一个等于 s 子列表的索引。如果 l 中不存在等于 s 的子列表，则返回 -1

* `static void swap(List<?> l, int i, int j)`

  交换给定偏移量的两个元素

* `static void reverse(List<?> l)`

  逆置列表中元素的顺序。

* `static void rotate(List<?> l, int d)`

  旋转列表中的元素，将索引 i 的条目移动到位置`(i + d）% l.size()`

* `static int frequency(Collection<?> c, Object o)`

  返回 c 中与对象 o 相同的元素个数

* `boolean disjoint(Collection<?> cl, Collection<?> c2)`

  如果两个集合没有共同元素，返回 ture

### `java.util.NavigableMap<K, V>`

* `NavigableMap<K, V> subMap(K from, boolean fromIncluded, k to, boolean toInclued)`

* `NavigableMap<K, V> headMap(K from, boolean fromInclueded)`

* `NavigableMap<K, V> tailMap<K to, boolean toIncluded)`

  返回在给定范围内的键条目的映射视图。`boolean` 标志决定视图是否包含边界

### `java.util.Properties`

* `Properties()`

  创建一个空的属性映射

* `Properties(Properties defaults)`

  创建一个带有一组默认值的空的属性映射

* `String getProperty(String key)`

  获得属性的对应关系；返回与键对应的字符串。如果在映射中不存在，返回默认表中与这个键对应的字符串

* `String getProperty(String key, String defaultValue)`

  获得在键没有找到时具有的默认值属性；它将返回与键对应的字符串，如果在映射中不存在，就返回默认的字符串

* `void load(InputStream in)`

  从 `InputStream` 加载属性映射

* `void store(OutputStream out, String commentString)`

  把属性映射存储到 `OutputStream`

### `java.util.Stack<E>`

* `E push(E item)`

  将 `item` 压入栈并返回 `item`

* `E pop()`

  弹出并返回栈顶的 `item` 如果栈为空，则不要调用该方法

* `E peek()`

  返回栈顶元素，但不弹出，如果栈为空，则不要调用该方法


