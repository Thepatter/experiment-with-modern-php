## java.util.logging.Logger

* `Logger getLogger(String loggerName)`

* `Logger getLogger(String loggerName, String bundleName)`

  获得给定名字的日志记录器。如果这个日志记录器不存在，创建一个日志记录器

  参数：`loggerName`    具有层次结构的日志记录器名。例如：`com.mycompany.myapp`

  ​	   `bundleName`     用来查看本地消息的资源包名

* `void servere(String message)`

* `void warning(String message)`

* `void info(String message)`

* `void config(String message)`

* `void fine(String message)`

* `void finer(String message)`

* `void finest(String message)`

  记录一个由方法名和给定消息指示级别的日志记录

* `void entering(String className, String methodName)`

* `void entering(String className, String methodName, Object param)`

* `void entering(String className, String methodName, Object[] param)`

* `void exiting(String className, String methodName)`

* `void exiting(String className, String methodName, Object result)`

  记录一个描述进入/退出方法的日志记录，其中应该包括给定参数和返回值

* `void throwing(String className, String methodName, Throwable t)`

  记录一个描述抛出给定异常对象的日志记录

* `void log(Level level, String message)`

* `void log(Level level, String message, Object obj)`

* `void log(Level level, String message, Object[] objs)`

* `void log(Level level, String message, Throwable t)`

  记录一个给定级别和消息的日志记录，其中可以包括对象或者可抛出对象。要想包括对象，消息中必须包含格式化占位符号 ｛0｝、｛1｝等

* `void logp(Level level, String className, String methodName, String message)`

* `void logp(Level level, String className, String methodName, String message, Object obj)`

* `void logp(Level level, String className, String methodName, String message, Object[] objs)`

* `void logp(Level level, String className, String methodName, String message, Throwable t)`

  记录一个给定级别、准确的调用者信息和消息的日志记录，其中可以包括对象和可抛出对象

* `void logrb(Level level, String className, String methodName, String bundleName, String message)`

* `void logrb(Level level, String className, String methodName, String bundleName, String message, Object obj)`

* `void logrb(Level level, String className, String methodName, String bundleName, String message, Object[] objs)`

* `void logrb(Level level, String className, String methodName, String bundleName, String message, Throwable t)`

  记录一个给定级别、准备的调用者信息、资源包名和消息的日志记录，其中可以包括对象或可抛出对象

* `Level getLevel()`

* `void setLevel(Level l)`

  获得和设置这个日志记录器的级别

* `Logger getParent()`

* `void setParent(Logger l)`

  获得和设置这个日志记录器父日志记录器

* `Handler[] getHandlers()`

  获得这个日志记录器的所有处理器

* `void addHandler(Handler h)`

* `void removeHandler(Handler h)`

  增加或删除这个日志记录器的一个处理器

* `boolean getUseParentHandlers()`

* `void setUseParentHandlers(boolean b)`

  获得和设置 “use parent handler" 属性。如果这个属性是 true，则日志记录器会将全部的日志记录转发给它的父处理器

* `Filter getFilter()`

* `void setFilter(Filter f)`

  获得和设置这个日志记录器的过滤器

### java.util.logging.Handler

* `abstract void publish(LogRecord record)`

  将日志记录发送到希望的目的地

* `abstract void flush()`

  刷新所有已缓冲的数据

* `abstract void close()`

  刷新所有已缓冲的数据，并释放所有相关的资源

* `Filter getFilter()`

* `void setFilter(Filter f)`

  获得和设置这个处理器的格式化器

* `Level getLevel()`

* `void setLevel(Level l)`

  获得和设置这个处理器的级别

### java.util.logging.ConsoleHandler

* `ConsoleHandler()`

  构造一个新的控制台处理器

### java.util.logging.FileHandler

* `FileHandler(String pattern)`

* `FileHandler(String pattern, boolean append)`

* `FileHandler(String pattern, int limit, int count)`

* `FileHandler(String pattern, int limit, int count, boolean append)`

  构造一个文件处理器

  参数：pattern	构造日志文件名的模式

  ​	    limit		在打开一个新日志文件之前，日志文件可以包含的近似最大字节数

  ​	    count 		循环序列的文件数量

  ​	    append	新构造的文件处理器对象应该追加在一个已存在的日志尾部，则为 true

### java.util.logging.LogRecord

*  `Level getLevel()`

  获得这个日志记录的记录级别

* `String getLoggerName()`

  获得正在记录这个日志记录的日志记录器的名字

* `ResourceBundle getresourceBundle()`

* `String getresourceBundleName()`

  获得用于本地化消息的资源包或资源包的名字。如果没有获得，则返回 null

* `String getMessage()`

  获得本地化和格式化之前的原始消息

* `Object[] getParameters()`

  获得参数对象。如果没有获得，则返回 null

* `Throwable getThrow()`

  获得被抛出的对象，如果对象不存在，则返回 null

* `String getSourceClassName()`

* `String getSourceMethodName()`

  获得记录这个日志的代码区域。这个信息有可能是由日志记录代码提供的，也有可能是自动从运行时堆栈推测出来的。如果日志记录代码提供的值有误，或者运行时代码由于被优化而无法推测出确切的位置，这两个方法的返回值就有可能不准确

* `long getMillis()`

  获得创建时间。以毫秒为单位

* `long getSequenceNumber()`

  获得这个日志记录的唯一序列号

* `int getThreadID()`

  获得创建这个日志记录的线程的唯一ID。这些 ID 是由 LogRecord 类分配的，并且与其他线程的 ID 无关

### java.util.logging.Filter

* `boolean isLoggable(LogRecord record)`

  如果给定日志记录需要记录，则返回 true

### java.util.logging.Formatter

* `abstract String format(LogRecord record)`

  返回对日志记录格式化后得到的字符串

* `String getHead(Handler h)`

* `String getTail(Handler h)`

  返回应该出现在包含日志记录的文档的开通和结尾的字符串。超类 `Formatter` 定义了这些方法，它们只返回空字符串。如果必要的话，可以对它们进行覆盖

* `String formatMessage(LogRecord record)`

  返回经过本地化和格式化后的日志记录的消息内容
