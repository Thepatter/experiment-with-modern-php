## lambda 表达式和内部类

### Java 接口特性

* 接口不是类，不能使用 `new` 运算符实例化一个接口
* 可以声明接口的变量，接口变量必须引用实现了接口的类对象
* 可以使用 `instance` 检查一个对象是否实现了某个特定的接口
* 接口可以被扩展
* 接口可以定义常量
* 接口的方法自动设置为 `public`，常量自动设置为 `public static final`

### Java SE 8 接口新特性

* 允许在接口中增加静态方法。
* 默认方法，可以为接口方法提供一个默认实现。必须用 `default` 修饰符标记这样的的方法

#### 默认方法冲突

如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。Java 的相应规则是：

1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略

2）接口冲突。如果一个超接口提供了一个默认方法。另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突

3）如果两个接口都没有为共享方法提供默认实现，那么就与 Java 8 之前的情况一样，不存在冲突。实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，这个类本身就是抽象的

4）一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。即类优先规则

### lambda 表达式

#### lambda 表达式语法

参数，箭头（`->`）以及一个表达式。

```java
(String first, String second)
    ->first.length() - seconde.length()
```

如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 `｛｝`  中，并包含显式的 `return` 语句。

```java
(String first, String second)->
	{
        if (first.length() < second.length()) {
            return 1;
        } else {
            return 0;
        }
	}
```

即使 `lambda` 表达式没有参数，仍然要提供空括号，就像无参数方法一样。

```
()->{
    for (int i = 100; i )
}
```



如果可以推导出一个 `lambda` 表达式的参数类型，则可以忽略其类型。如果方法只有一个参数，而且这个参数的类型可以推导得出，那么可以省略小括号