## 国际化

### Locale 对象

### 数字格式

数字和货币的格式高度依赖于 `locale` 。Java 类库提供了一个格式器对象的集合，可以对 `java.text` 包中的数字值进行格式化和解析。可以通过下面的步骤对特定 `Locale` 的数字进行格式化：使用一个工厂方法得到一个格式器对象，使用这个格式器对象来完成格式化和解析工作

工厂方法是 `NumberFormat` 类的静态方法，它们接受一个 `Locale` 类型的参数。总共有 3 个工厂方法：`getNumberInstance` 、`getCurrencyInstance` 、`getPercentInstance`，这些方法返回的对象可以分别对数字、货币量和百分比进行格式化和解析。

```java
// 对德语中的货币进行格式化
Locale loc = Locale.GERMAN;
NumberFormat currFmt = NumberFormat.getCurrencyInstance(loc);
double amt = 123456.78;
String result = currFmt.format(amt);
```

如果要读取一个按照某个 `Locale` 的惯用法而输入或存储的数字，那么就需要使用 `parse` 方法。`parse` 方法能处理小数点和分隔符以及其他语言中的数字

```java
TextField inputField;
NumberFormat fmt = NumberFormat.getNumberInstance();
Number input = fmt.parse(inputField.getText().trim());
double x = input.doubleValue();
```

`parse` 的返回类型是抽象类型的 `Number`。返回的对象是一个 `Double` 或 `Long` 的包装器类对象，这取决于被解析的数字是否是浮点数。如果不关心两者的差异。可以直接使用 `Number` 类中的 `doubleValue` 方法来读取被包装的数字

`Number` 类型的对象并不能自动转换成相关的基本类型，因此，不能直接将一个 `Number` 对象赋给一个基本类型，而应该使用 `doubleValue` 或 `intValue` 方法

如果数字文本的格式不正确，该方法会抛出一个 `ParseException` 异常。（字符串以空白字符开头是不允许的，但是任何跟在数字之后的字符都将被忽略，所以这些跟在后面的字符是不会引起异常的）

由  `getXxxInstance` 工厂方法返回的类并非是 `NumberFormat` 类型的。`NumberFormat` 类型是一个抽象类，而我们实际上得到的格式器是它的一个子类。工厂方法只知道如何定位属于特定 `locale` 的对象

可以用静态的 `getAvailableLocales` 方法得到一个当前所支持的 `Locale` 对象列表。这个方法返回一个 `Locale` 对象数组，从中可以获得针对它们的数字格式器对象

### 货币

为了格式化货币值，可以使用 `NumberFormat.getCurrencyInstance` 方法。但是这个方法灵活性不好，它返回的是一个只针对一种货币的格式器。处理这样的情况，应该使用 `Currency` 类来控制被格式器所处理的货币。可以通过将一个货币标识符传给静态的 `Currency.getInstance` 方法来得到一个 `Currency` 对象，然后对每一个格式器都调用 `setCurrency` 方法

### 日期和时间

当格式化日期和时间时，需要考虑 4 个与 `Locale` 相关的问题

* 月份和星期应该用本地语言来表示
* 年月日的顺序要符号本地习惯
* 公历可能不是本地首选的日期表示方法
* 必须要考虑本地的时区

`java.time` 包中的 `DateTimeFormatter` 类可以处理这些问题。可以使用 `LocalDate`、`LocalDateTime`、`LocalTime` 和 `ZonedDateTme` 的静态的 `parse` 方法之一来解析字符串中的日期和时间

```java
LocalTime time = LocalTime.parse("9:32 AM", formatter);
```

### 排序和范化

`compareTo` 方法使用的是字符串的 `UTF-16` 编码值，这会导致很荒唐的结果，即使在英文比较中也是如此。为了获得 `Locale` 敏感的比较符，可以调用静态的 `Collator.getInstance` 方法：

```java
Collator coll = Collator.getInstance(locale);
words.sort(coll);
```

因为 `Collator` 类实现了 `Comparator` 接口，因此，可以传递一个 `Collator` 对象给 `list.sort(Comparator)` 方法来对一组字符串进行排序

排序器有几个高级设置项。可以设置排序器的强度以此来选择不同的排序行为。字符间的差别可以被分为首要的、其次的和再次的。如果将排序器的强度设置成 `Collator.PRIMARY`，那么排序器将只关注 `primary` 级的差别。如果设置成 `Collator.SECONDARY`，排序器将把 `secondary` 级的差别也考虑进去。即，两个字符串在 `secondary` 或 `tertiary` 强度下更容易被区分开来。如果强度被设置为 `Collator.IDENTICAL` 则不允许有任何差异。这种设置与排序器的第二种具有相当技术性的设置，即分解模式，联合使用时，就会显得非常有用

让排序器去多次分解一个字符串是很浪费的。如果一个字符串要和其他字符串进行多次比较，可以将分解的结果保存在一个排序键对象中。`getCollationKey` 方法返回一个 `CollationKey` 对象，可以用它来进行更进一步的、更快速的比较操作。

```java
String a = ...;
CollationKey akey = coll.getCollationKey(a);
if (akey.compareTo(coll.getCollationKey(b)) == 0) {
    
}
```

在将字符串存储到数据库中，或与其他程序进行通信时。`java.text.Normalizer` 类实现了对范化的处理

```java
String normalized = Normalizer.normalize(name, Normalizer.Form.NFD);
```

### 消息格式化

Java 类库中有一个 `MessageFormat` 类，它与用 `printf` 方法进行格式化很类似，但是它支持 `Locale` ，并且会对数字和日期进行格式化。

#### 格式化数字和日期

典型的消息格式化字符串

```java
"On {2}, a {0} destroyed {1} houses and caused {3} of damage."
```

括号中的数字是占位符，可以用实际的名字和值来替换它们。使用静态方法 `MessageFormat.format` 可以用实际的值来替换这些占位符。它是一个 "varargs" 方法，可以通过下面的方法提供参数

```java
String msg = MessageFormat.format("On {2}, a {0} destroyed {1} houses and caused {3} of damage.", "hurricane", 99, new GregorianCalendar(1999, 0, 1).getTime(), 10.0E8);
```

上面例子中，占位符 `{0}` 被 "hurricane" 替换，`{1}` 被 99 替换。

占位符索引后面可以跟一个类型（type）和一个风格（style）, 它们之间用逗号隔开。类型是：`number` , `time`、`date` 、`choice` 如果类型是 `number` 那么风格可以是 `integer` 、`currency`、`percent`，如果类型是 `time` 或 `date` ，风格可以是 `short` ，`medium`、`long`、`full` 或者是一个日期格式模式，就像 `yyyy-MM-dd` 

静态的 `MessageFormat.format` 方法使用当前的 `locale` 对值进行格式化。要用任意的 `locale` 进行格式化，还有一些工作要做，因为这个类还没有提供任何可以使用的 "varargs" 方法。需要把将要格式化的值置于 `Object[]` 数组中。

```java
MessageFormat mf = new MessageFormat(pattern, loc);
String msg = mf.format(new Object[] {});
```

### 文本文件和字符集





