### 对象和类

#### 构造方法

* 构造方法必须具备和所在类相同的名字
* 构造方法没有返回值类型，连 void  也没有
* 构造方法可以重载，可以有多个同名的构造方法，但它们要签名不同，这样易用不同的初始数据值来构造对象
* 在构造方法中，语句 `this (参数列表)` 应在任何其他可执行语句之前出现

#### 通过引用变量访问对象

* 对象是通过对象引用变量来访问的，该变量包含对对象的引用，从本质上来说，一个类是一个程序员定义的类型。类是一种引用类型**对象引用变量中只包含了对该对象的引用，严格来说，对象引用变量和对象是不同的，但是大多数情况下，这种差异是可以忽略的**
* 数组被看作是对象，数组是用 `new` 操作符创建的，一个数组变量实际上是一个包含数组引用的变量
* 给方法传递一个对象，是将对象的引用传递给方法

#### 对象操作符号 `.`

* `objectRefVar.dataField`  引用对象的数据域 （实例变量，依赖于某个具体事例）
* `objectRefvar.method(arguments)` 调用对象的方法（实例方法，具体实例上调用它）

#### 引用数据域

如果一个引用类型的数据域没有引用任何对象，那么这个数据域既有一个特殊的 Java 值 `null` 

* 引用类型数据域的默认值是 `null`
* 数值类型域的默认值是 `0`
* Boolean 类型数据域默认值是 `false`
* char 类型的数据域的默认值是 `\u0000`

#### 基本类型变量和引用类型变量的区别

每个变量都代表一个存储值的内存位置。声明一个变量时，就是在告诉编译器这个变量可以存放什么类型的值。对基本类型变量来说。对应内存所存储的值是基本类型的值。对引用类型变量来说，对应内存所存储的值是一个引用，是对象的存储地址。将一个变量赋值给另一个变量时，另一个变量就被赋予同样的值。对基本对象就是将一个变量的实际值赋给另一个变量。对引用变量就是将一个变量的引用赋给另一个变量

### Java类库中常用的类

* `Date` 类 `java.util.Date` 类中提供了与系统无关的对时间和日期的封装

  ```
  +Date()			为当前时间创建一个 Date 对象
  +Date(elapseTime: Long)	1970.01.01 毫秒时间对象
  +toString(): String 	返回一个日期时间字符串
  +getTime(): long		1970.01.01 以来的毫秒数
  +setTime(elapseTime: long): void	在对象中设置一个新的流逝时间
  ```

* `Random` 类 `java.util.Random`

  ```
  +Random()		以当前时间作为种子创建一个 Random 对象
  +Random(seed: long)		以一个特定值作为种子创建一个 Random 对象
  +nextInt(): int			返回一个随机的 int 值
  +nextInt(n: int)：int	返回一个 0 到 n (不包含n) 之间的随机 int 类型的值
  +nextLong(): long		返回一个随机 long 值
  +nextDouble(): doubel	返回一个0.0 到 1.0 (不包含 1.0）之间的随机 double 类型的值
  +nextFloat(): float		返回一个 0.0F 到 1.0F （不包含 1.0F) 之间的随机 float 类型的值
  +nextBoolean(): boolean		返回一个随机的 Boolean 值
  ```

* `Point2D` 类 `javafx.geometry` 用于表示二维平面上的点

  ```
  +Point2D(X: double, y: double)		用给定的 x 和 y 坐标来创建一个 Point2D 对象
  +distance(x: doubel, y: double): double		返回该点到给点（x, y）之间的距离
  +distance(p: Point2D): double		返回该点到给定点 p 之间的距离
  +getX(): double				返回该点的 x 坐标
  +getY(): double				返回该点的 y 坐标
  +toString(): String			返回该点的字符串表示
  ```

* `BigInteger` 和 `BigDecimal` 类 `java.math` 用于表示任意大小和精度的证书或十进制数

  __如果要进行非常大的数的计算或者高精度浮点值的计算，可用使用 `BigInteger` 和 `BigDecimal` 类，它们是不可变的__

  ```uml
  +BigInteger(String)
  +BigDecimal(String)
  +add() 加
  +subtract() 减
  +multiple() 乘
  +divide()	除
  +divide(BigDecimal d,int scale, int roundingMode); 指定尺度和舍入方式 scale 是指小数点后最小的整数位数，舍入方式为 roundingMode
  +remainder
  ## 算术运算的必须为对象，且两个对象类型必须一致
  ```

* `String` 类，String 类对象不可改变，一旦创建，内容不能再改变

  ```java
  // 构造字符串，可用用字符串直接量或字符数组创建一个字符串对象，String 变量存储的是对 String 对象的引用，String 对象里存储的才是字符串的值
  String newString = new String("hello world");
  String message = "hello world";
  char[] charArray = {'G', 'o', 'o', 'd'}  单引号字符，双引号字符串
  String message = new String(charArray);
  // 字符串对象一旦创建，不能改变，将字符串变量赋值给新的一个字符串，是将该新的字符串引用赋给了该字符串变量，对具有相同字符序列的字符串直接量使用同一个实例
  // 字符串的替换和分隔,返回一个新字符串对象
  replace(oldChar: char, new Char): string
  "Welcome".replace('e', 'A')； // WAlcomA
  "welcome".replaceFirst("e", "AB");  // WABlcome
  "welcome".replace("e", "AB");  // WABlcomAB
  split(String regex);  //指定分隔符分割字符串，返回一个字符串数组
  // 依照模式匹配，替换和分割
  matches(String regex);   // 正则表达式匹配
  replaceAll(regex, replacement);  // 正则表达式全局替换
  replaceFirst(regex, replacement); // 正则表达式首次出现替换
  // 字符串与数组之间的转换
  char[] chars = "Java".toCharArray()  // 字符串转数组
  getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin); // 将下标从 scrbegin 到 srcEnd -1 的字串赋值到字符数组 dst 中下标从 detBegin 开始的位置
  // 将字符和数值转换为字符串
  valueOf(mixd):string
  // 格式化字符串，静态方法 format
  String.format(format, item1, item2); // 返回一个格式化的字符串
  ```

* `StringBuilder` 和 `StringBuffer` 类，类似与 `String` 类，区别 `String` 类不可改变

  ```java
  StringBuilder();		// 构建一个容量为 16 的空字符串构造器
  StringBuilder(capacity:int); // 构建一个指定容量的字符串构建器
  StringBuilder(s:String); // 构建一个指定字符串的字符串构建器
  +append(data:char[]): StringBuilder;	// 追加一个字符数组到字符串构建器
  +append(data:char[], offset:int, len:int): StringBuilder // 追加 data 中的子数组到字符串构建器
  +append(v: aPrimitiveType): StringBuilder; // 将一个基本类型值作为字符串追加到字符串构建器
  +append(s:String): StringBuilder; 	// 追加一个字符串到字符串构建器
  +delete(startIndex: int, endIndex: int): StringBuilder; 	// 删除从 startIndex 到 endIndex - 1 的字符
  +deleteCharAt(index: int): StringBuilder;	// 删除给定索引位置的字符
  +insert(index:int,data:char[],offset:int,len:int): StringBuilder; // 在字符串构建器的给定索引位置插入数组 data 的子数组
  +insert(offset: int,data:char[]): StringBuilder; 	// 向构造器的偏移位置插入数据
  +insert(offset: int, b: aPrimitiveType): StringBuilder   // 向该字符串构建器插入一个转换为字符串的值
  +insert(offset: int, s: String): StringBuilder 	// 在该字符串构建器指定的偏移位置插入一个字符串
  +replace(startIndex: int, endIndex: int, s:String):StringBuilder	将该字符串构建器从 startIndex 到 endIndex - 1 的位置的字符替换为给定的字符串
  +reverse(): StringBuilder	// 倒置构造器中的字符
  +setCharAt(index: int, ch: char): void	// 将该构造器的指定索引位置设为新的字符
  ```


#### 静态变量，常量和方法

* 静态变量被类中的所有对象所共享。静态方法不能访问类中的实例成员，静态变量，静态变量将变量值存储在一个公共的内存地址，因为它是公共的地址，__所以如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响，java 支持静态方法和静态变量，无需创建类的实例就可以调用静态方法__
* 实例方法可以调用实例方法和静态方法，以及访问实例数据或者静态数据。静态方法可以调用静态方法以及访问静态数据域。然而，静态方法不能调用实例方法或者访问实例数据，因为静态方法不属于某个特定的对象。

#### 可见性修饰符

* 可见性修饰符可用用于确定一个类及它成员的可见性

* 可在类，方法和数据域前使用 `public` 修饰符，表示它们可以被任何其他的类访问。__表示它们可以被任何其他类访问，如果没有使用可见性修饰符，那么默认类，方法和数据域是可以被同一个包的任何一个类方法。这称为 包私有 （package-private）或 包内访问（package-access）__

* 包可用用来组织类，在使用是在程序文件开头声明 `package packageName` ,如果定义类中没有声明包，就表示它放在默认包中。

* `private` 修饰符限定方法和数据域只能在它自己的类中访问。

* `protected` 一个类中的受保护成员可用从子类中访问，父类中被保护的数据域或方法可以在它子类中访问

* 可见性递增 `私有 -> 默认 -> 被保护 -> 公共成员`

  | 类中成员修饰符 | 在同一类中可访问 | 在同一包中可访问 | 在子类内可访问 | 在不同包可访问 |
  | :------------: | :--------------: | :--------------: | :------------: | :------------: |
  |     public     |        是        |        是        |       是       |       是       |
  |   protected    |        是        |        是        |       是       |       否       |
  |    defaule     |        是        |        是        |       否       |       否       |
  |    private     |        是        |        否        |       否       |       否       |

* __如果一个变量或方法依赖于类的某个具体实例，那就应该将它定义为实例变量或实例方法。如果一个变量或方法不依赖于类的某个具体实例，就应该将它定义为静态变量或静态方法__

#### 数据域封装

将数据域设为私有保护数据，并且使类易于维护，为了避免对数据域的直接修改，应该使用 `private` 修饰符将数据域声明为私有。为了能修改私有数据域，可以提供一个修改器方法, 和访问器方法

* 访问器 `get()` 方法

  `public returnType getPropertyName()`

* 修改器 `set()` 方法

  `public void setPropertyName(dataType propertyValue)`

#### 对象数组

数组既可以存储基本类型值，也可以存储对象，对象的数组实际是引用变量的数组。调用 `curcleArray[1].getArea()` 实际上调用了两个层次的引用，`curcleArray` 引用了整个数组，`curcleArray[1]` 引用了一个 `circle` 对象，

**当使用 new 操作符创建对象数组后，这个数组中的每个元素都是默认值为 `null` 的引用变量**

#### 变量的作用域

__实例变量和静态变量的作用域是整个类，无论变量是在哪里声明__

* 一个类的实例变量和静态变量称为类变量或数据域，在方法内部定义的变量称为局部变量，类的变量和方法可以在类中以任意顺序出现
* 如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量将被隐藏。

#### this 引用

__关键字 this 引用对象自身，它也可以在构造方法内部用于调用同一个类的其他构造方法，关键字 this 是指向调用对象本身的引用名。可用 this 关键字引用对象的实例成员__

* this 关键字可用用来引用类的隐藏数据域，在数据域的 set 方法中，经常将数据域名用作参数名。在这种情况下，这个数据域在 set 方法中被隐藏。为了给它设置新值，需要在方法中引用隐藏的数据域名。隐藏的静态变量可用简单的通过 `类名.静态变量` 方式访问。隐藏的实例变量就需要使用关键字 `this` 来引用
* 使用 this 可用调用同一个类的另一个构造方法

#### 类的关系

* 关联：关联是一种常见的二元关系，描述两个类之间的活动，关系中涉及的每个类可以有一个角色表示，描述在该关系中担当的角色，关联中涉及的每个类可以给定一个多重性，多重性可以是一个数字或一个区间，决定在关系中涉及类的多少个对象
* 聚集：聚集是关联的一种特殊形式，代表了两个对象之间的归属关系。聚集建模 `has-a` 关系。所有者对象称为聚集对象，它的类称为聚集类。而从属对象称为被聚集对象，它的类称为被聚集类。一个对象可以被多个其他的聚集对象所拥有，如果一个对象只归属于一个聚集对象，那么它和聚集对象之间的关系就称为组合

#### 将基本数据类型值作为对象处理

__基本数据类型值不是一个对象，但是可用使用 JAVA API 中的包装类来包装成一个对象，出于性能考虑，在 Java 中基本数据类型不作为对象使用。因为处理对象需要额外的系统开销，Java 提供了一个方便的方法，即将基本数据类型包装成对象。通过使用包装类，可以将基本数据类型值作为对象处理__

__根据上下文环境，基本数据类型值可以使用包装类自动转换成一个对象，反过来的自动转换也可以，将基本类型值转换为包装类的过程为装箱，将包装了转换为基本类型为开箱，Java 支持自动装开箱__

* 包装类没有无参构造方法，所有包装类都是不可变的，一旦创建该对象，它们内部值就不能再改变
* 每一个数值包装类都有常量 `MAX_VALUE` 和 `MIN_VALUE` 表示对象基本数据类型的最大值和最小值
* 每个数值包装类都包含方法 `doubleValue`, `floatValue`, `intValue` , `longValue` ,`shortValue`, 这些方法返回包装对象的 `double`, `float`, `int`, `long` , `short` 值。
* 数值包装类中包含 `compareTo` 方法用于比较两个数值，如果该数值大于，等于，小于另外一个数值时，分别返回 1，0，-1
* 数值包装类有一个有用的静态方法 `valueOf(String s)` 该方法创建一个新对象，并将它初始化为指定字符串表示的值
* 使用 `Integer` 类中的 `parseInt` 方法将一个数值字符串转换为一个 `int` 值，如果数值字符串参数不是一个合法的待转换的数值字符串，则会发生运行时错误,该方法为类的静态方法，直接调用即可



