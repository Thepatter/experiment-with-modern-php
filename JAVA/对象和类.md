### 对象和类

#### 构造方法

* 构造方法必须具备和所在类相同的名字
* 构造方法没有返回值类型，连 void  也没有
* 构造方法可以重载，可以有多个同名的构造方法，但它们要签名不同，这样易用不同的初始数据值来构造对象
* 在构造方法中，语句 `this (参数列表)` 应在任何其他可执行语句之前出现

#### 通过引用变量访问对象

* 对象是通过对象引用变量来访问的，该变量包含对对象的引用，从本质上来说，一个类是一个程序员定义的类型。类是一种引用类型**对象引用变量中只包含了对该对象的引用，严格来说，对象引用变量和对象是不同的，但是大多数情况下，这种差异是可以忽略的**
* 数组被看作是对象，数组是用 `new` 操作符创建的，一个数组变量实际上是一个包含数组引用的变量
* 给方法传递一个对象，是将对象的引用传递给方法

#### 对象操作符号 `.`

* `objectRefVar.dataField`  引用对象的数据域 （实例变量，依赖于某个具体事例）
* `objectRefvar.method(arguments)` 调用对象的方法（实例方法，具体实例上调用它）

#### 引用数据域

如果一个引用类型的数据域没有引用任何对象，那么这个数据域既有一个特殊的 Java 值 `null` 

* 引用类型数据域的默认值是 `null`
* 数值类型域的默认值是 `0`
* Boolean 类型数据域默认值是 `false`
* char 类型的数据域的默认值是 `\u0000`

#### 基本类型变量和引用类型变量的区别

每个变量都代表一个存储值的内存位置。声明一个变量时，就是在告诉编译器这个变量可以存放什么类型的值。对基本类型变量来说。对应内存所存储的值是基本类型的值。对引用类型变量来说，对应内存所存储的值是一个引用，是对象的存储地址。将一个变量赋值给另一个变量时，另一个变量就被赋予同样的值。对基本对象就是将一个变量的实际值赋给另一个变量。对引用变量就是将一个变量的引用赋给另一个变量

### Java类库中常用的类

* Date 类 `java.util.Date` 类中提供了与系统无关的对时间和日期的封装

  ```
  +Date()			为当前时间创建一个 Date 对象
  +Date(elapseTime: Long)	1970.01.01 毫秒时间对象
  +toString(): String 	返回一个日期时间字符串
  +getTime(): long		1970.01.01 以来的毫秒数
  +setTime(elapseTime: long): void	在对象中设置一个新的流逝时间
  ```

* Random 类 `java.util.Random`

  ```
  +Random()		以当前时间作为种子创建一个 Random 对象
  +Random(seed: long)		以一个特定值作为种子创建一个 Random 对象
  +nextInt(): int			返回一个随机的 int 值
  +nextInt(n: int)：int	返回一个 0 到 n (不包含n) 之间的随机 int 类型的值
  +nextLong(): long		返回一个随机 long 值
  +nextDouble(): doubel	返回一个0.0 到 1.0 (不包含 1.0）之间的随机 double 类型的值
  +nextFloat(): float		返回一个 0.0F 到 1.0F （不包含 1.0F) 之间的随机 float 类型的值
  +nextBoolean(): boolean		返回一个随机的 Boolean 值
  ```

* Point2D 类 `javafx.geometry` 用于表示二维平面上的点

  ```
  +Point2D(X: double, y: double)		用给定的 x 和 y 坐标来创建一个 Point2D 对象
  +distance(x: doubel, y: double): double		返回该点到给点（x, y）之间的距离
  +distance(p: Point2D): double		返回该点到给定点 p 之间的距离
  +getX(): double				返回该点的 x 坐标
  +getY(): double				返回该点的 y 坐标
  +toString(): String			返回该点的字符串表示
  ```

#### 静态变量，常量和方法

* 静态变量被类中的所有对象所共享。静态方法不能访问类中的实例成员，静态变量，静态变量将变量值存储在一个公共的内存地址，因为它是公共的地址，__所以如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响，java 支持静态方法和静态变量，无需创建类的实例就可以调用静态方法__
* 实例方法可以调用实例方法和静态方法，以及访问实例数据或者静态数据。静态方法可以调用静态方法以及访问静态数据域。然而，静态方法不能调用实例方法或者访问实例数据，因为静态方法不属于某个特定的对象。

#### 可见性修饰符

* 可见性修饰符可用用于确定一个类及它成员的可见性

* 可在类，方法和数据域前使用 `public` 修饰符，表示它们可以被任何其他的类访问。__表示它们可以被任何其他类访问，如果没有使用可见性修饰符，那么默认类，方法和数据域是可以被同一个包的任何一个类方法。这称为 包私有 （package-private）或 包内访问（package-access）__

* 包可用用来组织类，在使用是在程序文件开头声明 `package packageName` ,如果定义类中没有声明包，就表示它放在默认包中。

* `private` 修饰符限定方法和数据域只能在它自己的类中访问。

* `protected` 一个类中的受保护成员可用从子类中访问，父类中被保护的数据域或方法可以在它子类中访问

* 可见性递增 `私有 -> 默认 -> 被保护 -> 公共成员`

  | 类中成员修饰符 | 在同一类中可访问 | 在同一包中可访问 | 在子类内可访问 | 在不同包可访问 |
  | :------------: | :--------------: | :--------------: | :------------: | :------------: |
  |     public     |        是        |        是        |       是       |       是       |
  |   protected    |        是        |        是        |       是       |       否       |
  |    defaule     |        是        |        是        |       否       |       否       |
  |    private     |        是        |        否        |       否       |       否       |

* __如果一个变量或方法依赖于类的某个具体实例，那就应该将它定义为实例变量或实例方法。如果一个变量或方法不依赖于类的某个具体实例，就应该将它定义为静态变量或静态方法__

#### 数据域封装

将数据域设为私有保护数据，并且使类易于维护，为了避免对数据域的直接修改，应该使用 `private` 修饰符将数据域声明为私有。为了能修改私有数据域，可以提供一个修改器方法, 和访问器方法

* 访问器 `get()` 方法

  `public returnType getPropertyName()`

* 修改器 `set()` 方法

  `public void setPropertyName(dataType propertyValue)`

#### 对象数组

数组既可以存储基本类型值，也可以存储对象，对象的数组实际是引用变量的数组。调用 `curcleArray[1].getArea()` 实际上调用了两个层次的引用，`curcleArray` 引用了整个数组，`curcleArray[1]` 引用了一个 `circle` 对象，

**当使用 new 操作符创建对象数组后，这个数组中的每个元素都是默认值为 `null` 的引用变量**

#### 变量的作用域

__实例变量和静态变量的作用域是整个类，无论变量是在哪里声明__

* 一个类的实例变量和静态变量称为类变量或数据域，在方法内部定义的变量称为局部变量，类的变量和方法可以在类中以任意顺序出现
* 如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量将被隐藏。

#### this 引用

__关键字 this 引用对象自身，它也可以在构造方法内部用于调用同一个类的其他构造方法，关键字 this 是指向调用对象本身的引用名。可用 this 关键字引用对象的实例成员__

* this 关键字可用用来引用类的隐藏数据域，在数据域的 set 方法中，经常将数据域名用作参数名。在这种情况下，这个数据域在 set 方法中被隐藏。为了给它设置新值，需要在方法中引用隐藏的数据域名。隐藏的静态变量可用简单的通过 `类名.静态变量` 方式访问。隐藏的实例变量就需要使用关键字 `this` 来引用

* 使用 this 可用调用同一个类的另一个构造方法
