### 对象和类

#### 构造方法

* 构造方法必须具备和所在类相同的名字
* 构造方法没有返回值类型，连 void  也没有
* 构造方法可以重载，可以有多个同名的构造方法，但它们要签名不同，这样易用不同的初始数据值来构造对象
* 在构造方法中，语句 `this (参数列表)` 应在任何其他可执行语句之前出现

#### 通过引用变量访问对象

* 对象是通过对象引用变量来访问的，该变量包含对对象的引用，从本质上来说，一个类是一个程序员定义的类型。类是一种引用类型**对象引用变量中只包含了对该对象的引用，严格来说，对象引用变量和对象是不同的，但是大多数情况下，这种差异是可以忽略的**
* 数组被看作是对象，数组是用 `new` 操作符创建的，一个数组变量实际上是一个包含数组引用的变量
* 给方法传递一个对象，是将对象的引用传递给方法

#### 对象操作符号 `.`

* `objectRefVar.dataField`  引用对象的数据域 （实例变量，依赖于某个具体事例）
* `objectRefvar.method(arguments)` 调用对象的方法（实例方法，具体实例上调用它）

#### 引用数据域

如果一个引用类型的数据域没有引用任何对象，那么这个数据域既有一个特殊的 Java 值 `null` 

* 引用类型数据域的默认值是 `null`
* 数值类型域的默认值是 `0`
* Boolean 类型数据域默认值是 `false`
* char 类型的数据域的默认值是 `\u0000`

#### 基本类型变量和引用类型变量的区别

每个变量都代表一个存储值的内存位置。声明一个变量时，就是在告诉编译器这个变量可以存放什么类型的值。对基本类型变量来说。对应内存所存储的值是基本类型的值。对引用类型变量来说，对应内存所存储的值是一个引用，是对象的存储地址。将一个变量赋值给另一个变量时，另一个变量就被赋予同样的值。对基本对象就是将一个变量的实际值赋给另一个变量。对引用变量就是将一个变量的引用赋给另一个变量

### Java类库中常用的类

* `Date` 类 `java.util.Date` 类中提供了与系统无关的对时间和日期的封装

  ```
  +Date()			为当前时间创建一个 Date 对象
  +Date(elapseTime: Long)	1970.01.01 毫秒时间对象
  +toString(): String 	返回一个日期时间字符串
  +getTime(): long		1970.01.01 以来的毫秒数
  +setTime(elapseTime: long): void	在对象中设置一个新的流逝时间
  ```

* `Random` 类 `java.util.Random`

  ```
  +Random()		以当前时间作为种子创建一个 Random 对象
  +Random(seed: long)		以一个特定值作为种子创建一个 Random 对象
  +nextInt(): int			返回一个随机的 int 值
  +nextInt(n: int)：int	返回一个 0 到 n (不包含n) 之间的随机 int 类型的值
  +nextLong(): long		返回一个随机 long 值
  +nextDouble(): doubel	返回一个0.0 到 1.0 (不包含 1.0）之间的随机 double 类型的值
  +nextFloat(): float		返回一个 0.0F 到 1.0F （不包含 1.0F) 之间的随机 float 类型的值
  +nextBoolean(): boolean		返回一个随机的 Boolean 值
  ```

* `Point2D` 类 `javafx.geometry` 用于表示二维平面上的点

  ```
  +Point2D(X: double, y: double)		用给定的 x 和 y 坐标来创建一个 Point2D 对象
  +distance(x: doubel, y: double): double		返回该点到给点（x, y）之间的距离
  +distance(p: Point2D): double		返回该点到给定点 p 之间的距离
  +getX(): double				返回该点的 x 坐标
  +getY(): double				返回该点的 y 坐标
  +toString(): String			返回该点的字符串表示
  ```

* `BigInteger` 和 `BigDecimal` 类 `java.math` 用于表示任意大小和精度的证书或十进制数

  __如果要进行非常大的数的计算或者高精度浮点值的计算，可用使用 `BigInteger` 和 `BigDecimal` 类，它们是不可变的__

  ```uml
  +BigInteger(String)
  +BigDecimal(String)
  +add() 加
  +subtract() 减
  +multiple() 乘
  +divide()	除
  +divide(BigDecimal d,int scale, int roundingMode); 指定尺度和舍入方式 scale 是指小数点后最小的整数位数，舍入方式为 roundingMode
  +remainder
  ## 算术运算的必须为对象，且两个对象类型必须一致
  ```

* `String` 类，String 类对象不可改变，一旦创建，内容不能再改变

  ```java
  // 构造字符串，可用用字符串直接量或字符数组创建一个字符串对象，String 变量存储的是对 String 对象的引用，String 对象里存储的才是字符串的值
  String newString = new String("hello world");
  String message = "hello world";
  char[] charArray = {'G', 'o', 'o', 'd'}  单引号字符，双引号字符串
  String message = new String(charArray);
  // 字符串对象一旦创建，不能改变，将字符串变量赋值给新的一个字符串，是将该新的字符串引用赋给了该字符串变量，对具有相同字符序列的字符串直接量使用同一个实例
  // 字符串的替换和分隔,返回一个新字符串对象
  replace(oldChar: char, new Char): string
  "Welcome".replace('e', 'A')； // WAlcomA
  "welcome".replaceFirst("e", "AB");  // WABlcome
  "welcome".replace("e", "AB");  // WABlcomAB
  split(String regex);  //指定分隔符分割字符串，返回一个字符串数组
  // 依照模式匹配，替换和分割
  matches(String regex);   // 正则表达式匹配
  replaceAll(regex, replacement);  // 正则表达式全局替换
  replaceFirst(regex, replacement); // 正则表达式首次出现替换
  // 字符串与数组之间的转换
  char[] chars = "Java".toCharArray()  // 字符串转数组
  getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin); // 将下标从 scrbegin 到 srcEnd -1 的字串赋值到字符数组 dst 中下标从 detBegin 开始的位置
  // 将字符和数值转换为字符串
  valueOf(mixd):string
  // 格式化字符串，静态方法 format
  String.format(format, item1, item2); // 返回一个格式化的字符串
  ```

* `StringBuilder` 和 `StringBuffer` 类，类似与 `String` 类，区别 `String` 类不可改变

  __StringBuffer 中修改缓冲区的方法是同步的，如果是多任务并发访问，就是用 StringBuffer, 因为这种情况下需要同步以防止 StringBuffer 崩溃，如果是单任务，则 StringBuilder 效率更好，其余基本一致__

  ```java
  StringBuilder();		// 构建一个容量为 16 的空字符串构造器
  StringBuilder(capacity:int); // 构建一个指定容量的字符串构建器
  StringBuilder(s:String); // 构建一个指定字符串的字符串构建器
  +append(data:char[]): StringBuilder;	// 追加一个字符数组到字符串构建器
  +append(data:char[], offset:int, len:int): StringBuilder // 追加 data 中的子数组到字符串构建器
  +append(v: aPrimitiveType): StringBuilder; // 将一个基本类型值作为字符串追加到字符串构建器
  +append(s:String): StringBuilder; 	// 追加一个字符串到字符串构建器
  +delete(startIndex: int, endIndex: int): StringBuilder; 	// 删除从 startIndex 到 endIndex - 1 的字符
  +deleteCharAt(index: int): StringBuilder;	// 删除给定索引位置的字符
  +insert(index:int,data:char[],offset:int,len:int): StringBuilder; // 在字符串构建器的给定索引位置插入数组 data 的子数组
  +insert(offset: int,data:char[]): StringBuilder; 	// 向构造器的偏移位置插入数据
  +insert(offset: int, b: aPrimitiveType): StringBuilder   // 向该字符串构建器插入一个转换为字符串的值
  +insert(offset: int, s: String): StringBuilder 	// 在该字符串构建器指定的偏移位置插入一个字符串
  +replace(startIndex: int, endIndex: int, s:String):StringBuilder	将该字符串构建器从 startIndex 到 endIndex - 1 的位置的字符替换为给定的字符串
  +reverse(): StringBuilder	// 倒置构造器中的字符
  +setCharAt(index: int, ch: char): void	// 将该构造器的指定索引位置设为新的字符
  +toString(): String	   // 从字符串构建器返回一个字符串对象
  +capacity(): int		// 返回该字符串构建器的容量
  +charAt(index: int): char	// 返回指定索引的字符
  +length(): int		// 返回该构建器中的字符数
  +setLength(newLength: int): void	// 设置该构建器的新的长度
  +substring(startIndex: int): String		// 返回从 startIndex 开始的子字符串
  +substring(startIndex: int,endIndex: int): String	// 返回从 startIndex 到 enIndex -1的子字符串
  +trimToSize(): void		// 减少用于字符串构建器的存储大小
  ```

* `Object` 类 `java.lang.Object`

  __Java 中的所有类都继承自 Object 类，如果定义一个类时，没有指定继承性，那么这个类的父类就被默认为是 Object__

  ```Java
  public Sting toString();	// 返回对象类名@内存地址的字符串
  public boolean equals(Object o);	// 测试两个对象是否相等，指向同一个对象
  ```

* `ArrayList`  类 `ArrayList` 对象可以用于存储一个对象列表，`ArrayList` 来存储不限定个数的对象，ArrayList 是一种泛型类，具有一个泛型类型 `E`，创建一个 `ArrayList` 时，可以指定一个具体的类型来替换 `E`

  ```java
  ArrayList<AConcreteType> list = new ArrayList<AConcreteType>()；
  ArrayList<java.util.Date> dates = new ArrayList<java.util.Date> ();
  ArrayList<AConcreteType> list = new ArrayList<>()；
  ```

  ```java
  +ArrayList();	// 创建一个空的列表
  +add(o:E): void		// 增加一个新元素 o 到该列表的末尾
  +add(index: int, o: E): void	// 增加一个新元素 o 到该列表的指定下标处
  +clear(): void			// 清楚列表中的所有元素
  +contains(o: Object): boolean		// 如果该列表包含元素 o, 则返回 true
  +get(index: int): E		// 返回该列表指定下标位置的元素
  +indexOf(o: Object): int	// 返回列表中第一个匹配元素的下标
  +isEmpty(): boolean			// 如果该列表不包含如何元素，则返回 true
  +lastIndexOf(o: Object): int	// 返回列表中匹配的最后一个元素的下标
  +remove(o: Object): boolean		// 去除列表中的一个元素。如果该元素被去除，则返回 true
  +size(): int				// 返回列表中的元素个数
  +remove(index: int): E			// 去除指定下标位置的元素。如果该元素被去除，则返回 true
  +set(index: int, o: E): E			// 设置指定下标位置的元素
  ```

  数组和 ArrayList 之间的异同

  |       操作        |             数组              |                  ArrayList                   |
  | :---------------: | :---------------------------: | :------------------------------------------: |
  | 创建数组/数组列表 | `String[] a = new String[10]` | `ArrayList list<String> = new ArrayList<>()` |
  |     引用元素      |          `a[index]`           |              `list.get(index)`               |
  |     更新元素      |     `a[index] = "value"`      |          `list.set(index, "value")`          |
  |     返回大小      |          `a.length`           |                `list.size()`                 |
  |    添加新元素     |                               |             `list.add("value")`              |
  |  插入一个新元素   |                               |          `list.add(index, "value")`          |
  |   删除一个元素    |                               |             `list.remove(index)`             |
  |   删除一个元素    |                               |            `list.remove(Object)`             |
  |   删除所有元素    |                               |                `list.clear()`                |

  从数组创建一个数组列表,数组静态方法 `asList` 返回一个列表，传递给 `ArrayList` 构造方法用于创建一个 `ArrayList`

  ```java
  String[] array = {"red", "green", "blue"};
  ArrayList<String> list = new ArrayList<>(Arrays.asList(array));	
  ```

  从数组列表创建一个数组,数组列表的 `toArray(array)` 将 list 的内复制到 array 中

  ```java
  String[] array1 = new String[list.size()];
  list.toArray(array1);
  ```

  如果数组列表的元素时可比较的，整数，浮点数，字符串，则可以使用 `java.util.Collections` 类中的静态的 `sort` 方法来对元素进行排序

  ```java
  Integer[] array = {3,5,95,4,15,34,3,6,5};
  ArrayList<Integer> list = new ArrayList<>(Arrays.asList(array));
  java.util.Collections.sort(list);
  ```

  `java.util.Collections` 类中的静态的 `max` 和 `min` 方法返回列表中的最大和最小元素, `shuffle` 来随机打乱列表的元素

#### 静态变量，常量和方法

* 静态变量被类中的所有对象所共享。静态方法不能访问类中的实例成员，静态变量，静态变量将变量值存储在一个公共的内存地址，因为它是公共的地址，__所以如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响，java 支持静态方法和静态变量，无需创建类的实例就可以调用静态方法__
* 实例方法可以调用实例方法和静态方法，以及访问实例数据或者静态数据。静态方法可以调用静态方法以及访问静态数据域。然而，静态方法不能调用实例方法或者访问实例数据，因为静态方法不属于某个特定的对象。

#### 可见性修饰符

* 可见性修饰符可用用于确定一个类及它成员的可见性

* 可在类，方法和数据域前使用 `public` 修饰符，表示它们可以被任何其他的类访问。__表示它们可以被任何其他类访问，如果没有使用可见性修饰符，那么默认类，方法和数据域是可以被同一个包的任何一个类方法。这称为 包私有 （package-private）或 包内访问（package-access）__

* 包可用用来组织类，在使用是在程序文件开头声明 `package packageName` ,如果定义类中没有声明包，就表示它放在默认包中。

* `private` 修饰符限定方法和数据域只能在它自己的类中访问。

* `protected` 一个类中的受保护成员可用从子类中访问，父类中被保护的数据域或方法可以在它子类中访问

* 可见性递增 `私有 -> 默认 -> 被保护 -> 公共成员`

  | 类中成员修饰符 | 在同一类中可访问 | 在同一包中可访问 | 在子类内可访问 | 在不同包可访问 |
  | :------------: | :--------------: | :--------------: | :------------: | :------------: |
  |     public     |        是        |        是        |       是       |       是       |
  |   protected    |        是        |        是        |       是       |       否       |
  |    defaule     |        是        |        是        |       否       |       否       |
  |    private     |        是        |        否        |       否       |       否       |

* __如果一个变量或方法依赖于类的某个具体实例，那就应该将它定义为实例变量或实例方法。如果一个变量或方法不依赖于类的某个具体实例，就应该将它定义为静态变量或静态方法__

#### 数据域封装

将数据域设为私有保护数据，并且使类易于维护，为了避免对数据域的直接修改，应该使用 `private` 修饰符将数据域声明为私有。为了能修改私有数据域，可以提供一个修改器方法, 和访问器方法

* 访问器 `get()` 方法

  `public returnType getPropertyName()`

* 修改器 `set()` 方法

  `public void setPropertyName(dataType propertyValue)`

#### 对象数组

数组既可以存储基本类型值，也可以存储对象，对象的数组实际是引用变量的数组。调用 `curcleArray[1].getArea()` 实际上调用了两个层次的引用，`curcleArray` 引用了整个数组，`curcleArray[1]` 引用了一个 `circle` 对象，

**当使用 new 操作符创建对象数组后，这个数组中的每个元素都是默认值为 `null` 的引用变量**

#### 变量的作用域

__实例变量和静态变量的作用域是整个类，无论变量是在哪里声明__

* 一个类的实例变量和静态变量称为类变量或数据域，在方法内部定义的变量称为局部变量，类的变量和方法可以在类中以任意顺序出现
* 如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量将被隐藏。

#### this 引用

__关键字 this 引用对象自身，它也可以在构造方法内部用于调用同一个类的其他构造方法，关键字 this 是指向调用对象本身的引用名。可用 this 关键字引用对象的实例成员__

* this 关键字可用用来引用类的隐藏数据域，在数据域的 set 方法中，经常将数据域名用作参数名。在这种情况下，这个数据域在 set 方法中被隐藏。为了给它设置新值，需要在方法中引用隐藏的数据域名。隐藏的静态变量可用简单的通过 `类名.静态变量` 方式访问。隐藏的实例变量就需要使用关键字 `this` 来引用
* 使用 this 可用调用同一个类的另一个构造方法

#### 类的关系

* 关联：关联是一种常见的二元关系，描述两个类之间的活动，关系中涉及的每个类可以有一个角色表示，描述在该关系中担当的角色，关联中涉及的每个类可以给定一个多重性，多重性可以是一个数字或一个区间，决定在关系中涉及类的多少个对象
* 聚集：聚集是关联的一种特殊形式，代表了两个对象之间的归属关系。聚集建模 `has-a` 关系。所有者对象称为聚集对象，它的类称为聚集类。而从属对象称为被聚集对象，它的类称为被聚集类。一个对象可以被多个其他的聚集对象所拥有，如果一个对象只归属于一个聚集对象，那么它和聚集对象之间的关系就称为组合

#### 将基本数据类型值作为对象处理

__基本数据类型值不是一个对象，但是可用使用 JAVA API 中的包装类来包装成一个对象，出于性能考虑，在 Java 中基本数据类型不作为对象使用。因为处理对象需要额外的系统开销，Java 提供了一个方便的方法，即将基本数据类型包装成对象。通过使用包装类，可以将基本数据类型值作为对象处理__

__根据上下文环境，基本数据类型值可以使用包装类自动转换成一个对象，反过来的自动转换也可以，将基本类型值转换为包装类的过程为装箱，将包装了转换为基本类型为开箱，Java 支持自动装开箱__

* 包装类没有无参构造方法，所有包装类都是不可变的，一旦创建该对象，它们内部值就不能再改变
* 每一个数值包装类都有常量 `MAX_VALUE` 和 `MIN_VALUE` 表示对象基本数据类型的最大值和最小值
* 每个数值包装类都包含方法 `doubleValue`, `floatValue`, `intValue` , `longValue` ,`shortValue`, 这些方法返回包装对象的 `double`, `float`, `int`, `long` , `short` 值。
* 数值包装类中包含 `compareTo` 方法用于比较两个数值，如果该数值大于，等于，小于另外一个数值时，分别返回 1，0，-1
* 数值包装类有一个有用的静态方法 `valueOf(String s)` 该方法创建一个新对象，并将它初始化为指定字符串表示的值
* 使用 `Integer` 类中的 `parseInt` 方法将一个数值字符串转换为一个 `int` 值，如果数值字符串参数不是一个合法的待转换的数值字符串，则会发生运行时错误,该方法为类的静态方法，直接调用即可

#### super 关键字

关键字 super 指这个 super 关键字所在类的父类，可用于调用父类中的普通方法和构造方法。

* 调用父类构造方法 `super()` 或 `super(parameters)`, `super` 必须出现在子类构造方法第一行，这是显示调用父类构造方法的唯一方法
* 构造方法链：构造方法可以调用重载的构造方法或父类的构造方法。如果它们都没有被显示地调用，编译器就会自动地将 `super()` 作为构造方法的第一条语句，在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类的对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法，如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自身的父类的构造方法。这个过程持续到沿着这个继承体系结构的最后一个构造方法被调用为止。

* 调用父类方法：`super.方法名（参数）`

#### 方法重写

__要重写一个方法，需要在子类中使用和父类一样的签名以及一样的返回值类型来对该方法进行定义，在子类的方法前面放一个 `@Override` 来重写标注__

* 仅当实例方法是可访问时，它才能被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系
* 静态方法也能被继承，但是静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏，可使用 `父类名.静态方法名` `SuperClass.staticMethod` 调用隐藏的静态方法
* 方法重写发生在通过继承而相关的不同类中；方法重载可以发生在同一类中，也可以发生在由于继承而相关的不同类中，方法重写具有同样的签名和返回值类型；方法重载具有同样的名字，但是不同的参数列表

#### 多态

__多态意味着父类的变量可以指向子类对象,每个子类实例都是其父类的实例，但反过来不成立，使用父类对象的地方都可以使用子类的对象__

#### 动态绑定

__方法可以在沿着继承链的多个类中实现，JVM 决定运行时候调用那个方法__

* 声明类型：一个变量必须被声明为某种类型，变量的这个类型称为它的声明类型，一个引用类型变量可以是 null 值或者是一个对声明类型实例的引用，实例可以使用声明类型或它的子类型的构造方法创建
* 实际类型：是被变量引用的对象的实际类，调用那个方法是由实际类型决定的。
* 如果对象 `o` 调用一个方法 `p`，那么 `JVM` 会依次在本类及继承链查找 `p` 方法的实现，一旦找到一个实现就停止查找，然后调用这个首先找到的实现

#### 对象转换和 instanceof 运算符

__对象转换：对象的引用可以类型转换为对另外一种对象的引用 `(class)o`__

* 总是可以将一个子类的实例转换为一个父类的变量（向上转换）因为子类的实例永远是它父类的实例。当把一个父类的实例转换为它的子类变量（向下转换）时，必须使用转换记号`(子类名)`  进行显示转换，向编译器告知具体实例类型
* 在尝试转换之前确保该对象是目标类型的实例。使用运算符 `instanceof` 来实现
* 基本类型值转换返回一个新值，而转换一个对象引用不会创建一个新的对象