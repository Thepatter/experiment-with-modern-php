## Java 并发相关

### 中断线程

当线程的 `run()` 方法执行方法体中最后一条语句后，并经由执行 `return` 语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。在 Java 的早期版本中，还有一个 `stop` 方法，其他线程可以调用它终止线程。但，现在已经被弃用了。

没有可以强制线程终止的方法。`interrupt` 方法可以用来请求终止线程，当对一个线程调用 `interrupt` 方法时，线程的终端状态将被置位。这是每一个线程都具有的 `boolean` 标志。每个线程都应该不时检查这个标志，以判断线程是否被中断

要确定中断状态是否被置位，首先调用静态的 `Thread.currentThread` 方法获得当前线程，然后调用 `isInterrupted` 方法，但如果线程被阻塞，就无法检测中断状态。当在一个被阻塞的线程（调用 `sleep` 或 `wait`）上调用 `interrupt` 方法，阻塞调用将会被 `Interrupted Exception` 异常中断。

### 线程状态

线程有 6 类状态

* New (新创建)

* Runnable (可运行)

* Blocked (被阻塞)

* Waiting  (等待)

* Timed waiting (记时等待）

* Terminated (被终止)

  ​				*线程状态*

![](./Images/线程状态.png)

#### 新创建线程

当用 `new` 操作符创建一个新线程时，如 `new Thread(r)`，该线程还没有开始运行。这意味着它状态是 `new` 。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做

#### 可运行线程

一旦调用 `start` 方法，线程处于 `runnable` 状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。（Java 规范中，一个正在运行中的线程仍然处于可运行状态）

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得远行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级别

现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 `yield` 方法，或者被阻塞或等待时，线程才失去控制权

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制

#### 被阻塞线程和等待线程

当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的

* 当一个线程试图获取一个内部的对象锁（而不是 `java.util.concurrent` 库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态
* 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用 `Object.wait` 方法或 `Thread.join` 方法，或者是等待 `java.util.comcurrent` 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的
* 有几个方法有一个超时参数。调用它们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 、`Object.wait`、`Thread.join` 、`Lock.tryLock` 以及`Condition.await` 的计时版

#### 被终止的线程

线程因如下两个原因之一被终止

* 因为 `run` 方法正常退出而自然死亡
* 因为一个没有捕获的异常终止了 `run` 方法而意外死亡

可以调用线程的 `stop` 方法杀死一个线程。该方法抛出 `ThreadDeath` 错误对象，由此杀死线程，但是，`stop` 方法已过时，不要在代码中调用这个方法

#### 线程优先级

在 Java 程序中，每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。可以用 `setPriority` 方法提高或降低任何一个线程的优先级。可以将优先级设置为 `MIN_PRIORITY` （在 Thread 类中定义为 1）与 `MAX_PRIORITY` （定义为 10）之间的任何值。`NORM_PRIORITY` 被定义为 5

每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许会更多或更少

Oracle 为 Linux 提供的 Java 虚拟机中，线程的优先级被忽略，所有的线程具有相同的优先级，不要将程序构建为功能的正确性依赖于优先级