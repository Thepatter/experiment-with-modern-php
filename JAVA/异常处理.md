## 异常

__在程序运行过程中,如果 JVM 检测出一个不可能执行的操作,就会出现运行时错误 (runtime error),在 java 中,运行时错误会作为异常抛出.异常就是一种对象,表示阻止正常进行程序执行的错误或情况.,如果异常没有被处理,那么程序就会非正常终止__

### 异常处理概述

__异常是从方法抛出的,方法的调用者可以捕获以及处理该异常__

`try {} catch (Exception ex){}`

### 抛出异常

`throw new ArithmeticException("Divisor cannot be zero")`, 抛出的值为一个异常,`throw` 语句的执行称为抛出一个异常, 异常就是一个从异常类创建的对象

### 异常类型

异常是对象,异常的根类是 `java.lang.Throwable`, 所有的 `java` 类都直接或间接继承自 `Throwable` ,异常类分为系统错误，异常和运行时错误

* 系统错误是由 `Java` 虚拟机抛出的，用 `Error` 类表示。`Error` 类描述的是内部系统错误。这样的错误很少发生，如果发生，除了通知用户以及尽量稳妥的终止程序外，几乎什么都不能做

  `LinkageError` 一个类对另一个类有某种依赖，但是在编译前者后，后者进行了修改，变得不兼容

  `VirtualMachineError` `Java` 虚拟机崩溃，或者运行所必须的资源已经耗尽

* 异常时用 `Exception` 类表示，它描述的是由程序和外部环境所引起的错误，这戏错误能被程序捕获和处理

  `ClassNotFoundException` 试图使用一个不存在的类

  `IOException` 同输入输出相关的操作

* 运行时异常是用 `RuntimeException` 类表示的，它描述的是程序设计错误，如错误的类型转换。访问一个越界数组。运行时错误由 `Java` 虚拟机抛出的

  `ArithmeticException` 一个整数除以 0

  `NullPointerException`	试图通过一个 null 引用变量访问一个对象

  `IndexOutOfBoundsException`	 数组的下标超出范围

  `IllegalArgumentException`	传递给方法的参数非法或不合适

`RuntimeException` 和 `Error` 以及它们的子类都称为免检异常，所有的其他异常都称为必检异常（编译器会强制程序员检查并通过 `try-catch` 处理它们，或者在方法头中进行声明），大多情况下，免检异常都会反映除程序设计上不可恢复的逻辑错误。免检异常可能在程序的任何一个地方出现

#### 预定义异常

异常的处理是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方法找到的。`java` 的异常处理模型基于三种操作：声明一个异常，抛出一个异常，捕获一个异常。

#### 声明异常 `throws`

__在 Java 中，当前指向的语句必属于某个方法，Java 解释器调用 main 方法开始执行一个程序，每个方法都必须声明它可能抛出的必检异常的类型。Java 不要求在方法中显示声明 Error 和 RuntimeException, 但是方法要抛出的其他异常必须在方法头中显示声明，这样方法的调用者会被告知由异常__

```java
public void myMethod() throws IOException
public void myMethod() throws Exception1, Exception2,,, ExceptionN
```

如果方法没有在父类中声明异常，那么就不能在子类中对其进行继承来声明异常

#### 抛出异常`throw`

__检测到错误的程序可以创建一个合适的异常类型的实例并抛出,通常 Java 中的每个异常类至少由两个构造方法：一个无参构造方法和一个带可描述这个异常的 String 参数的构造方法。该参数为异常消息，可用 getMessage() 获取__

* 从一个通用的父类可用派生除各种异常类。如果一个 `catch` 块可以捕获一个父类的异常对象，它就能捕获那么父类的所有子类的异常对象

* 在 catch 块中异常被指定的顺序是非常重要的，如果父类的 catch 块出现在子类的 catch 块之前，就会编译错误

* 如果方法声明了一个必检异常，就必须在 `try-catch` 块中调用它，或者在调用方法中声明要抛出的异常

  ```java
  void p2() throws IOException {
      Scanner scanner = new Scanner("system");
      int input = scanner.nextInt();
      System.out.println(input);
  }
  
  void p1 () throws IOException{
      p2();
  }
  
  void p3() {
      try {
          p2();
      } catch (IOException Ie) {
          System.out.println(Ie.getMessage());
      }
  
  }
  ```

#### 捕获异常

* 如果在执行 `try` 块的过程中没有出现异常，则跳过 `catch` 子句，如果 `try` 块中的某条语句抛出一个异常，Java 就会跳过 `try` 块中剩余的语句，然后开始查找处理这个异常的代码的过程。处理这个异常的代码称为异常处理器
* 可以从当前的方法开始，沿着方法调用链，按照异常的反响传播方向找到这个处理器。从第一个到最后一个逐个检查 `catch` 块，判断在 `catch` 块中的异常类实例是否是该异常对象的类型，如果是，就将该异常对象赋值给所声明的变量，然后执行 `catch` 块中的代码。如果没有发现异常处理器，Java 会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器，如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息

#### 从异常中获取信息

__异常对象包含关于异常的有价值的信息，可以使用 `java.lang.Throwable` 类中的实例方法获取有关异常的信息

```java
getMessage(): String		// 返回描述该异常对象的信息
toString():	String		// 返回三个字符串的连接：1，异常类的全名，2，": " 3,getMessage() 方法
printStackTrace():	void		// 在控制台上打印 Throwable 对象和它的调用堆栈信息
getStackTrace():	StackTraceElement[]		// 返回和该异常对象相关的代表堆栈跟踪的一个堆栈跟踪元素的数组
```

#### finally 子句

在任何情况下，finally 块中的代码都会执行，不论 try 块中是否出现异常或者是否被捕获

* 如果 `try` 块中没有出现异常，执行 `finally statements` 然后执行 `try` 语句的下一条语句

* 如果 `try` 块中有一条语句引起异常，并被 `catch` 块捕获，然后跳过 `try` 块的其他语句，执行 `catch` 块和 `finally` 子句。执行 `try` 语句之后的下一条语句

* 如果 `try` 块中有一条语句引起异常，但是没有被任何 `catch` 块捕获，就会跳过 `try` 块中的其他语句，执行 `finally` 子句，并且将异常传递给这个方法的调用者
