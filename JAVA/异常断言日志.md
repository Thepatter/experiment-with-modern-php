## 异常

__在程序运行过程中,如果 JVM 检测出一个不可能执行的操作,就会出现运行时错误 (runtime error),在 java 中,运行时错误会作为异常抛出.异常就是一种对象,表示阻止正常进行程序执行的错误或情况.,如果异常没有被处理,那么程序就会非正常终止__

### 异常处理概述

__异常是从方法抛出的,方法的调用者可以捕获以及处理该异常__

`try {} catch (Exception ex){}`

### 抛出异常

`throw new ArithmeticException("Divisor cannot be zero")`, 抛出的值为一个异常,`throw` 语句的执行称为抛出一个异常, 异常就是一个从异常类创建的对象

### 异常类型

异常是对象,异常的根类是 `java.lang.Throwable`, 所有的 `java` 类都直接或间接继承自 `Throwable` ,异常类分为系统错误，异常和运行时错误

* 系统错误是由 `Java` 虚拟机抛出的，用 `Error` 类表示。`Error` 类描述的是内部系统错误。这样的错误很少发生，如果发生，除了通知用户以及尽量稳妥的终止程序外，几乎什么都不能做

  `LinkageError` 一个类对另一个类有某种依赖，但是在编译前者后，后者进行了修改，变得不兼容

  `VirtualMachineError` `Java` 虚拟机崩溃，或者运行所必须的资源已经耗尽

* 异常是用 `Exception` 类表示，它描述的是由程序和外部环境所引起的错误，这戏错误能被程序捕获和处理

  `ClassNotFoundException` 试图使用一个不存在的类

  `IOException` 同输入输出相关的操作

* 运行时异常是用 `RuntimeException` 类表示的，它描述的是程序设计错误，如错误的类型转换。访问一个越界数组。运行时错误由 `Java` 虚拟机抛出的

  `ArithmeticException` 一个整数除以 0

  `NullPointerException`	试图通过一个 null 引用变量访问一个对象

  `IndexOutOfBoundsException`	 数组的下标超出范围

  `IllegalArgumentException`	传递给方法的参数非法或不合适

`RuntimeException` 和 `Error` 以及它们的子类都称为免检异常，所有的其他异常都称为必检异常（编译器会强制程序员检查并通过 `try-catch` 处理它们，或者在方法头中进行声明），大多情况下，免检异常都会反映除程序设计上不可恢复的逻辑错误。免检异常可能在程序的任何一个地方出现

#### 预定义异常

异常的处理是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方法找到的。`java` 的异常处理模型基于三种操作：声明一个异常，抛出一个异常，捕获一个异常。

#### 声明异常 `throws`

__在 Java 中，当前指向的语句必属于某个方法，Java 解释器调用 main 方法开始执行一个程序，每个方法都必须声明它可能抛出的必检异常的类型。Java 不要求在方法中显示声明 Error 和 RuntimeException, 但是方法要抛出的其他异常必须在方法头中显示声明，这样方法的调用者会被告知由异常__

```java
public void myMethod() throws IOException
public void myMethod() throws Exception1, Exception2,,, ExceptionN
```

如果方法没有在父类中声明异常，那么就不能在子类中对其进行继承来声明异常

#### 抛出异常`throw`

__检测到错误的程序可以创建一个合适的异常类型的实例并抛出,通常 Java 中的每个异常类至少由两个构造方法：一个无参构造方法和一个带可描述这个异常的 String 参数的构造方法。该参数为异常消息，可用 getMessage() 获取__

* 从一个通用的父类可用派生除各种异常类。如果一个 `catch` 块可以捕获一个父类的异常对象，它就能捕获那么父类的所有子类的异常对象

* 在 catch 块中异常被指定的顺序是非常重要的，如果父类的 catch 块出现在子类的 catch 块之前，就会编译错误

* 如果方法声明了一个必检异常，就必须在 `try-catch` 块中调用它，或者在调用方法中声明要抛出的异常

  ```java
  void p2() throws IOException {
      Scanner scanner = new Scanner("system");
      int input = scanner.nextInt();
      System.out.println(input);
  }
  
  void p1 () throws IOException{
      p2();
  }
  
  void p3() {
      try {
          p2();
      } catch (IOException Ie) {
          System.out.println(Ie.getMessage());
      }
  
  }
  ```

#### 捕获异常

* 如果在执行 `try` 块的过程中没有出现异常，则跳过 `catch` 子句，如果 `try` 块中的某条语句抛出一个异常，Java 就会跳过 `try` 块中剩余的语句，然后开始查找处理这个异常的代码的过程。处理这个异常的代码称为异常处理器
* 可以从当前的方法开始，沿着方法调用链，按照异常的反响传播方向找到这个处理器。从第一个到最后一个逐个检查 `catch` 块，判断在 `catch` 块中的异常类实例是否是该异常对象的类型，如果是，就将该异常对象赋值给所声明的变量，然后执行 `catch` 块中的代码。如果没有发现异常处理器，Java 会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器，如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息

#### 从异常中获取信息

__异常对象包含关于异常的有价值的信息，可以使用 `java.lang.Throwable` 类中的实例方法获取有关异常的信息

```java
getMessage(): String		// 返回描述该异常对象的信息
toString():	String		// 返回三个字符串的连接：1，异常类的全名，2，": " 3,getMessage() 方法
printStackTrace():	void		// 在控制台上打印 Throwable 对象和它的调用堆栈信息
getStackTrace():	StackTraceElement[]		// 返回和该异常对象相关的代表堆栈跟踪的一个堆栈跟踪元素的数组
```

#### finally 子句

在任何情况下，finally 块中的代码都会执行，不论 try 块中是否出现异常或者是否被捕获

* 如果 `try` 块中没有出现异常，执行 `finally statements` 然后执行 `try` 语句的下一条语句

* 如果 `try` 块中有一条语句引起异常，并被 `catch` 块捕获，然后跳过 `try` 块的其他语句，执行 `catch` 块和 `finally` 子句。执行 `try` 语句之后的下一条语句

* 如果 `try` 块中有一条语句引起异常，但是没有被任何 `catch` 块捕获，就会跳过 `try` 块中的其他语句，执行 `finally` 子句，并且将异常传递给这个方法的调用者

### 异常机制良好实践

* 异常处理不能代替测试即只在异常情况下使用异常机制，因为捕获异常时间更久
* 不过分细化异常
* 利用异常层次结构
* 不要压制异常
* 早抛出，晚捕获（抛出异常到上层方法及应用）
* 不要在 `finally` 里 `return`，且不要出现无法访问语句

### 断言

断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会自动地移走

`java` 语言引入了关键字 `assert` ：`assert 条件`；`assert 条件：表达式` 。这两种形式都会对条件进行检测，如果结果为 `false`，则抛出一个 `AssertionError` 异常。在第二种形式中，表达式将被传入 `AssertionError` 的构造器，并转换成一个消息字符串。（表达式部分的唯一目的是产生一个消息字符串。`AssertionError` 对象并不存储表达式的值，因此，不可能在以后得到它）

#### 启用和禁用断言

在默认情况下，断言被禁用。可以在运行程序时用 `-enableassertions` 或 `-ea` 选项启用：

`java -enableassertions MyApp`

在启用或禁用断言时不必要重新编译程序。启用或禁用断言时类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度

在某个类或整个包中使用断言

`java -ea:MyClass -ea:com.mycompany.mylib... MyApp`

这条命令将开启 `MyClass` 类以及在 `com.mycompany.mylib` 包和它的子包中的所有类的断言。选项 `-ea` 将开启默认包中的所有类的断言

可以用选项 `-disableassertions` 或 `-da` 禁用某个特定类和包的断言

`java -ea:... -da:MyClass MyApp`

有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。启用和禁用所有断言的 `-ea` 和 `-da` 开关不能应用到那些没有类加载器的 “系统类” 上。对于这些系统类，需要使用 `-enablesystemassertions/-esa` 开关启用断言。

### 异常执行顺序

```java
try{} catch() {} finally{} return;
```

顺序执行

```java
try {return;} catch() {} finally{} return;
```

程序执行 `try` 里 `return` 代码块前的代码，出现异常执行 `catch` 中的代码，然后执行最后的 `return` 代码；程序执行 `try` 里 `return` 代码块前的代码，不出现异常则将先执行 `finally` 里代码，然后执行 `try` 里的 `return` 代码，最后的 `return` 语句不会执行

```java
try {} catch() {return;} finally {} return;
```

程序执行 `try` 出现异常则执行 `catch` 代码，然后执行 `finally` 代码，返回 `catch` 中的 `return` 返回值，最后的 `return` 不会执行；程序执行 `try` 不出现异常，然后执行 `finally` 语句，执行最后的 `return` 语句

```java
try {return;} catch() {return;} finally {return;}
```

`finally` 中不要包含 `return` 语句，否则就始终返回 `finally` 里 `return`  返回值

```java
try {return;} catch() {return;} finally {} return;
```

编译错误，不可访问错误，最后的 `return` 语句不会被访问

### 日志

#### 基本日志

要生成简单的日志记录，可以使用全局日志记录器并调用其 `info` 方法

`Logger.getGlobal().info("File->Open menu item selected")`

如果在 `main` 调用 `Logger.getGlobal().setLevel(Level.OFF)` 将会取消所有的日志

