# 数据结构与算法分析

### 枚举类型

__枚举类型定义了一个枚举值的列表，每个值是一个标识符，是类型安全的，试图赋一个枚举类型所列出的值或者 null 之外的一个值，都将导致编译错误__

* 必须使用枚举类型名称作为限定词来引用一个值
* 枚举类型被作为一个特殊的类来对待，是 `Object` 类和 `Comparable` 接口的子类。枚举类型的变量是引用变量，可以调用 `object` 和 `Comparable` 方法
* 枚举类型中的第一个值具有序号数 0，第二个具有序号数 1

```java
enum FavoriteColor {RED, BLUE, GREEN, YELLOW};		// 声明枚举类型
FavoriteColor	color = FavoriteColor.BLUE;		// 声明枚举类型变量
```

### 泛型

__泛型可以参数化类型，可以定义带泛型类型的类或方法，随后编译器会用具体的类型来替换它，泛型能在编译时检测出错误__

* 可以为类或者接口定义泛型。当使用类来创建对象，或者使用类或接口来声明引用变量时，必须指定具体的类型

* 可以定义泛型接口，泛型类，泛型方法，泛型静态方法

  ```java
  public static <E> void print(E[] list);			// 静态泛型方法
  ```

* 可以将泛型指定为另外一种类型的子类型。这些的泛型类型为受限的

  ```Java
  public static <E extends InputStream> boolean equalArea(E obj1, E obj2) // E 指定为 InputStream 的泛型子类型
  ```

* 不能使用 `new E()` ，不能使用泛型类型参数创建实例
* 不能使用 `new E[]` ，不能使用泛型类型参数创建数组，`E[] elements = new E[capacity]` 则编译错误，可以通过创建一个 `object` 类型的数组，然后将它的类型转换为 `E[]` 来规避这个限制 `E[] elements = (E[])new Object[capacity]`, 类型转换到`（E[])` 会导致一个免检的编译警告
* 使用泛型类创建泛型数组也是不允许的 `ArrayList<String>[] list = new ArrayList<String>[10]`
* 在静态上下文中不允许类的参数是泛型类型，由于泛型类的所有实例都有相同的运行时类实例，所以泛型类的静态变量和方法是被它的所有实例所共享的。在静态方法，数据域或初始化语句中，为类引用泛型参数是非法的。
* 异常类不能是泛型的

### 合集 `Collection` 接口为线性表，向量，栈，队列，优先队列以及集合定义了共同的操作

Java 合集框架支持以下两种类型的容器

* 一种是为了存储一个元素合集，简称合集 `collection`

  `Set` 用于存储一组不重复的元素，`List` 用于存储一个有序元素合集，`Stack` 用于存储采用后进先出方式处理的对象，`Queue` 用于存储采用先进先出方式处理的对象，`Priority Queue` 用于存储按照优先级顺序处理的对象

* 另一种是为了存储键/值对，称为映射表，映射表是一种用于使用一个键快速搜索一个元素的高效数据结构。

`java.util.Collection` 接口是存储对象合集的根接口