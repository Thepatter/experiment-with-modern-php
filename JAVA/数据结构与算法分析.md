# 数据结构与算法分析

### 枚举类型

__枚举类型定义了一个枚举值的列表，每个值是一个标识符，是类型安全的，试图赋一个枚举类型所列出的值或者 null 之外的一个值，都将导致编译错误__

* 必须使用枚举类型名称作为限定词来引用一个值
* 枚举类型被作为一个特殊的类来对待，是 `Object` 类和 `Comparable` 接口的子类。枚举类型的变量是引用变量，可以调用 `object` 和 `Comparable` 方法
* 枚举类型中的第一个值具有序号数 0，第二个具有序号数 1

```java
enum FavoriteColor {RED, BLUE, GREEN, YELLOW};		// 声明枚举类型
FavoriteColor	color = FavoriteColor.BLUE;		// 声明枚举类型变量
```

### 泛型

__泛型可以参数化类型，可以定义带泛型类型的类或方法，随后编译器会用具体的类型来替换它，泛型能在编译时检测出错误__

* 可以为类或者接口定义泛型。当使用类来创建对象，或者使用类或接口来声明引用变量时，必须指定具体的类型

* 可以定义泛型接口，泛型类，泛型方法，泛型静态方法

  ```java
  public static <E> void print(E[] list);			// 静态泛型方法
  ```

* 可以将泛型指定为另外一种类型的子类型。这些的泛型类型为受限的

  ```Java
  public static <E extends InputStream> boolean equalArea(E obj1, E obj2) // E 指定为 InputStream 的泛型子类型
  ```

* 不能使用 `new E()` ，不能使用泛型类型参数创建实例
* 不能使用 `new E[]` ，不能使用泛型类型参数创建数组，`E[] elements = new E[capacity]` 则编译错误，可以通过创建一个 `object` 类型的数组，然后将它的类型转换为 `E[]` 来规避这个限制 `E[] elements = (E[])new Object[capacity]`, 类型转换到`（E[])` 会导致一个免检的编译警告
* 使用泛型类创建泛型数组也是不允许的 `ArrayList<String>[] list = new ArrayList<String>[10]`
* 在静态上下文中不允许类的参数是泛型类型，由于泛型类的所有实例都有相同的运行时类实例，所以泛型类的静态变量和方法是被它的所有实例所共享的。在静态方法，数据域或初始化语句中，为类引用泛型参数是非法的。
* 异常类不能是泛型的

### 合集 `Collection` 接口为线性表，向量，栈，队列，优先队列以及集合定义了共同的操作

Java 合集框架支持以下两种类型的容器

* 一种是为了存储一个元素合集，简称合集 `collection`

  `Set` 用于存储一组不重复的元素，`List` 用于存储一个有序元素合集，`Stack` 用于存储采用后进先出方式处理的对象，`Queue` 用于存储采用先进先出方式处理的对象，`Priority Queue` 用于存储按照优先级顺序处理的对象

* 另一种是为了存储键/值对，称为映射表，映射表是一种用于使用一个键快速搜索一个元素的高效数据结构。

`java.util.Collection` 接口是存储对象合集的根接口

*java.util.Collection.java*

```java
add(o: E): boolean				// 添加一个新的元素 o 到合集中
addAll(c: Collection<? extends E>): boolean    // 将合集 c 中的所有元素添加到该合集中，并集
clear(): void			// 从该合集删除所有元素
contains(o: Object)		// 如果该合集包含元素 o, 则返回 true
containsAll(c: Collection<?>): boolean		// 如果该合集包含 c 中所有的元素，则返回 true
equals(o: Object): boolean			// 如果该合集等同于另外一个合集 o,则返回 true
hashCode(): int			// 返回该合集的哈希码
isEmpty(): boolean		// 如果该合集没有包含元素，则返回 true
remove(o: Object): boolean	// 从该合集中移除元素 o
removeAll(c: Collection<?>): boolean		// 从该合集中移除 c 中的所有元素， 差集
retainAll(c: Collction<?>): boolean			// 保留同时位于 c 和该合集中的元素，交集
size(): int			// 返回该合集中的元素数目
toArray()： Object[]		// 为该合集中的元素返回一个 Object 数组
iterator(): Iterator<E>		// 为该集合中的元素返回一个迭代器
```

* 迭代器：每种合集都是可迭代的。可以获得集合中的 iterator 对象来遍历合集中的所有元素

java.lang.Iterator.java*

```java
hasNext(): boolean			// 如果该迭代器还有下一个元素，则返回 true
next(): E				// 返回该迭代器中的下一个元素
remove(): void			// 移除使用 next 方法获取的上一个元素
```

* 线性表：list 接口继承自 `Collection` 接口，定义了一个允许重复用于顺序存储元素的合集。可以使用它的两个具体类数组线性表 `ArrayList` 或者链表 `LinkedList` 来创建一个线性表 `list`

*java.util.List.java*

```java
add(index: int, element: Object): boolean	// 在指定索引位置处增加一个新元素
addAll(index: int, c: Collection<? extends E>): boolean 	// 在指定索引位置处添加 c 中的所有元素
get(index: int): E   	// 返回该线性表指定索引位置处的元素
indexOf(element: Object): int 		// 返回第一个匹配元素的索引
lastIndexOf(element: Object): int		// 返回最后一个匹配元素的索引
listIterator(): ListIterator<E>			// 返回针对该线性表元素的迭代器
listIterator(startIndex: int): ListIterator<E>		// 返回针对从 startIndex 开始的元素的迭代器
remove(index: int): E			// 移除指定索引位置处的元素
set(index: int, element: Object): Object 	// 设置指定索引处的元素
subList(fromIndex: int, toIndex: int): List<E>		// 返回从 fromIndex 到 toIndex-1 的子线性表
```

*java.util.ListIterator.java* 接口可以双向遍历线性表,继承 Iterator 接口

```java
/** 添加一个指定的对象到线性表中，如果 Iterator 接口中定义的 next() 方法的返回值非空，该元素将被插入**到 next() 方法返回的元素之前；如果 previous() 方法的返回值非空，该元素将被插入到 previous() 方法**返回的元素之后，如果线性表中没有元素，这个新元素即成为线性表中唯一的元素
**/
add(element: E): void
add(element: E): void
hasPrevious(): boolean		// 当往回遍历时，如果该线性表遍历器还有更多的元素，则返回 true
nextIndex(): int			// 返回下一个元素的索引
previous(): E			// 返回该线性表遍历器的前一个元素
previousIndex(): int		// 返回前一个元素的索引
set(element: E): void		// 使用指定的元素替换 previous 或者 next 方法返回的最后一个元素
```

*java.util.AbstractSequentialList.java*

```java
LinkedList() 		// 创建一个默认的空线性表
LinkedList(c: Collection<? extends E>)		// 从已经存在的合集中创建一个线性表
addFirst(element: E): void			// 添加元素到该线性表的头部
addLast(element: E): void			// 添加元素到该线性表的尾部
getFirst(): E						// 返回该线性表的第一个元素
getLast(): E						// 返回该线性表的最后一个元素
removeFirst(): E					// 从该线性表中返回并删除第一个元素
removeLast(): E						// 从该线性表中返回并删除最后一个元素
```

