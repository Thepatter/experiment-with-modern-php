# 数据结构与算法分析

### 枚举类型

__枚举类型定义了一个枚举值的列表，每个值是一个标识符，是类型安全的，试图赋一个枚举类型所列出的值或者 null 之外的一个值，都将导致编译错误__

* 必须使用枚举类型名称作为限定词来引用一个值
* 枚举类型被作为一个特殊的类来对待，是 `Object` 类和 `Comparable` 接口的子类。枚举类型的变量是引用变量，可以调用 `object` 和 `Comparable` 方法
* 枚举类型中的第一个值具有序号数 0，第二个具有序号数 1

```java
enum FavoriteColor {RED, BLUE, GREEN, YELLOW};		// 声明枚举类型
FavoriteColor	color = FavoriteColor.BLUE;		// 声明枚举类型变量
```

### 泛型

__泛型可以参数化类型，可以定义带泛型类型的类或方法，随后编译器会用具体的类型来替换它，泛型能在编译时检测出错误__

* 可以为类或者接口定义泛型。当使用类来创建对象，或者使用类或接口来声明引用变量时，必须指定具体的类型

* 可以定义泛型接口，泛型类，泛型方法，泛型静态方法

  ```java
  public static <E> void print(E[] list);			// 静态泛型方法
  ```

* 可以将泛型指定为另外一种类型的子类型。这些的泛型类型为受限的

  ```Java
  public static <E extends InputStream> boolean equalArea(E obj1, E obj2) // E 指定为 InputStream 的泛型子类型
  ```

* 不能使用 `new E()` ，不能使用泛型类型参数创建实例
* 不能使用 `new E[]` ，不能使用泛型类型参数创建数组，`E[] elements = new E[capacity]` 则编译错误，可以通过创建一个 `object` 类型的数组，然后将它的类型转换为 `E[]` 来规避这个限制 `E[] elements = (E[])new Object[capacity]`, 类型转换到`（E[])` 会导致一个免检的编译警告
* 使用泛型类创建泛型数组也是不允许的 `ArrayList<String>[] list = new ArrayList<String>[10]`
* 在静态上下文中不允许类的参数是泛型类型，由于泛型类的所有实例都有相同的运行时类实例，所以泛型类的静态变量和方法是被它的所有实例所共享的。在静态方法，数据域或初始化语句中，为类引用泛型参数是非法的。
* 异常类不能是泛型的

### 合集 `Collection` 接口为线性表，向量，栈，队列，优先队列以及集合定义了共同的操作

Java 合集框架支持以下两种类型的容器

* 一种是为了存储一个元素合集，简称合集 `collection`

  `Set` 用于存储一组不重复的元素，`List` 用于存储一个有序元素合集，`Stack` 用于存储采用后进先出方式处理的对象，`Queue` 用于存储采用先进先出方式处理的对象，`Priority Queue` 用于存储按照优先级顺序处理的对象

* 另一种是为了存储键/值对，称为映射表，映射表是一种用于使用一个键快速搜索一个元素的高效数据结构。

`java.util.Collection` 接口是存储对象合集的根接口

*java.util.Collection.java*

```java
add(o: E): boolean				// 添加一个新的元素 o 到合集中
addAll(c: Collection<? extends E>): boolean    // 将合集 c 中的所有元素添加到该合集中，并集
clear(): void			// 从该合集删除所有元素
contains(o: Object)		// 如果该合集包含元素 o, 则返回 true
containsAll(c: Collection<?>): boolean		// 如果该合集包含 c 中所有的元素，则返回 true
equals(o: Object): boolean			// 如果该合集等同于另外一个合集 o,则返回 true
hashCode(): int			// 返回该合集的哈希码
isEmpty(): boolean		// 如果该合集没有包含元素，则返回 true
remove(o: Object): boolean	// 从该合集中移除元素 o
removeAll(c: Collection<?>): boolean		// 从该合集中移除 c 中的所有元素， 差集
retainAll(c: Collction<?>): boolean			// 保留同时位于 c 和该合集中的元素，交集
size(): int			// 返回该合集中的元素数目
toArray()： Object[]		// 为该合集中的元素返回一个 Object 数组
iterator(): Iterator<E>		// 为该集合中的元素返回一个迭代器
```

* 迭代器：每种合集都是可迭代的。可以获得集合中的 iterator 对象来遍历合集中的所有元素

java.lang.Iterator.java*

```java
hasNext(): boolean			// 如果该迭代器还有下一个元素，则返回 true
next(): E				// 返回该迭代器中的下一个元素
remove(): void			// 移除使用 next 方法获取的上一个元素
```

* 线性表：list 接口继承自 `Collection` 接口，定义了一个允许重复用于顺序存储元素的合集。可以使用它的两个具体类数组线性表 `ArrayList` 或者链表 `LinkedList` 来创建一个线性表 `list`

*java.util.List.java*

```java
add(index: int, element: Object): boolean	// 在指定索引位置处增加一个新元素
addAll(index: int, c: Collection<? extends E>): boolean 	// 在指定索引位置处添加 c 中的所有元素
get(index: int): E   	// 返回该线性表指定索引位置处的元素
indexOf(element: Object): int 		// 返回第一个匹配元素的索引
lastIndexOf(element: Object): int		// 返回最后一个匹配元素的索引
listIterator(): ListIterator<E>			// 返回针对该线性表元素的迭代器
listIterator(startIndex: int): ListIterator<E>		// 返回针对从 startIndex 开始的元素的迭代器
remove(index: int): E			// 移除指定索引位置处的元素
set(index: int, element: Object): Object 	// 设置指定索引处的元素
subList(fromIndex: int, toIndex: int): List<E>		// 返回从 fromIndex 到 toIndex-1 的子线性表
```

*java.util.ListIterator.java* 接口可以双向遍历线性表,继承 Iterator 接口

```java
/** 添加一个指定的对象到线性表中，如果 Iterator 接口中定义的 next() 方法的返回值非空，该元素将被插入**到 next() 方法返回的元素之前；如果 previous() 方法的返回值非空，该元素将被插入到 previous() 方法**返回的元素之后，如果线性表中没有元素，这个新元素即成为线性表中唯一的元素
**/
add(element: E): void
add(element: E): void
hasPrevious(): boolean		// 当往回遍历时，如果该线性表遍历器还有更多的元素，则返回 true
nextIndex(): int			// 返回下一个元素的索引
previous(): E			// 返回该线性表遍历器的前一个元素
previousIndex(): int		// 返回前一个元素的索引
set(element: E): void		// 使用指定的元素替换 previous 或者 next 方法返回的最后一个元素
```

*java.util.AbstractSequentialList.java*

```java
LinkedList() 		// 创建一个默认的空线性表
LinkedList(c: Collection<? extends E>)		// 从已经存在的合集中创建一个线性表
addFirst(element: E): void			// 添加元素到该线性表的头部
addLast(element: E): void			// 添加元素到该线性表的尾部
getFirst(): E						// 返回该线性表的第一个元素
getLast(): E						// 返回该线性表的最后一个元素
removeFirst(): E					// 从该线性表中返回并删除第一个元素
removeLast(): E						// 从该线性表中返回并删除最后一个元素
```

* `Comparator` 比较器接口，用于比较没有实现 `Comparable ` 的类的对象

  ```Java
  public int compare(T element1, I element2)    // 如果 element1 小于 element2，就返回一个负值；如果 element1 大于 element2 就返回一个正值；如果两者相等返回 0
  ```

* `Collections` 类包含了执行合集和线性表中通用操作的静态方法

  *java.util.Collections.java*

  ```Java
  sort(list: List): void				// 对指定的线性表进行排序
  sort(list: List, c: Comparator): void			// 使用比较器对指定的线性表进行排序
  binarySearch(list: List, key: Object): int		// 采用二分查找来找到排序的线性表中的键值
  binarySearch(list: List, key: Object, c: Comparator): int 	// 使用比较器，采用二分查找来找到排好序的线性表中的键值
  reverse(list: List): void		// 对指定的线性表进行逆序排序
  reverseOrder(): Comparator		// 返回一个逆序排序的比较器
  shuffle（list: List): void		// 随机打乱指定的线性表
  shuffle（list: List, rmd: Random): void		// 使用一个随机对象打乱指定的线性表
  copy(des: List, src: List): void			// 复制源线性表到目标线性表
  nCopies(n: int, o: Object): List		// 返回一个由 n 个对象副本组成的线性表
  fill(list: List, o: Object): void		// 返回对象填充线性表
  max(c: Collection): Object		// 返回合集中的 max 对象
  max(c: Collection, c: Comparator): Object	// 返回比较器返回 max 对象
  min(c: Collection): Object	// 返回合集中的 min 对象
  min(c: Collection, c: Comparator): Object	// 返回比较器返回 min 对象
  disjoint(c1: Collection c2: Collection): boolean	// 如果 c1 和 c2 没有共同的元素，则返回真
  frequency(c: Collection, o: Object): int	// 返回合集中指定元素的出现次数
  ```

* 栈类 `Stack` 扩展 `Vector` 类，提供后进先出的数据结构

  ```Java
  Stack()				// 创建一个空的栈
  empty(): boolean		// 如果栈是空的，则返回真
  peek(): E		// 返回栈中的顶部元素
  pop(): E		// 返回并移除该栈中的顶部元素
  push(o: E): E	// 增加一个新的元素到栈的顶部
  search(o: Object): int		// 返回该栈中指定元素的位置
  ```

* 队列和优先队列：队列先进先出，元素被追加到队列末尾，然后从队列头删除，在优先队列中，元素被赋予优先级，当访问元素时，拥有最高优先级的元素首先被删除

  *java.util.Queue.java*

  ```Java
  offer(element: E): boolean		// 插入一个元素到队列中
  poll(): E			// 获取并且移除队列的头元素，如果队列为空则返回 null
  remove(): E 	// 获取并移除队列头元素，如果队列为空则抛出异常
  peek(): E 	// 获取但不移除队列的头元素，如果队列为空则返回 null
  element(): E		// 获取但不移除队列头元素，如果队列为空则抛出异常
  ```

  *java.util.Deque.java* 双向队列

  ```Java
  addFirs(e)		// 队列头插入数据
  addLast(e)		// 队列未插入数据
  removeFist()		// 队列头移除数据
  removeLast()		// 队列未移除数据
  getFirst()			// 获取队列头数据
  getLast()		// 获取队列未数据
  ```

### 集合

__集合 （set）是一个用于存储和处理无重复元素的高效数据结构，可以使用集合的三个具体类 `HashSet`, `LinkedHashSet`, `TreeSet` 来创建集合__

*java.util.HashSet.java* 类是一个实现了 `Set` 接口的具体类 