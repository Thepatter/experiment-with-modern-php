# 数据结构与算法分析

### 枚举类型

__枚举类型定义了一个枚举值的列表，每个值是一个标识符，是类型安全的，试图赋一个枚举类型所列出的值或者 null 之外的一个值，都将导致编译错误__

* 必须使用枚举类型名称作为限定词来引用一个值
* 枚举类型被作为一个特殊的类来对待，是 `Object` 类和 `Comparable` 接口的子类。枚举类型的变量是引用变量，可以调用 `object` 和 `Comparable` 方法
* 枚举类型中的第一个值具有序号数 0，第二个具有序号数 1

```java
enum FavoriteColor {RED, BLUE, GREEN, YELLOW};		// 声明枚举类型
FavoriteColor	color = FavoriteColor.BLUE;		// 声明枚举类型变量
```

### 泛型

__泛型可以参数化类型，可以定义带泛型类型的类或方法，随后编译器会用具体的类型来替换它，泛型能在编译时检测出错误__

* 可以为类或者接口定义泛型。当使用类来创建对象，或者使用类或接口来声明引用变量时，必须指定具体的类型

* 可以定义泛型接口，泛型类，泛型方法，泛型静态方法

  ```java
  public static <E> void print(E[] list);			// 静态泛型方法
  ```

* 可以将泛型指定为另外一种类型的子类型。这些的泛型类型为受限的

  ```Java
  public static <E extends InputStream> boolean equalArea(E obj1, E obj2) // E 指定为 InputStream 的泛型子类型
  ```

* 不能使用 `new E()` ，不能使用泛型类型参数创建实例
* 不能使用 `new E[]` ，不能使用泛型类型参数创建数组，`E[] elements = new E[capacity]` 则编译错误，可以通过创建一个 `object` 类型的数组，然后将它的类型转换为 `E[]` 来规避这个限制 `E[] elements = (E[])new Object[capacity]`, 类型转换到`（E[])` 会导致一个免检的编译警告
* 使用泛型类创建泛型数组也是不允许的 `ArrayList<String>[] list = new ArrayList<String>[10]`
* 在静态上下文中不允许类的参数是泛型类型，由于泛型类的所有实例都有相同的运行时类实例，所以泛型类的静态变量和方法是被它的所有实例所共享的。在静态方法，数据域或初始化语句中，为类引用泛型参数是非法的。
* 异常类不能是泛型的

### 合集 `Collection` 接口为线性表，向量，栈，队列，优先队列以及集合定义了共同的操作

Java 合集框架支持以下两种类型的容器

* 一种是为了存储一个元素合集，简称合集 `collection`

  `Set` 用于存储一组不重复的元素，`List` 用于存储一个有序元素合集，`Stack` 用于存储采用后进先出方式处理的对象，`Queue` 用于存储采用先进先出方式处理的对象，`Priority Queue` 用于存储按照优先级顺序处理的对象

* 另一种是为了存储键/值对，称为映射表，映射表是一种用于使用一个键快速搜索一个元素的高效数据结构。

`java.util.Collection` 接口是存储对象合集的根接口

*java.util.Collection.java*

```java
add(o: E): boolean				// 添加一个新的元素 o 到合集中
addAll(c: Collection<? extends E>): boolean    // 将合集 c 中的所有元素添加到该合集中，并集
clear(): void			// 从该合集删除所有元素
contains(o: Object)		// 如果该合集包含元素 o, 则返回 true
containsAll(c: Collection<?>): boolean		// 如果该合集包含 c 中所有的元素，则返回 true
equals(o: Object): boolean			// 如果该合集等同于另外一个合集 o,则返回 true
hashCode(): int			// 返回该合集的哈希码
isEmpty(): boolean		// 如果该合集没有包含元素，则返回 true
remove(o: Object): boolean	// 从该合集中移除元素 o
removeAll(c: Collection<?>): boolean		// 从该合集中移除 c 中的所有元素， 差集
retainAll(c: Collction<?>): boolean			// 保留同时位于 c 和该合集中的元素，交集
size(): int			// 返回该合集中的元素数目
toArray()： Object[]		// 为该合集中的元素返回一个 Object 数组
iterator(): Iterator<E>		// 为该集合中的元素返回一个迭代器
```

* 迭代器：每种合集都是可迭代的。可以获得集合中的 iterator 对象来遍历合集中的所有元素

java.lang.Iterator.java*

```java
hasNext(): boolean			// 如果该迭代器还有下一个元素，则返回 true
next(): E				// 返回该迭代器中的下一个元素
remove(): void			// 移除使用 next 方法获取的上一个元素
```

* 线性表：list 接口继承自 `Collection` 接口，定义了一个允许重复用于顺序存储元素的合集。可以使用它的两个具体类数组线性表 `ArrayList` 或者链表 `LinkedList` 来创建一个线性表 `list`

*java.util.List.java*

```java
add(index: int, element: Object): boolean	// 在指定索引位置处增加一个新元素
addAll(index: int, c: Collection<? extends E>): boolean 	// 在指定索引位置处添加 c 中的所有元素
get(index: int): E   	// 返回该线性表指定索引位置处的元素
indexOf(element: Object): int 		// 返回第一个匹配元素的索引
lastIndexOf(element: Object): int		// 返回最后一个匹配元素的索引
listIterator(): ListIterator<E>			// 返回针对该线性表元素的迭代器
listIterator(startIndex: int): ListIterator<E>		// 返回针对从 startIndex 开始的元素的迭代器
remove(index: int): E			// 移除指定索引位置处的元素
set(index: int, element: Object): Object 	// 设置指定索引处的元素
subList(fromIndex: int, toIndex: int): List<E>		// 返回从 fromIndex 到 toIndex-1 的子线性表
```

*java.util.ListIterator.java* 接口可以双向遍历线性表,继承 Iterator 接口

```java
/** 添加一个指定的对象到线性表中，如果 Iterator 接口中定义的 next() 方法的返回值非空，该元素将被插入**到 next() 方法返回的元素之前；如果 previous() 方法的返回值非空，该元素将被插入到 previous() 方法**返回的元素之后，如果线性表中没有元素，这个新元素即成为线性表中唯一的元素
**/
add(element: E): void
add(element: E): void
hasPrevious(): boolean		// 当往回遍历时，如果该线性表遍历器还有更多的元素，则返回 true
nextIndex(): int			// 返回下一个元素的索引
previous(): E			// 返回该线性表遍历器的前一个元素
previousIndex(): int		// 返回前一个元素的索引
set(element: E): void		// 使用指定的元素替换 previous 或者 next 方法返回的最后一个元素
```

*java.util.AbstractSequentialList.java*

```java
LinkedList() 		// 创建一个默认的空线性表
LinkedList(c: Collection<? extends E>)		// 从已经存在的合集中创建一个线性表
addFirst(element: E): void			// 添加元素到该线性表的头部
addLast(element: E): void			// 添加元素到该线性表的尾部
getFirst(): E						// 返回该线性表的第一个元素
getLast(): E						// 返回该线性表的最后一个元素
removeFirst(): E					// 从该线性表中返回并删除第一个元素
removeLast(): E						// 从该线性表中返回并删除最后一个元素
```

* `Comparator` 比较器接口，用于比较没有实现 `Comparable ` 的类的对象

  ```Java
  public int compare(T element1, I element2)    // 如果 element1 小于 element2，就返回一个负值；如果 element1 大于 element2 就返回一个正值；如果两者相等返回 0
  ```

* `Collections` 类包含了执行合集和线性表中通用操作的静态方法

  *java.util.Collections.java*

  ```Java
  sort(list: List): void				// 对指定的线性表进行排序
  sort(list: List, c: Comparator): void			// 使用比较器对指定的线性表进行排序
  binarySearch(list: List, key: Object): int		// 采用二分查找来找到排序的线性表中的键值
  binarySearch(list: List, key: Object, c: Comparator): int 	// 使用比较器，采用二分查找来找到排好序的线性表中的键值
  reverse(list: List): void		// 对指定的线性表进行逆序排序
  reverseOrder(): Comparator		// 返回一个逆序排序的比较器
  shuffle（list: List): void		// 随机打乱指定的线性表
  shuffle（list: List, rmd: Random): void		// 使用一个随机对象打乱指定的线性表
  copy(des: List, src: List): void			// 复制源线性表到目标线性表
  nCopies(n: int, o: Object): List		// 返回一个由 n 个对象副本组成的线性表
  fill(list: List, o: Object): void		// 返回对象填充线性表
  max(c: Collection): Object		// 返回合集中的 max 对象
  max(c: Collection, c: Comparator): Object	// 返回比较器返回 max 对象
  min(c: Collection): Object	// 返回合集中的 min 对象
  min(c: Collection, c: Comparator): Object	// 返回比较器返回 min 对象
  disjoint(c1: Collection c2: Collection): boolean	// 如果 c1 和 c2 没有共同的元素，则返回真
  frequency(c: Collection, o: Object): int	// 返回合集中指定元素的出现次数
  ```

* 栈类 `Stack` 扩展 `Vector` 类，提供后进先出的数据结构

  ```Java
  Stack()				// 创建一个空的栈
  empty(): boolean		// 如果栈是空的，则返回真
  peek(): E		// 返回栈中的顶部元素
  pop(): E		// 返回并移除该栈中的顶部元素
  push(o: E): E	// 增加一个新的元素到栈的顶部
  search(o: Object): int		// 返回该栈中指定元素的位置
  ```

* 队列和优先队列：队列先进先出，元素被追加到队列末尾，然后从队列头删除，在优先队列中，元素被赋予优先级，当访问元素时，拥有最高优先级的元素首先被删除

  *java.util.Queue.java*

  ```Java
  offer(element: E): boolean		// 插入一个元素到队列中
  poll(): E			// 获取并且移除队列的头元素，如果队列为空则返回 null
  remove(): E 	// 获取并移除队列头元素，如果队列为空则抛出异常
  peek(): E 	// 获取但不移除队列的头元素，如果队列为空则返回 null
  element(): E		// 获取但不移除队列头元素，如果队列为空则抛出异常
  ```

  *java.util.Deque.java* 双向队列

  ```Java
  addFirs(e)		// 队列头插入数据
  addLast(e)		// 队列未插入数据
  removeFist()		// 队列头移除数据
  removeLast()		// 队列未移除数据
  getFirst()			// 获取队列头数据
  getLast()		// 获取队列未数据
  ```

### 集合

__集合 （set）是一个用于存储和处理无重复元素的高效数据结构，可以使用集合的三个具体类 `HashSet`, `LinkedHashSet`, `TreeSet` 来创建集合__

*java.util.HashSet.java* 类是一个实现了 `Set` 接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的合集创建散列集。默认情况下，初始容量为16而负载系数是0.75，当元素个数超过了容量与负载系数的积，容量就会自动翻倍

*java.util.LinkedHashSet.java* 用一个链表实现来扩展 `HashSet` 类，它支持对集合内的元素排序，`HashSet` 中的元素是没有被排序的，`LinkedHashSet` 中的元素可以按照它们插入集合的顺序提取。

`SortedSet` 是 set 的一个子接口，它可以确保集合中的元素是有序的。另外，它还提供方法 `first()` 和 `last()` 以返回集合中的第一个元素和最后一个元素，`headSet(toElement)` 返回小于 `toElement` , `tailSet(fromElement)` 返回大于或等于 `fromElement` 的部分

`NavigableSet` 扩展 `SortedSet` 接口，方法 `lower(e)` 小于，`floor(e)` 小于或等于，`ceiling(e)` 大于或等于，`higher(e)` 大于一个给定元素的的元素。如果未找到则返回 null。`pollFirst()` ，`pollLast()`删除和返回第一个，最后一个元素

`TreeSet` 实现了 `SortedSet` 接口，只要对象是可互相比较的（Comparable 或 Comparator 接口），就可以将它们添加到一个树形集。

### 映射表：`HashMap`, `LinkedHashMap`, `TreeMap`

#### 映射表是一种依照键/值存储元素的容器。它提供了通过键快速获取，删除和更新键/值对的功能。映射表将值和键一起保存。键可以是任意类型的对象，映射表中不能有重复的键，每个键对应一个镇。一个键和它对应的值构成一个条目并保存在映射表中。

*java.util..Map.java*

```Java
clear(): void		// 从该映射表中删除所有条目
containsKey(key: Object)：Boolean	// 如果该映射表包含了指定键的条目，则返回true
containsValue(value: Object): boolean	// 如果该映射表将一个或者多个键映射到指定值，则返回true
entrySet(): Set<Map.Entry<K,V>>		// 返回一个包含了该映射表中条目的集合
get(key: Object): V			// 返回该映射表中指定键对应的值
isEmpty(): boolean				// 如果该映射表中没有包含任何条目，则返回 true
keySet(): Set<K>			// 返回一个包含该映射表中所有键的集合
put(key: K, value: v): v			// 将一个条目放入该映射表中，如果原来就包含该键的一个条目，则原来的值将被新的值取代，并且返回与这个键相连的原来的值
putAll(m: Map<? extends K, ? extends V): void		// 将 m 中的所有条目添加到该映射表中
remove(key: Object): V		// 删除指定键对应的条目
size(): int					// 返回该映射表中条目数
values(): Collection<V>			// 返回该映射表中所有值组成的合集
```

*java.util.Map.Entry.java*

```java
getKey(): K					// 返回该条目的键
getValue(): V				// 返回该条目的值
setValue(value: v): void		// 将该条目的值赋以新的值
```

* 对于定位一个值，插入一个条目以及删除一个条目而言，`HashMap` 类是高效的，如果更新映射表时不需要保持映射表中元素的顺序，使用 `HashMap`,如果需要保持映射表中元素的插入顺序或访问顺序，使用 `LinkedHashMap`,如果需要使映射表按照键排序，使用 `TreeMap`

* `LinkedHashMap` 类用链表实现来扩展 `HashMap` 类，它支持映射表中条目的排序，`HashMap` 类中的条目是没有顺序的，但在 `LinkedHashMap` 中，元素既可以按照它们插入映射表的顺序排序，也可以按照它们被最后一个访问时的顺序（从最早到最晚）的访问顺序排序。无参构造方法时以插入顺序来创建 `LinkedHashMap` 对象的，`LinkedHashMap(initialCapacity, loadFactor, true)` 传教顺序访问对象

* `TreeMap` 类在遍历排好顺序的键时很高效，键可以使用 `Comparable` 接口或 `Comparator` 接口来排序。如果使用它的无参构造方法创建一个 `TreeMap` 对象，假定键的类实现了 `Comparable` 接口，则可以使用 `Comparable` 接口中 `CompareTo` 方法来对映射表内的键进行比较。要使用比较器，必须使用构造方法 `TreeMap(Comparator comparator)` 来创建一个有序映射表，这样，该映射表中的条目就能使用比较器中的 `compare` 方法按键进行排序

* `SortedMap` 是 `Map` 的一个子接口，使用它可确保映射表中的条目是排好序的。

  ```Java
  firstKey()		// 返回第一个 key
  lastKey()			// 返回最后一个 key
  headMap(toKey)			// 小于键 tokey 的那部分映射表
  fromKey(tokey)			// 键大于或等于 tokey 的那部分映射表
  ```

* `NavigableMap` 继承了 `SortedMap` 

  ```java
  lowerKey(key)					// 小于给定key的key,没有则返回 null
  floorKey(key)					// 小于等于
  ceilingKey(key)					// 大于等于
  higherKey(key)					// 大于
  ```

* `Hashtable` 更新方法是同步的，与 `HashMap` 的用法是一样的

### 单元素与不可变的合集和映射表，可以使用 `Collections` 类中的静态方法来创建单元素的集合，线性表和映射表，以及不可变集合，线性表和映射表

```java
singleton(o: Object): Set	// 返回一个包含了指定对象的不可修改的集合
singletonList(o: Object): List	// 返回一个包含了指定对象的不可修改的线性表
singletonMap(key: Objectm value: Object):Map 	// 返回一个具有键值对的不可修改的映射表
// 视图类似真正合集的引用，不能通过它来修改合集
unmodifiableCollection(c: Collection): Collection	// 返回一个合集的只读视图
unmodifiableList(list: List): List			// 返回一个线性表的只读视图
unmodifiableMap(m: Map): Map				// 返回一个映射表的只读视图
unmodifiableSet(s: Set): Set				// 返回一个集合的只读视图
unmodifiableSortedMap(s: SortedMap): SortedMap		// 返回一个排好序的映射表的只读视图
unmodifiableSortedSet(s: SortedSet): SortedSet		// 返回一个排好序的集合的只读视图
EMPTY_SET // 常量空集合
EMPTY_LIST		// 常量空线性表
EMPTY_MAP			// 常量空映射表
```

### 线性表

__线下表的通用特性在 list 接口中定义, 线性表时一个顺序存储数据的数据结构,线性表支持的操作包括,实现线性表的方式有两种.一种是使用数组存储线性表的元素,数组大小是固定的,如果元素个数超过了数组的容量,就创建一个更大的新数组,并将当前数组中的元素复制到新数组,一种是使用链式结构,链式结构由节点组成,每个结点都是动态创建的,用来存储一个元素,所有的结点链接成一个线性表__

* 从线性表中提取一个元素
* 向线性表中插入一个新元素
* 从线性表中删除一个元素
* 找出线性表中元素的个数
* 确定线性表中是否包含某个元素
* 确定线性表是否为空

链表中的每个元素都包含一个节点的结构,当向链表中加入一个新的元素时,就会产生一个包含它的节点,每个节点都和它的相邻节点相链接