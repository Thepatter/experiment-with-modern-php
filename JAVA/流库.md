## Java SE 8 的流操作相关

### 流概述

流提供了一种比集合更高的概念级别上指定计算的数据视图。用来以“做什么而非怎么做”的方式处理集合

流与集合很类似，都可以让我们转换和获取数据，它们之间的差异为

1.流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的

2.流的操作不会修改其数据源。（`filter` 方法不会从新的流中移出元素，而是会生成一个新的流，其中不包含被过滤掉的元素）

3.流的操作是尽可能惰性执行。即：直至需要其结果时，操作才会执行。

```java
long count = words.parallelStream()
                .filter(w -> w.length() > 12)
                .count();
```

上述示例中，`stream` 和 `parallelStream` 方法会产生一个用于 `words` 列表的 `stream` 。`filter` 方法会返回另一个流，其中只包含长度大于 12 的单词。`count` 方法会将这个流简化为一个结果。这个工作流是操作流时的典型流程。建立了一个包含三个阶段的操作管道

1.创建一个流

2.指定将初始流转换为其他流的中间操作，可能包含多个步骤

3.应用终止操作，从而产生结果。这个操作会强制执行之前的惰性操作。从此之后，这个流就再也不能用了

### 流的创建

* `Collection` 接口的 `stream` 方法将任何集合转换为一个流

* `Stream.of` 的静态方法可以从数组创建一个流， `of` 方法具有可变长参数，可以构建具有任意数量引元的流

* `Array.stream(array, from, to)` 可以从数组中位于 `from`(包括) 和 `to` (不包括) 的元素中创建一个流

* `Stream.empty()` 方法创建不包含任何元素的流

* `Stream` 接口有两个用于创建无限流的静态方法：`generate()`，`iterate()` 方法

    `generate()` 方法会接受一个不包含任何引元的函数（是一个 `Supplier<T>` 接口的对象）。只要需要一个流类型的值，该函数就会被调用以产生一个这样的值。

    ```java
    Stream<String> echos = Stream.generate(()-> "Echo");
    // 获取一个随机数的流
    Stream<Double> randoms = Stream.generate(Math::random);
    ```

    `iterate()` 方法可以产生无限序列，会接受一个“种子”值，以及一个函数（是一个 `UnaryOperation<T>`），并且会反复地将函数应用到之前的结果上。

    ```java
    // 该序列中的第一个元素是种子BigInteger.ZERO，第二个元素是 f(seed),即 1（作为大整数），下一个元素是 f(f(seed)) 即 2，后续以此类推
    Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO, n->n.add(BigInteger.ONE));
    ```

* `Pattern` 类的 `splitAsStream()` 方法，它会按照某个正则表达式来分割一个 `CharSequence` 对象

  ```java
  Stream<String> words = Pattern.compile("\\PL+").splitAsStream(contents);
  ```

* 静态的 `Files.lines()` 方法会返回一个包含了文件中所有行的 `Stream`

  ```java
  try (Stream<String> lines = Files.lines(path))
  {
      
  }
  ```

### 抽取子流和连接流

* 调用 `stream.limit(n)` 会返回一个新的流，它在 n 个元素之后结束（如果原来的流更短，那么就会在流结束时结束）。这个方法对于裁剪无限流的尺寸会显得特别有用。

```java
// 生成一个包含 100 个随机数的流
Stream<Double> randoms = Stream.generate(Math::random).limit(100);
```

* 调用 `stream.skip(n)` 会丢弃前 n 个元素。这个方法在文本分隔为单词时会显得很方便

*  `Stream` 类的静态的 `concat` 方法将两个流连接起来：

```java
Stream<String> combined = Stream.concat(letters("Hello"), letters("World"));
```

当然第一个流不应该是无限的，否则第二个流永远都不会得到处理的机会

### 其他流转换

*  `distinct` 方法会返回一个流，它的元素是从原有流中产生的，即原来的元素按照同样的顺序剔除重复元素后产生的。

* 对于流的排序，有多种 `sorted` 方法的变体可用。其中一种用于操作 `Comparable` 元素的流，而另一个可以接受一个 `Comparator` ，与所有的流转换一样，`sorted` 方法会产生一个新的流，它的元素是原有流中按照顺序排列的元素

  ```java
  // 字符串排序，使得最长的字符串排在最前面
  Stream<String> longestFirst = words.stream().sorted(Comparator.comparing(String::length).reversed());
  ```

* `peek()` 方法会产生另一个流，它的元素与原来流中的元素相同，但是在每次获取一个元素时，都会调用一个函数。

  ```java
  Object[] powers = Stream.iterate(1.0, p -> p * 2).peek(e -> System.out.println("Fetching " + e)).limit(20).toArray();
  ```

### 从流中获得结果

​	将流约简为可以在程序中使用的非流值。

* `count()` 方法会返回流中元素的数量

* `max()` 和 `min()` 会返回最大值和最小值。这些方法返回的是一个类型 `Optional<T>` 的值，它要么在其中包装了答案，要么表示没有任何值（因为流碰巧为空）。在过去，碰到这种情况返回 `null` 是很常见的，但是这样会导致在未做完备测试的程序中产生空指针异常。`Optional` 类型是一种更好的表示缺少值的方式

  ```java
  // 获取流中的最大值
  Optional<String> largest = words.max(String::compareToIgnoreCase);
  ```

* `findFirst()` 返回的是非空集合中的第一个值。它通常会在与 `filter()` 组合使用时显得很有用。

  ```java
  // 查找第一个以字母 Q 开头的单词
  Optional<String> startsWithQ = words.filter(s -> s.startsWith("Q")).findFirst();
  ```

* `findAny()` 方法返回任意一个它找到的匹配，在并行处理流时会很有效

  ```java
  Optional<String> startWithQ = words.filter(s -> s.startsWith("Q")).findFirst();
  ```

* 如果只想知道是否存在匹配，使用 `anyMatch` 。这个方法会接受一个断言引元，因此不需要使用 `filter`

  ```java
  boolean aWordStartsWithQ = words.parallel().anyMatch(S -> s.startsWith("Q")).findAny();
  ```

* `allMatch()` 和 `noneMatch` 方法，分别会在所有元素和没有任何元素匹配断言的情况下返回 true。这些方法也可以通过并行运行而获益

### Optional 类型

​	`Optional<T>` 对象是一种包装器对象，要么包装了类型 T 的对象，要么没有包装任何对象。对第一种情况，即值为存在的。`Optional<T>` 类型被当作一种更安全的方式，用来替代类型 T 的引用，这种引用要么引用某个对象，要么为 `null`。但是，它只有在正确使用的情况下才会更安全

​	有效使用 `Optional` 的关键字是要使用这样的方法：

* 它在值不存在的情况下会产生一个可替代物，而只有在值存在的情况下才会使用这个值

```java
// 在没有匹配时，使用某种默认值
String result = optionalString.orElse("");
// 计算默认值
String result = optionalString.orElseGet(()->Locale.getDefault().getDisplayName());
// 在没有任何值时抛出异常
String result = optionalString.orElseThrow(IllegalStateException::new);
```

* 调用 `ifPresent` 方法会接受一个函数。如果该可选值存在，那么它会被传递给该函数。否则，不会发生任何事情

  ```java
  optionalValue.ifPresent(V->Process V);
  // 如果在该值存在的情况下想要将其添加到某个集中，调用
  optionalValue.ifPresent(V->results.add(V))
  // 上面等价于
  optionalValue.ifPresent(results::add);
  ```

  当调用 `ifPresent` 时，从该函数不会返回任何值。如果想要处理函数的结果，应该使用 `map()`

  ```java
  Optional<Boolean> added = optionalValue.map(results::add);
  ```

  如果没有正确地使用 `Optional` 值，那么相比较以往得到“某物或null”的方式，并没有得到任何好处。

  `get()` 方法会在 `Optional` 值存在的情况下获得其中包装的元素，或者在不存在的情况下抛出一个 `NoSuchElementException` 对象。

  ```java
  Optional<T> optionalValue = ...;
  optionalValue.get().someMethod();
  // 并不比下面的方式更安全
  T value = ...;
  values.someMethod();
  ```

  `isPresent()` 方法会报告某个 `Optional<T>` 对象是否具有一个值。但是 

  ```java
  if (optionalValue.isPresent()) {
      optionValue.get().someMethod();
  }
  // 并不比下面的方式更容易处理
  if (value != null) {
      value.someMethod();
  }
  ```








