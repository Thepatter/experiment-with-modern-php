## Java 集合框架

### Collection

在 Java 类库中，集合类的基本接口是 `Collection` 接口。

*集合框架中的接口*

![](./Images/集合接口.png)

*java库中的具体集合*

![](./Images/java库中的具体集合.png)

*java集合框架中的类*

![](./Images/集合框架中类.png)

### 链表

在 Java 程序设计语言中，所有链表实际上都是双向链接的（每个结点还存放着指向前驱结点的引用）

链表与泛型集合之间有一个重要的区别。链表是一个有序集合，每个对象的位置十分重要。`LinkedList.add` 方法将对象添加到链表的尾部。

如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的情况。e.g. 一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或者被该集合自身的方法修改了，就会抛出一个 `ConcurrentModificationException` 异常。为了避免发生并发修改的异常：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，在单独附加一个既能读又能写的迭代器。集合可以跟踪改写操作（诸如添加或删除元素）的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计算值是否与集合的改写操作计数值一致。如果不一致，抛出一个 `ConcurrentModificationException` 异常

### 散列表

散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生的一个整数。即：具有不同数据域的对象将产生不同的散列码。

在 Java 中，散列表用链表数组实现。每个列表称为桶。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。如果桶被占满，这种现象被称为散列冲突。这时需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少（在 Java SE 8 中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突）

如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 75% ~ 150%。最好将桶数设置为一个素数，以防键的集聚。标准库使用的桶数是 2 的幂，默认值为 16 （为表大小提供的任何值都将被自动地转换为 2 的下一个幂）

如果散列表太满，就需要再散列。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子决定何时对散列表进行再散列。默认值为 0.75

散列表可以用于实现几个重要的数据结构。其中最简单的是 `set` 类型。`set` 是没有重复元素的元素集合。`set` 的 `add` 方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。Java 集合类提供的 `HashSet` 类，它实现了基于散列表的集。`contains` 方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素

