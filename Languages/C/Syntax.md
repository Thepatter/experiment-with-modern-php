### 语言

#### 语法

C99/C11 可以在块中任何位置声明变量，之前只能在块的顶部声明。C99/C11 允许使用更长的标识符名，编译器只识别前 63 个字符（如果两个标识符名都是 64 个字符，只有最后一个字符不同，那么编译器可能将其视为同一个名称，也可能不会，其行为是未定义的）。对外部标识符，只允许使用 31 个字符。C90 只允许 6 个字符

*关键字*

|   auto   |    extern     |  short   |     while      |  break   |   float   |
| :------: | :-----------: | :------: | :------------: | :------: | :-------: |
|  signed  |   _Alignas    |   case   |      for       |  sizeof  | _Alignof  |
|   char   |     goto      |  static  |    _Atomic     |  const   |    if     |
|  struct  |     _Bool     | continue |     inline     |  switch  | _Complex  |
| default  |      int      | typedef  |    _Generic    |    do    |   long    |
|  union   |  _Imaginary   |  double  |    register    | unsigned | _Noreturn |
|   else   |   restrict    |   void   | _Static_assert |   enum   |  return   |
| volatile | _Thread_local |          |                |          |           |

变量作用域包含块（一对花括号之间声明的变量，C99 允许在块中任意位置声明变量，C99 把块的概念扩展到 for、while、do while、if）、函数（仅用于 goto 语句的标签，即使一个标签首次出现在函数的内层块中，它的作用域也延伸到整个函数）、函数原型（用于函数原型中形参名，在变长数组中形参名才有用）、文件（定义在函数外，从它的定义处到所在文件的末尾均可见）。

变量有 3 种连结属性：外部链接（可以在多文件程序中使用）、内部链接（只能在一个翻译单元中使用）、无链接（块作用域、函数作用域、函数，这些变量属于它们的块、函数、原型私有）。具有文件作用域的变量可以是外部链接或内部链接。

##### 运算符

除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值。对于逻辑运算符，C 保证逻辑表达式的求值顺序是从左往右。&& 和 || 运算符都是序列点，程序在从一个运算符对象执行到下一个运算符对象之前，所有的副作用都会生效，一旦发现某个元素让整个表达式无效，便立即停止求值。

###### typedef

允许为现有类型创建别名

```c
typedef double real;
```

###### sizeof/size_t

sizeof 运算符以字节为单位返回运算对象的大小，返回 size_t 类型的值，这是一个无符号整型。size_t 是语言定义标准类型。

##### 数据类型

基本数据类型 `int`、`long`、`short`、`unsigned`、`char`、`float`、`double`、`signed`、`_Bool`、`_Complex`、`_Imaginary` 可以使用 `sizeof`（以字节为单位给出指定类型的大小）来获取基本类型占用字节数。当浮点类型被降级为整数类型时，原来的浮点值会被截断。许多类型转换都是自动进行的。当 char/short 出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为 int 类型；float 类型在函数参数中时，会被升级为 double 类型。

```c
# C99/C11 使用 %zd 转换 sizeof 返回类型，之前使用 %u/%lu 代替
printf("long double size %zd bytes\n", sizeof(long double)); // 16 bytes
```

###### 常量

C90 新增了 const 关键字，用于限定一个变量为只读。

```c
#define NAME value
```

编译程序时，程序中所有的常量会被替换成常量值，这样定义的常量被称为明示常量（manifest constant）

###### Int

ISO C 规定 `int` 的取值范围最小为 -32768～32767，即不小于 16 位，格式化时：%d 十进制显示数字，%o 八进制显示数字，%x 十六进制显示数字，显示前缀 0、0x、0X，使用 %#o、%#x、%#X。

C 语言提供了：short、long、unsigned 修饰整数，整数溢出行为是未定义的，可能会从该类型最小值开始重新计数

* short int 

  占用空间可能比 int 少，有符号，标准规定 short 占用存储空间不能多于 int，格式化时用 hd 无符号使用 hu

  ```c
  int main()
  {
      short b = -336;
    	// b: -336 format signed short: -336; unsigned short: 65200
      printf("b: -336 format signed short: %hd; unsigned short: %hu\n", b, b);
      unsigned short a = 65200;
      // a:65200 format signed short: -336; unsigned short: 65200
      printf("a:65200 format signed short: %hd; unsigned short: %hu\n", a, a);
  }
  ```

  上述转换结果原因：short 大小是 2 字节，系统使用二进制补码来表示有符号整数，这种方法数字 0～32767 代表它们本身，而数字 32768 ～ 65535 则表示负数。65535 表示 -1，65534 表示 -2。所以 -336 解释成无符号 short 时为 65200，65200 被解释成有符号 short 时为 -336

* long int

  占用空间可能比 int 多，有符号，标准规定 long 占用空间不能少于 int，至少占 32 位

* long long int

  C99 加入，占用空间可能比 long 多，至少占 64 位，有符号，格式化时使用 ll LL ull LLU ULL 表示

###### char

存储字符，实际存储的是整型，C 语言把 1 字节定义为 char 类型占用的位数。C 语言将字符常量视为 int 类型而非 char 类型。直接表示字符常量时，使用单引号将字符括起来，支持在八进制或十六进制前加一个反斜杠表示 ASCII 中的一个字符（`\007`）

```c
int main()
{
  	short num = 336;
    // num as int and char: 336 P
  	printf("num as int and char: %d %c\n", num, num);
}
```

使用 printf 函数 %c 打印 336 时，它只会查看存储 336 的 2 字节中的后 1 字节。336 二进制为 「00000001 01010000」，取后一个字节为「01010000」即十进制 80，对应 ASCII 码为「P」。计算方式为除 256 取余即取 256 模值转 ASCII 码。

打印 char 时，使用 %d 将打印一个整数值，使用 %c 将打印字符值。有些编译器将 char 实现为有符号类型，表示范围为 -128～127，有些编译器将 char 实现为无符号类型，表示范围是 0～255。C90 标准，允许使用 signed 或 unsigned 修饰 char。

*特殊字符*

| 字符 |   含义   |                           标准                            |
| :--: | :------: | :-------------------------------------------------------: |
| `\a` |   警报   |                     不得改变活跃位置                      |
| `\b` |   退格   |                       活跃位置退格                        |
| `\f` |   换页   |                  活跃位置移到下一页开始                   |
| `\n` |   换行   |                活跃位置移至下一行开始出处                 |
| `\r` |   回车   |                活跃位置移动到当前行开始处                 |
| `\t` | 水平制表 | 活跃位置移至下一个水平制表点（第1、9、17、25 等字符位置） |
| `\v` | 垂直制表 |               活跃位置移至下一个垂直制表点                |

* 活跃位置，显示设备中下一个字符将出现的位置，如光标。换页、垂直制表符在 PC 屏幕会产生奇怪的符号，光标并不会移动，只有将其输出到打印机才会有效果

* `\\`、`\'`、`\"` 用于打印，`\0oo`、`\xhh`

  ```c
  # 如果要用八进制 ASCII 码表示一个字符，可以在编码值前加一个反斜杠并用单引号括起来
  # 使用 '\x' 或 '\x0' 表示十六进制
  beep = '\007'; # 可以省略前面的 0，'\07', '\7' 编译器都能识别
  ```

* 无论是普通字符还是转义字符，只要是双引号括起来的字符集合（字符串），就无需用单引号括起来

###### _Bool

C99 标准添加了 _Bool 类型用于表示布尔值，true/false，使用 1 表示 true，0 表示 false，仅占用 1 位存储空间

###### float

浮点类型有 float、double、long double（C90 新增），double 和 float 类型最小取值范围相同，至少能表示 10 位有效数字。一般情况下 double 占用 64 位。C 只保证 long double 至少与 double 类型精度相同。默认情况下，编译器假定浮点型（没有后缀）常量是 double 类型的精度。f/F 后缀表示 float 类型。l/L 后缀为 long double 类型。

使用 %f 打印 float/double 浮点数。使用 %Lf、%Le、%La 打印 long double 。未在函数原型中显式说明参数类型的函数，传递参数时，编译器会把 float 类型的值自动转换成 double 类型

*   上溢（数字过大，超过当前类型表达范围）浮点数溢出时显示一个表示无穷大的特定值（inf/infinity）
*   下溢（损失了指数精度），C 语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。把最小的浮点数除 2 将一个一个低于正常的值，如果除非常大的值，会导致所有的位都为 0
*   NaN 特殊浮点值，部分函数结果返回该值（asin 函数传入大于 1 的参数）

C99 新增了用十六进制表示浮点常量，在十六进制数前加上十六进制前缀，用 p/P 代替 e/E，用 2 的幂代替 10 的幂，并非所有编译器都支持 C99 这一特性。打印十六进制浮点数，用 a/A 代替 e/E。

C 编译器把浮点数转换成整数时，直接丢弃小数部分。

```c
float planck = 6.53e-34;
double a = -1.56E+12;
double b = .8E-5;
double c = 0xa.1fp10; // 10364.0
```

###### `_Complex/_Imaginary`

C99 标准支持复数和虚数类型。C11 标准把整个复数软件包作为可选项。

C 语言复数类型：float _Complex（包含两个 float 类型的值，表示复数的实部和虚部）、double _Complex、long double _Complex

C 语言的虚数类型：float _Imaginary、double _Imaginary、long double _Imaginary

引入 complex.h 头文件，可用 complex 代替 _Complex，用 imaginary 代替 _Imaginary，用 l 代替 -1 的平方根

##### 复合类型

###### 数组

C 使用新的语法来初始化数组，不支持该语法可以加上关键字 static 解决

```c
// type 是数组中每个元素的数据类型，name 是数组的名，size 是数组元素个数 
type name [size];
int powers[8] = {1, 2, 3, 4, 5, 6, 7, 8};
const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31};
```

C99 新增了指定初始化器

```c
// C99 之前的指定初始化
int arr[6] = {0, 0, 0, 0, 0, 212};
// C99 之后，可以在初始化列表中使用待方括号的下标指明初始化的元素
int arr[6] = {[5] = 212};
```

数组名是数组首元素的地址。指针访问和数组访问两种方式等效。对数组名加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。递增它所指向类型的大小，以字节为单位

```c
dates + 2 == &dates[2]     // 相同的地址
*(dates + 2) == dates[2]   // 相同的值
ar[i] 和 *(ar + i) 等价
```

在使用数组为参数的函数中，只有在函数原型或函数定义头中，才可以用 int ar[] 代替 int *ar（两者都表示 ar 是一个指向 int 的指针，但 int ar[] 只能用于声明形参，因为数组名是数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，只有在这种情况下，C 才会将两者解释成一样）。

```c
// 以下四种原型等价
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
// 以下两种定义等价
int sum(int *ar, int n){}
int sum(int ar[], int n){}
// 使用双指针标示数组开始和结束
int SIZE = 4;
int[SIZE] arr = {1, 2, 3, 4};
int int_sum = sum(arr, arr + SIZE);
// 使用数组首地址和尾部地址
int sum(int * start, int * end)
{
  	int total = 0;
  	while (start < end) {
      	total += *start++; // 一元运算符 * 和 ++ 的优先级相同，结合律从右往左
    }
  	return total;
}
```

C 保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。但对该指针处值未做任何保证（即 arr + SIZE 有效，但 arr[SIZE] 无效）

要创建一个处理任意大小的二维数组的函数，必须把数组作为一维数组传递，然后让函数计算每行的开始处。C99 新增了变长数组，允许使用变量表示数组的维度。变长数组必须是自动存储。无论在函数声明还是作为函数形参声明，都不能使用 static 或 extern。而且，不能在声明中初始化它们。C11 把变长数组作为一个可选特性。变长数组不能改变大小（不能修改已创建数组的大小，一旦创建了变长数组，它的大小则保持不变。变指的是，在创建数组时，可以使用变量指定数组的维度）变长数组名实际是一个指针。

```c
int quarters = 4;
int regions = 5;
double sales[regions][quarters]; // 变长数组，创建数组时，使用变量指定数组的维度
// 前两个形参用作第3个形参二维数组的两个维度，ar 声明要使用 rows，cols，在形参列表中必须在声明 ar 之前先声明这两个形参
int sum2d(int rows, int cols, int ar[rows][cols]);
// 实参声明变长数组，但不能使用声明并赋值的语法
int rs = 3; 
int cs = 2;
int i = 0;
int j = 0;
int var_arr_success[rs][cs]; // 正确，先声明编程数组，再为数组赋值
for (i = 0; i < rs; ++i) {
  for (j = 0; j < cs; ++j) {
    var_arr_success[i][j] = i * j + j;
  }
}
int var_arr_error[rs][cs] = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}; // 错误
// C99/C11 标准规定，可以省略原型中的形参名
int sum2d(int, int int ar[*][*]);
// 无效的顺序
int sum2d(int ar[rows][cols], int rows, int cols);
```

声明数组时使用 const 变量可能会无法移植。C90 标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合。由于 C 实现可以扩大整型常量表达式的范围，所以可能会允许使用 const，但这种代码可能无法移植

C99/C11 标准允许在声明变长数组时使用 const 变量。所以该数组的定义必须是声明在块中的自动存储类别数组。变长数组还允许动态内存分配，可以在程序运行时指定数组的大小。普通 C 数组都是静态内存分配，即在编译时确定数组大小。由于数组大小是常量，所以编译器在编译时就知道了

对于传统 C 数组，必须用常量表达式指明数组大小，数组大小在编译时就确定。C99/C11 支持的变长数组，可以用变量表示数组大小，变长数组的大小延迟到程序运行时才确定

```
const int SZ = 89;
double ar[SZ];
```

C99 新增了复合字面量（除符号常量外的常量）对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。复合字面量的类型名也代表首元素的地址。可以将它赋给指针后使用，可以将复合字面量作为实际参数传递给匹配形参的函数（把信息传入函数前不必先创建数组）复合字面量是提供只临时需要值的一种方法，具有块作用域。一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在

```c
// 普通数组声明
int diva[2] = {10, 20};
// 复合字面量（创建了和 diva 相同的匿名数组）
(int [2]){10, 20}
// 初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器自动计数数组当前的元素个数
(int []){59, 29, 89}
// 复合字面量是匿名{的，必须在创建的同时使用，使用指针记录地址
int *pt1;
pt1 = (int [2]){10, 20};
```

###### 字符串

C 语言没有专门用于存储字符串的变量类型，字符串都被存储在 char 类型的数组中。使用 `\0` 字符（不可打印字符）来标记字符串的结束。ANSI C 引入字符串连接，在两个双引号括起来的字符串之间用空白隔开，C 编译器会把多个字符串看作是一个字符串。

使用 sizeof 计算字符串字符数时会包含末尾不可见的空字符。sizeof 函数运算对象是类型时要使用圆括号，对于特定量可以省略圆括号

printf/scanf 输出输入时不用换行，刷新缓冲后会自动换行

*转换说明*

| 占位符 |                             说明                             |
| :----: | :----------------------------------------------------------: |
| %a/%A  |           浮点数、十六进制数和 p 记数法（C99/C11）           |
|   %c   |                           单个字符                           |
| %d/%i  |                       有符号十进制整数                       |
| %e/%E  |                       浮点数、e 记数法                       |
|   %f   |                     浮点数、十进制计数法                     |
| %g/%G  | 根据值自动选择 %f/%e（%e 格式用于指数小于 -4 或大于等于精度时） |
|   %o   |                       无符号八进制整数                       |
|   %p   |                             指针                             |
|   %s   | 字符串（指定宽度左对齐使用 `%-30s`，默认右对齐，精度限制打印个数） |
|   %u   |                       无符号十进制整数                       |
| %x/%X  |           无符号十六进制整数，使用十六进制数 Of/OF           |
|   %%   |                            百分号                            |

* printf()

  如果 printf() 语句有其他不匹配的地方，即使忽略警告的转换也会生成错误的结果（可能会截断或读取错误的字节）。函数执行时：1. 程序把传入的值放入栈中，根据变量类型（不是根据转换说明）把这些值放入栈中。2.控制转到 printf 函数，该函数根据转换说明（不是根据变量类型）从栈中读取值。

  该函数返回*打印字符*的个数，如果有输出错误，返回一个负数。格式化字符串中不能通过 Enter/Return换行。

  修饰符

  | 修饰符 |                             含义                             |
  | :----: | :----------------------------------------------------------: |
  |  数字  | 最小字段宽度，如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段（%4d） |
  | .数字  | 精度，%e/%E/%f，表示小数点右边数字的位数；%g/%G 表示有效数组最大位数；%s 转换，表示待打印字符的最大数量；对于整型，表示打印数字最小位数；只使用 . 表示其后跟随一个 0，%.f 和 %.0f 相同 |
  |   h    | 和整型转换说明一起使用，表示 short int/unsigned short int：%hu、%hx、%6.4hd |
  |   hh   | 和整型转换说明一起使用，表示 signed char/unsigned char 类型值：%hhu、%hhx、%6.4hd |
  |   j    | 和整型转换一起使用，表示 intmax_t/uintmax_t 类型的值：%jd、%8jx |
  |   l    | 和整型转换一起使用，表示 long int/unsigned long int 类型值：%ld、%81u |
  |   ll   | 和整型转换一起使用，表示 long long int/unsigned long long int 类型值：%11d、%10.4Le |
  |   L    |      和浮点转换一起使用，表示 long double：%Lf、%10.4Le      |
  |   t    | 和整数转换说明一起使用，表示 ptrdiff_t 类型值（两个指针差值的类型 C99），%td、%12ti |
  |   z    | 和整型转换一起使用，表示 size_t 类型（sizeof 返回的类型 C99）的值，%zd、%12zd |

* scanf()

  可以读取不同格式的数据。scanf 把输入的字符串转换成整数、浮点数、字符、字符串。与 printf 类似，使用格式字符串和参数列表。区别在与 printf 函数使用变量、常量、表达式，而 scanf 函数使用指向变量的指针（如果读取基本类型的值，使用指针操作符 &，读取字符串到字符数组中，不必使用指针操作符）

  scanf 使用空白（换行符、制表符、空格）把输入分成多个字段，在依次把转换说明和字段匹配时跳过空白（对于 %c 时例外）

  返回成功读取的项数，如果没有读取任何项或格式化项错误，返回 0，读到文件末尾时，返回 EOF

  ```c
  // 从输入中第一个字符开始读取
  scanf("%c", &ch);
  // 从第一个非空白字符开始读取
  scanf(" %c", &ch);
  // 用户必须输入 , 可在逗号前后包含任意个空格：88，121 88 ,123 88, 112
  scanf("%d,%d", &n, &m);
  ```

  *转换说明*

  |    转换说明    |                          含义                          |
  | :------------: | :----------------------------------------------------: |
  |       %c       |                    把输入解释成字符                    |
  |       %d       |              把输入解释成有符号十进制整数              |
  | %e、%f、%g、%a |         把输入解释成浮点数（C99 标准新增 %a）          |
  | %E、%F、%G、%A |        把输入解释成浮点数哦（C99 标准新增 %A）         |
  |       %i       |              把输入解释成有符号十进制整数              |
  |       %o       |              把输入解释成有符号八进制整数              |
  |       %p       |                    把输入解释成指针                    |
  |       %s       | 把输入解释成字符串，从第一个非空白字符到下一个空白字符 |
  |       %u       |              把输入解释成无符号十进制整数              |
  |     %x、%X     |             把输入解释成有符号十六进制整数             |

  *修饰符*

  | 修饰符 |                             用途                             |
  | :----: | :----------------------------------------------------------: |
  |   *    |                         抑制赋值 %*d                         |
  |  数字  | 最大字段宽度，输入达到最大字段宽度处，或第一次遇到空白字符时停止 %10s |
  |   hh   | 修饰整数为 signed char 或 unsigned char 类型（C99）%hhd、%hhu |
  |   ll   | 把整数作为 long long 或 unsigned long long 类型读取（C99）%lld、%llu |
  |   h    |  %hd %hi/%ho %hx 对应值存储为 short int/unsigned short int   |
  |   l    | %ld %li 对应值存储为 long，%lo %lx %lu 对应值存储为 unsigned long |
  |   lf   | %le、%lf、%lg 对应值存储为 double，e、f、g 前 L 大写为 long double |
  |   j    | 在整型转换后时，表明使用 intmax_t 或 uintmax_t（C99）：%jd、%ju |
  |   z    | 在整型转换后时，表明使用 sizeof 的返回类型（C99）：%zd、%zo  |

###### 指针

指针值为内存地址的变量。声明指针变量时必须指定指针所指向变量的类型，不同的变量类型占用不同的存储空间。一些指针操作要求知道操作对象的大小。程序必须知道存储在指定地址上的数据类型

大部分系统内部，该地址由一个无符号整数表示，一些处理整数的操作不能用来处理指针。指针的值为它所指向对象的地址，地址的表示方式依赖于计算机内部硬件（PC，Macintosh）都是按字节编码，内存中的每个字节都按顺序编号。一个较大对象的地址（如 double）通常是该对象第一个字节的地址

```c
// * 和指针名之间的空格可有可无，通常在声明时使用空格，在解引用时省略空格
int * pi; // pi 是指向 int 类型变量的指针
char * pc;  // pc 是指向 char 类型变量的指针
float * pf, * pg;  // pf、pg 是指向 float 类型变量的指针
```

可以把地址赋给指针（数组名、带地址运算符 & 的变量名、另一个指针），地址应该和指针类型兼容。指针变量也有自己的地址和值。对指针而言，& 运算符给出指针本身的地址。**创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。在使用指针之前，必须先用已分配的地址初始化它**

* 地址运算符 &

  获取变量对应的地址

* 间接运算符 `*` 也称为解引用运算符（获取指针变量指向地址存储的值）即该指针所指向对象的值，千万不要解应用未初始化的指针

  ```c
  val = *ptr;
  # val = bah; 等于以下语句
  ptr = &bah;
  var = *ptr;
  # 间接运算符优先级高于 +，*dates+2 相当于 (*dates)+2
  *(dates + 2) // dates 第三个元素的值
  *dates + 2 // 第一个元素的值加 2 
  ```

指针之间的赋值比数值类型之间的赋值要严格（不用类型转换就可以将较小范围的值赋值给较大范围的值，但两个类型的指针不能这样操作）

指针操作

* 指针与整数相加

  可以用 + 运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。如果相加的结果超出了指针指向数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C 保证指针有效

* 指针减去一个整数

  数组指针必须是第 1 个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。如果相减的结果超出初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C 保证该指针有效

* 递增指针

  递增指向数组元素的指针可以让该指针移动至数组的下一个元素。在 C 中，指针加 1 指的是增加一个存储单元

* 递减指针

* 指针求差

  可以计算两个指针的差值。通常求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。数组的两个指针所指向的两个元素的差为一个整数，意思这两个指针所指向的两个元素相隔两个 int。只有两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。

* 比较

  使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象

指针用途

对于基本类型，通常直接传值。只有程序需要在函数中改变该数值时，才会传递指针。对于数组必须传递指针。如果一个函数按值传递数组，必须分配足够的空间来存储原数组的副本，然后将原数组所有的数据拷贝至新数组。

如果函数不是修改数组中的数据内容，在函数原型和函数定义中声明型参时使用关键字 const（函数不能修改指针指向值，该函数在处理数组时将其视为常量，不可更改），把 const 数据或非 const 数据的地址初始化为指向 const 的指针或为其赋值是合法的，只能把非 const 数据的地址赋给普通指针，C 标准规定，使用非 const 标识符修改 const 数据导致的结果是未定义的。把 const 指针赋给非 const 指针不安全，这样可以使用新的指针改变 const 指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。把非 const 指针赋给 const 指针没问题，前提只进行一级解引用，超过一级则不安全

C 和 C++ 中 const 区别：C++ 允许在声明数组大小时使用 const 整数，而 C 不允许，C++ 的指针赋值检查更严格，C++ 不允许把 const 指针赋给非 const 指针

```c
const int y;
const int * p2 = &y;
int *p1;
p1 = p2; // c++ 不允许，c 可能给出警告
```

```C
double rates[5] = {99.1, 92,2, 93.3, 94.4, 95.5};
const double locked[4] = {0.08, 0.075, 0.72, 0.08}; // 有效，为 const 数据初始化赋值
const double *pc = rates;  // 有效，非 const 数据地址初始化为指向 const 的指针
double * pnc = rates; // 有效
pnc = locked; // 无效
pnc = &rate[3];  // 有效
// 声明一个不能指向别处的指针
double rate[5] = {88.99, 100.12, 59.45, 183.11, 340.55};
double * const pc = rates; // pc 指向数组开始且不会变
pc = &rate[2]; // 不允许
*pc = 92.99 // 允许，只改变了指针指向的值
const int **pp2; // 指向 int 型指针的指针，int 型指针的地址不容许修改
```

* 多维数组指针表示

  ```c
  // 数组名 zippo 是数组首元素的地址 zippo 的首元素是一个内含两个 int 值的数组，zippo 是这个内含两个 int 的数组地址，zippo 和 &zippo[0] 地址相同，zippo[0] 本身是一个内含两个整数的数组，zippo[0] 的值是它首元素地址(&zippo[0][0])相同。**zip 与 &zip[0][0] 等价
  int zip[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
  // zip 二维数组首元素的地址(每个元素都是内含两个 int 类型元素的一维数组)
  // zip+2 二维数组的第 3 个元素(即一维数组)的地址
  // *(zip+2) 二维数组的第 3 个元素(即一维数组)的首元素(一个 int 类型的值)地址
  // *(zip+2) + 1 二维数组的第 3 个元素(即一维数组)的第 2 个元素(也是一个 int 类型值) 地址
  // *(*(zip+2) + 1) 二维数组的第 3 个元素(即一维数组)的第 2 个 int 类型元素的值，即数组的 zip[2][1] = 3
  ```

  地址的地址或指针的指针就是双重间接。增加数组维数会增加指针的复杂度，最好使用数组表示法

* 指向多维数组的指针

  ```c
  // 指向一个内含两个 int 类型值的数组，[]的优先级高于 * 要使用括号
  int (* pz)[2]; 
  // pax 是一个内含两个指针元素的数组，每个元素都指向 int 的指针，[] 优先级高，先与 pax 结合，pax 成为内涵两个元素的数组，* 表示 pax 数组内含两个指针，int 表示 pax 数组中的指针都指向 int 类型的值
  int * pax[2];
  // 可用用数组或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名来访问数组
  int zip[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
  int (* pz)[2];
  pz = zip;
  printf("pz[2][1] = %d==*(*(pz+2)+1)=%d=3\n", pz[2][1], *(*(pz + 2) + 1));
  // 一般声明一个指向 N 维数组的指针时，只能省略最左边方括号中的值
  int sum3d(int ar[][12][23][3], int rows);
  // 等价
  int sum3d(int (*ar)[12][23][3], int rows);
  ```


* 指向函数的指针数组

* 函数间传递信息

  如果希望在被调函数中改变主调函数的变量，必须使用指针。

##### 函数

C90 标准新增了函数原型，即函数的声明，描述了函数的返回值和参数。在 ANSI C 之前，C 使用的是函数声明（指明了函数名和返回类型，没有指明参数类型）推荐将函数原型、常量、预处理语句定义在头文件中，编译多个文件时，将头文件放在依赖文件前面

#### 编译器

##### 编译流程

翻译单元：在源代码中包含一个或多个头文件，C 预处理器实际上是用包含的头文件替换 #include 指令。编译器源代码文件和所有的头文件都看成一个包含信息的单独文件。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。



在 C 语言中，编译器可以自行选择先对函数中那个参数求值。

*   如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
*   如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符

C 编译器提供了预定义标识符 `__func__` 在任意函数中获取函数字面量。

#### 库

##### 头文件

`#include` 是预处理指令（preprocessor directive，编译前对源码做的准备工作）。头文件包含了编译器创建最终可执行程序要用到的信息（常量、函数）

###### `limit.h`

|             明示常量              |                      含义                      |
| :-------------------------------: | :--------------------------------------------: |
|            `CHAR_BIT`             |                char 类型的位数                 |
|       `CHAR_MAX`/`CHAR_MIN`       |               char 类型最大/小值               |
|      `SCHAR_MAX`/`SCHAR_MIN`      |           signed char 类型最大/小值            |
|      `UCHAR_MAX`/`UCHAR_MIN`      |          unsigned char 类型最大/小值           |
|       `SHRT_MAX`/`SHRT_MIN`       |              short 类型最大/小值               |
|            `USHRT_MAX`            |             Unsigned short 最大值              |
|        `INT_MAX`/`INT_MIN`        |               Int 类型最大/小值                |
|            `UINT_MAX`             |              Unsigned int 最大值               |
|       `LONG_MAX`/`LONG_MIN`       |               Long 类型最大/小值               |
|            `ULONG_MAX`            |           Unsigned long 类型的最大值           |
|      `LLONG_MAX`/`LLONG_MIN`      |            Long long 类型最大/小值             |
|           `ULLONG_MAX`            |         imsigned Long long 类型最大值          |
|          `FLT_MANI_DIG`           |              float 类型的尾数位数              |
|             `FLT_DIG`             |     float 类型的最少有效数字位数（十进制）     |
| `FLT_MIN_10_EXP`/`FLT_MAX_10_EXP` |     float 类型最小负/正指数（以 10 为底）      |
|        `FLT_MIN`/`FLT_MAX`        |              float 类型的最大正数              |
|           `FLT_EPSILON`           | 1.00 和比 1.00 大的最小 float 类型值之间的差值 |

###### `stdint.h/inttypes.h`

C99 新增，为现有类型创建了更多类型名，新的类型名定义在 stdint.h 头文件中，编译器会将其替换为当前系统匹配的类型以确保移植性

|    类型     |                    用途                    |
| :---------: | :----------------------------------------: |
|  `int32_t`  |              32 位有符号整数               |
| `intmax_t`  |               最大有符号整型               |
| `uintmax_t` | 最大无符号整数，可能大于 usigned long long |

*   精确宽度类型（exact-width integer type）

    `int32_t` 表示整数类型的宽度正好是 32 位，精确宽度类型是可选项

*   最小宽度类型（minimum width type）

    `int_least8_t` 即可容纳 8 位有符号整数值的类型中宽度最小的类型的别名

*   最快最小宽度类型（fastst minimum width type）

    `int_fast8_t` 系统中对 8 位有符号值而言最快的整数类型的别名

inttypes.h 中提供了可移植字符串宏来显示可移植类型：

*   PRId32 字符串宏打印 32 位有符号值

    ```c
    int32_t me32 = 45933945;
    printf("me32 = %" PRId32 "\n", me32);
    ```

###### `stdio.h`

* putchar 只根据最后一个字节确定显示那个字符

  ```c
  putchar(ch);
  # 等价于
  printf("%c", ch);
  // 类似 printf，但将格式化数据写入 第一个参数声明的字符串中
  sprintf(char*, char*, ...);
  ```

*   getchar

    ```c
    int ch = getchar();
    # 等价于
    scanf("%c", &ch);
    ```

    `getchar()`/`putchar()` 只处理字符串，比通用的 scanf/printf 函数更快、更简洁，不需要转换说明，它们只处理字符。通常是预处理宏，而不是真正的函数。返回 int（因为处理 EOF 的情况，-1 用 char 无法表示）。读取每个字符、包括空格、制表符换行符（scanf 在读取数字时会跳过空格、制表符、换行符）

###### `ctype.h`

包含一系列专门处理字符函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类型，返回一个非零值，否则返回 0.

|   函数名   |                           测试是否                           |
| :--------: | :----------------------------------------------------------: |
| `isalnum`  |                    字母数字（字母或数字）                    |
| `isalpha`  |                             字母                             |
| `isblank`  | 标准的空白字符（空格、水平制表符、换行符）或任何其他本地化指定为空白的字符 |
| `iscntrl`  |                     控制字符，如 Ctrl+B                      |
| `isdigit`  |                             数字                             |
| `isgraph`  |                  除空格之外的任意可打印字符                  |
| `islower`  |                           小写字母                           |
| `isprint`  |                          可打印字符                          |
| `ispunct`  |     标点符号（除空格或字母数字字符以外的任何可打印字符）     |
| `isspace`  | 空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符、其他本地化字符） |
| `isupper`  |                           大写字母                           |
| `isxdigit` |                        十六进制数字符                        |
| `tolower`  |  如果参数是大写字符，该函数返回小写字符；否则，返回原始参数  |
| `toupper`  |  如果参数是小写字符，该函数返回大写字符；否则，返回原始参数  |

###### `iso646.h`

C99 标准新增了可代替逻辑运算符的拼写，定义在该头文件中。使用：

*   and 代替 `&&`
*   or 代替 `||`
*   not 代替 `!`

###### `string.h`

ASNI C 将字符串函数的原型定义在该头文件中。

```c
// 拼接字符串，将第二个字符串副本附加到第一个字符串末尾，将新字符串作为第一个字符串返回，第二个字符串不变，不会检查第一个数组是否能容纳第2个字符串，如果第一个数组空间不够，会造成溢出
strcat(char*, char*);
// 第三个参数指针最大添加字符数，遇到空字符串或 int 时停止追加
strncat(char*, char*, int);
// 比较字符串,相等返回 0, 字符串1小于字符串2返回大于0，否则返回小于0
strcmp(char*, char*);
// 指定比较字符数长度
strncmp(char*, char*, int);
// 拷贝字符串，第一个参数为目标位置，第二个参数为源字符串地址
strcpy(char*, char*);
// 指明最大可拷贝字符数
strncpy(char*, char*, int);
// 如果字符串包含字符，返回字符串首位置指针，未找到字符返回空指针
strchr(char*, int c);
// 如果字符串1包含字符串2中的任意字符，返回字符串1位置，都在返回空指针
stpbrk(char*, char*);
// 返回字符串1中字符2首次出现的位置
strstr(char*,char*);
// 返回字符串中字符串最后依次属性的位置
strrchr(char*, int);
// 返回字符串字符数，不包括末尾空字符
strlen(char*);
```

###### `stdlib.h`

```c
// 字母数字转换成整数, 起始位置指针，结束位置指针，进制
strtol(char*, char*, int);
```



#### IO

在底层 C 可以使用操作系统的文件 IO，在应用层上，C 可以使用标准 IO 包。

##### 标准 IO

ANSI C 把缓冲输入作为标准的（一些计算机不允许无缓冲输入）用 `setbuf` 和 `setvbuf` 函数控制缓冲。ANSI 没有提供调用无缓冲输入的标准方式（是否能进入无缓冲输入取决于操作系统）

标准 IO 定义了用于处理文件的标准模型和一套标准 I/O 函数。具体的 C 实现负责处理不同系统的差异。

*   IBM PC 兼容机编译器为支持无缓冲输入提供了一系列特殊的函数，原型在 `conio.h` 头文件中，这些函数包括用于回显无缓冲输入的 `getche()` 函数和用于无回显无缓冲输入的 getch() 函数
*   UNIX 使用 `ioctl()` 函数（属于 UNIX 库，但不属于 C 标准）指定待输入的类型，然后用 `getchar()` 执行相应的操作

###### 文件

概念上，C 程序处理的是流而不是直接处理文件（即不同属性和不同种类的输入，由属性更统一的流来表示）打开文件的过程就是把流与文件相关联，读写都是通过流来完成。

程序可以通过两种方式使用文件：显示使用函数打开文件、关闭文件、读取文件、写入文件；设计能与键盘和屏幕互动的程序，重定向输入至文件和从文件输出

*   文件结尾

    过m去操作系统使用内嵌的 Ctrl+Z 字符来标记文件结尾。现在文本文件不一定有嵌入的 Ctrl+Z，如果有，该操作系统会将其视为一个文件结尾标记。使用的另一bn种方法是存储文件大小的信息。如果文件有 3000 字节，程序在读到 3000 字节时便达到文件的末尾。键盘使用 `Ctrl+D` 模拟文件 EOF。

     在 C 语言中，用 `getchar()`/`scanf()` 读取文件检测到文件结尾时将返回一个特殊的值（`EOF` end-of-file），此时要用 int 而不是 char 来获取输入（EOF 为  -1，而 char 不能表示 -1）

*   重定向

    默认情况下，C 使用标准 I/O 包查找标准输入作为输入源。重定向与操作系统有关，与 C 无关。许多 C 环境（UNIX、Linux、Windows）都有重定向特性。

    重定向输入：`<`  符号是 UNIX、DOS/Windows 的重定向运算符，重定向输出：`>` 

    ```c
    # 组合重定向，命令与重定向运算符的顺序无关，输入与输出文件名不能相同
    ./prog < file1 > file2
    ./prog > file1 < file2
    ```

    重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。使用重定向运算符不能读取多个文件的输入，也不能把输出定义至多个文件。

    UNIX、Linux、Windows/DOS 还有 >> 运算符，该运算符可以把数据添加到现有文件的末尾。｜ 运算符能把一个文件输出连接到另一个文件的输入。

