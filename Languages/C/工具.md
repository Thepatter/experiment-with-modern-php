### 工具

#### 编译器

##### 编译流程

翻译单元：在源代码中包含一个或多个头文件，C 预处理器实际上是用包含的头文件替换 #include 指令。编译器源代码文件和所有的头文件都看成一个包含信息的单独文件。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。

在 C 语言中，编译器可以自行选择先对函数中那个参数求值。

*   如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
*   如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符

C 编译器提供了预定义标识符 `__func__` 在任意函数中获取函数字面量。

###### #define

预处理器指令从 # 开始运行，到后面的第 1 个换行符为止（指令的长度仅限一行）。宏和函数的选择实际上的时间和空间的权衡。宏生成内联代码（在程序中生成语句）。宏不用担心变量类型（宏处理的是字符串，而不是实际值）

*预定义宏*

|         宏         |                            含义                            |
| :----------------: | :--------------------------------------------------------: |
|     `__DATE__`     |          预处理日期（"Mmm dd yyyy"，Nov 23 2013）          |
|     `__FILE__`     |             表示当前源代码文件名的字符串字面量             |
|     `__LINE__`     |                当前源码文件中行号的整形常量                |
|     `__STDC__`     |              设置为 1 时，表明实现遵循 C 标准              |
| `__STDC_HOSTED__`  |               本机环境设置为 1：否则设置为 0               |
| `__STDC_VERSION__` | 支持 C99 标准设置为 199901L；支持 C11 标准，设置为 201112L |
|     `__TIME__`     |             翻译代码的时间，格式为 `hh:mm:ss`              |

`__func__`  C99 提供，展开为函数名的字符串字面量。`__func__` 必须具有函数作用域，而从本质上宏具有文件作用域，`__func__` 是 C 语言的预定义标识符，而不是预定义宏

```c
// #define 指令本身， PX 宏 printf 为替换体
#define PX printf("x is %d.\n", x)
```

* 宏名称

  宏名称中不允许有空格，且必须遵循 C 变量的命名规则

  使用参数可以创建外形和作用与函数类似的类函数宏，类函数宏定义的圆括号中可以有一个或多个参数，这些参数出现在替换体中，但预处理不做计算，不求值，只替换字符序列（一般避免用在宏中使用递增或递减运算符）。

  ```c
  #define MEAN(X, Y) (((X) + (Y)) / 2)
  ```

*   替换体

    预处理器在程序中找到宏的实例后，就会用替换体代替该宏，从宏变成最终替换文本的过程为宏展开。预处理器发现程序中的宏后，会用宏等价的替换文本进行替换。如果替换的字符串中还包含宏，则继续替换这些宏。双引号中的宏不会替换

    ```c
    // 如果预处理将该替换体解释为字符型字符串，将用 4 * 8 替换 EIGHT，额外的空格是替换
    #define EIGHT 4 * 8
    ```

* C 允许在字符串中包含宏参数，在类函数宏的替换体中，# 作为预处理运算符，可以把记号转换成字符串（字符串化）。如果 x 是一个宏形参，#x 就是转换为字符串 "x" 的形参名

  ```c
  #define PSQR(x) printf("The square of " #x " is %d.\n", ((x)*(x)))
  int y = 5;
  PSQR(y);	// The square of y is 25
  PSQR(2 + 4);	// The square of  2 + 4 is 36
  ```

* 变参宏

  接受数量可变的参数，C99/C11 对宏提供（...) 作为可变参数

  ```c
  #define PR(...) printf(__VA_ARGS__)
  ```

###### #undef

取消已定义的 #define 指令

```c
#define LIMIT 400
#undef LIMIT
```

移除定义后，可以将 LIMIT 重写定义为一个新值。即使原来没有定义 LIMIT，取消 LIMIT 的定义仍然有效。如果想使用一个名称，又不确定之前是否已经使用过，可以用 #undef 指令取消该名字的定义

#define 宏的作用域从它在文件中声明处开始，直到用 #undef 指令取消宏为止，或延申至文件尾（以二者中先满足的条件作为宏作用域的结束）。如果宏通过头文件引入，则 #define 在文件中的位置取决于 #include 指令的位置

取消

###### #include

当预处理器发现 #include 指令时，会查询后面的文件名并把文件的内容包含到当前文件中。即把被包含文件的全部内容输入到源文件 #include 指令所在的位置。

```c
#include <stdio.h> // 在标准系统目录中查找该文件
#include "myfunc.h"	 // 在当前目录中查找该文件
```

包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中的材料

需要包含头文件的另一种情况是，使用具有文件作用域、内部链接和 const 限定符的变量或数组。const 防止值被意外修改，static 意味着每个包含该头文件的文件都获得一份副本。因此，不需要在一个文件中进行定义式声明，在其他文件中进行引用式声明

##### 条件编译

可以使用这些指令根据编译时的条件执行或忽略代码块

###### #ifdef/#ifndef #else #endif

```c
// 如果已经用 #define 定义了 MAVIS 则执行下面指令
#ifdef MAVIS
	#include "horse.h"
	#define STABLES 5
#else		// 如果没有用 #define 定义 MAVIS，则执行下面指令
	#include "cow.h"
	#define STABLES 15
#endif
```

ANSI 标准支持缩进格式，之前则必须左对齐所有指令或至少左对齐 # 号

* #ifdef

  如果预处理器已定义了后面的标识符，则执行 #else 或 #endif 指令之前的所有指令并编译所有 C 代码

* #ifndef

  用法与 #ifdef 类似，但逻辑相反，通常包含多个头文件时，其中的文件可能包含了相同宏定义，该指令可以防止相同的宏被重新定义。

* #else

  执行 #else 和 #endif 指令之间的所有代码

###### #line #error

#line 指令重置 `__LINE__` 和 `__FILE__` 宏报告的行号和文件名

```c
#line 1000				// 把当前行号重置为 1000
#line 10 "cool.c"		// 将行号重置为 10，把文件名重置为 cool.c
```

#error 指令让预处理器发出一条错误小心，该消息包含指令中的文本。如果可能编译过程应该中断

```c
#if __STDC_VERSION__ !=201112L
#error Not C11
#enfif
```

###### #pragma

把编译器指令放入源代码中。