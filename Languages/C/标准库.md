### 标准库头文件及函数

#### 库

##### 头文件

`#include` 是预处理指令（preprocessor directive，编译前对源码做的准备工作）。头文件包含了编译器创建最终可执行程序要用到的信息（常量、函数）

###### `limit.h`

|             明示常量              |                      含义                      |
| :-------------------------------: | :--------------------------------------------: |
|            `CHAR_BIT`             |                char 类型的位数                 |
|       `CHAR_MAX`/`CHAR_MIN`       |               char 类型最大/小值               |
|      `SCHAR_MAX`/`SCHAR_MIN`      |           signed char 类型最大/小值            |
|      `UCHAR_MAX`/`UCHAR_MIN`      |          unsigned char 类型最大/小值           |
|       `SHRT_MAX`/`SHRT_MIN`       |              short 类型最大/小值               |
|            `USHRT_MAX`            |             Unsigned short 最大值              |
|        `INT_MAX`/`INT_MIN`        |               Int 类型最大/小值                |
|            `UINT_MAX`             |              Unsigned int 最大值               |
|       `LONG_MAX`/`LONG_MIN`       |               Long 类型最大/小值               |
|            `ULONG_MAX`            |           Unsigned long 类型的最大值           |
|      `LLONG_MAX`/`LLONG_MIN`      |            Long long 类型最大/小值             |
|           `ULLONG_MAX`            |         imsigned Long long 类型最大值          |
|          `FLT_MANI_DIG`           |              float 类型的尾数位数              |
|             `FLT_DIG`             |     float 类型的最少有效数字位数（十进制）     |
| `FLT_MIN_10_EXP`/`FLT_MAX_10_EXP` |     float 类型最小负/正指数（以 10 为底）      |
|        `FLT_MIN`/`FLT_MAX`        |              float 类型的最大正数              |
|           `FLT_EPSILON`           | 1.00 和比 1.00 大的最小 float 类型值之间的差值 |

###### `stdint.h/inttypes.h`

C99 新增，为现有类型创建了更多类型名，新的类型名定义在 stdint.h 头文件中，编译器会将其替换为当前系统匹配的类型以确保移植性

|    类型     |                    用途                    |
| :---------: | :----------------------------------------: |
|  `int32_t`  |              32 位有符号整数               |
| `intmax_t`  |               最大有符号整型               |
| `uintmax_t` | 最大无符号整数，可能大于 usigned long long |

* 精确宽度类型（exact-width integer type）

  `int32_t` 表示整数类型的宽度正好是 32 位，精确宽度类型是可选项

* 最小宽度类型（minimum width type）

  `int_least8_t` 即可容纳 8 位有符号整数值的类型中宽度最小的类型的别名

* 最快最小宽度类型（fastst minimum width type）

  `int_fast8_t` 系统中对 8 位有符号值而言最快的整数类型的别名

inttypes.h 中提供了可移植字符串宏来显示可移植类型：

* PRId32 字符串宏打印 32 位有符号值

  ```c
  int32_t me32 = 45933945;
  printf("me32 = %" PRId32 "\n", me32);
  ```

###### `stdio.h`

* putchar 只根据最后一个字节确定显示那个字符

  ```c
  putchar(ch);
  # 等价于
  printf("%c", ch);
  // 类似 printf，但将格式化数据写入 第一个参数声明的字符串中
  sprintf(char*, char*, ...);
  ```

* getchar

  ```c
  int ch = getchar();
  # 等价于
  scanf("%c", &ch);
  ```

  `getchar()`/`putchar()` 只处理字符串，比通用的 scanf/printf 函数更快、更简洁，不需要转换说明，它们只处理字符。通常是预处理宏，而不是真正的函数。返回 int（因为处理 EOF 的情况，-1 用 char 无法表示）。读取每个字符、包括空格、制表符换行符（scanf 在读取数字时会跳过空格、制表符、换行符）

###### `ctype.h`

包含一系列专门处理字符函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类型，返回一个非零值，否则返回 0.

|   函数名   |                           测试是否                           |
| :--------: | :----------------------------------------------------------: |
| `isalnum`  |                    字母数字（字母或数字）                    |
| `isalpha`  |                             字母                             |
| `isblank`  | 标准的空白字符（空格、水平制表符、换行符）或任何其他本地化指定为空白的字符 |
| `iscntrl`  |                     控制字符，如 Ctrl+B                      |
| `isdigit`  |                             数字                             |
| `isgraph`  |                  除空格之外的任意可打印字符                  |
| `islower`  |                           小写字母                           |
| `isprint`  |                          可打印字符                          |
| `ispunct`  |     标点符号（除空格或字母数字字符以外的任何可打印字符）     |
| `isspace`  | 空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符、其他本地化字符） |
| `isupper`  |                           大写字母                           |
| `isxdigit` |                        十六进制数字符                        |
| `tolower`  |  如果参数是大写字符，该函数返回小写字符；否则，返回原始参数  |
| `toupper`  |  如果参数是小写字符，该函数返回大写字符；否则，返回原始参数  |

###### `iso646.h`

C99 标准新增了可代替逻辑运算符的拼写，定义在该头文件中。使用：

*   and 代替 `&&`
*   or 代替 `||`
*   not 代替 `!`

###### `string.h`

ASNI C 将字符串函数的原型定义在该头文件中。

```c
// 拼接字符串，将第二个字符串副本附加到第一个字符串末尾，将新字符串作为第一个字符串返回，第二个字符串不变，不会检查第一个数组是否能容纳第2个字符串，如果第一个数组空间不够，会造成溢出
strcat(char*, char*);
// 第三个参数指针最大添加字符数，遇到空字符串或 int 时停止追加
strncat(char*, char*, int);
// 比较字符串,相等返回 0, 字符串1小于字符串2返回大于0，否则返回小于0
strcmp(char*, char*);
// 指定比较字符数长度
strncmp(char*, char*, int);
// 拷贝字符串，第一个参数为目标位置，第二个参数为源字符串地址
strcpy(char*, char*);
// 指明最大可拷贝字符数
strncpy(char*, char*, int);
// 如果字符串包含字符，返回字符串首位置指针，未找到字符返回空指针
strchr(char*, int c);
// 如果字符串1包含字符串2中的任意字符，返回字符串1位置，都在返回空指针
stpbrk(char*, char*);
// 返回字符串1中字符2首次出现的位置
strstr(char*,char*);
// 返回字符串中字符串最后依次属性的位置
strrchr(char*, int);
// 返回字符串字符数，不包括末尾空字符
strlen(char*);
```

###### `stdlib.h`

```c
// 字母数字转换成整数, 起始位置指针，结束位置指针，进制
strtol(char*, char*, int);
// 可以使用 ptd[0] 访问该块的首元素
double *pid;
pid = (double *) malloc(30 * sizeof(double)); // 可以在 C99 之前创建动态数组
// 释放之前 malloc 分配的内存，不能用 free 释放自动分配的内存
long *newmem;
// 第一个参数是要分配的存储单元数量，第二个参数是存储单元的大小（字节），calloc 把块中所有位设置为 0
newmem = (long *) calloc(100, sizeof(long));
// 释放 malloc/calloc 分配的内存
free(*void);
// 结束程序，EXIT_FAILURE 异常终止、EXIT_SUCCESS 等于 0 标识普通程序结束
exit();
```

malloc/calloc 函数分配内存，返回动态分配内存的首字节地址。ANSI C 标准之前返回 char 指针，ANSI C 标准开始返回 void 指针，通常该函数的返回值会被强制转换为匹配的类型（指向 void 的指针赋给任意类型的指针不用考虑类型匹配的问题，如果分配失败，将返回空指针）。动态分配内存的存储期从调用 malloc 分配内存到 free 释放内存。free 所用的指针变量可以与 malloc 的指针变量不同，但是两个指针必须存储相同的地址。不能释放同一块内存两次。通常使用动态内存比使用栈内存慢

###### `time.h`

提供 time() 函数返回 time_t.

#### 标准库

##### 标准 IO

在底层 C 可以使用操作系统的文件 IO，在应用层上，C 可以使用标准 IO 包。

ANSI C 把缓冲输入作为标准的（一些计算机不允许无缓冲输入）用 `setbuf` 和 `setvbuf` 函数控制缓冲。ANSI 没有提供调用无缓冲输入的标准方式（是否能进入无缓冲输入取决于操作系统）

标准 IO 定义了用于处理文件的标准模型和一套标准 I/O 函数。具体的 C 实现负责处理不同系统的差异。

*   IBM PC 兼容机编译器为支持无缓冲输入提供了一系列特殊的函数，原型在 `conio.h` 头文件中，这些函数包括用于回显无缓冲输入的 `getche()` 函数和用于无回显无缓冲输入的 getch() 函数
*   UNIX 使用 `ioctl()` 函数（属于 UNIX 库，但不属于 C 标准）指定待输入的类型，然后用 `getchar()` 执行相应的操作

###### 文件

C 提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。

概念上，C 程序处理的是流而不是直接处理文件（即不同属性和不同种类的输入，由属性更统一的流来表示）打开文件的过程就是把流与文件相关联，读写都是通过流来完成。

程序可以通过两种方式使用文件：显示使用函数打开文件、关闭文件、读取文件、写入文件；设计能与键盘和屏幕互动的程序，重定向输入至文件和从文件输出

* 文件结尾

  过m去操作系统使用内嵌的 Ctrl+Z 字符来标记文件结尾。现在文本文件不一定有嵌入的 Ctrl+Z，如果有，该操作系统会将其视为一个文件结尾标记。使用的另一bn种方法是存储文件大小的信息。如果文件有 3000 字节，程序在读到 3000 字节时便达到文件的末尾。键盘使用 `Ctrl+D` 模拟文件 EOF。

   在 C 语言中，用 `getchar()`/`scanf()` 读取文件检测到文件结尾时将返回一个特殊的值（`EOF` end-of-file），此时要用 int 而不是 char 来获取输入（EOF 为  -1，而 char 不能表示 -1）

* 重定向

  默认情况下，C 使用标准 I/O 包查找标准输入作为输入源。重定向与操作系统有关，与 C 无关。许多 C 环境（UNIX、Linux、Windows）都有重定向特性。

  重定向输入：`<`  符号是 UNIX、DOS/Windows 的重定向运算符，重定向输出：`>` 

  ```c
  # 组合重定向，命令与重定向运算符的顺序无关，输入与输出文件名不能相同
  ./prog < file1 > file2
  ./prog > file1 < file2
  ```

  重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。使用重定向运算符不能读取多个文件的输入，也不能把输出定义至多个文件。

  UNIX、Linux、Windows/DOS 还有 >> 运算符，该运算符可以把数据添加到现有文件的末尾。｜ 运算符能把一个文件输出连接到另一个文件的输入。



