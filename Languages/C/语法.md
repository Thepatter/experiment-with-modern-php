### 语言

#### 语法

C99/C11 可以在块中任何位置声明变量，之前只能在块的顶部声明。C99/C11 允许使用更长的标识符名，编译器只识别前 63 个字符（如果两个标识符名都是 64 个字符，只有最后一个字符不同，那么编译器可能将其视为同一个名称，也可能不会，其行为是未定义的）。对外部标识符，只允许使用 31 个字符。C90 只允许 6 个字符

*关键字*

|   auto   |    extern     |  short   |     while      |  break   |   float   |
| :------: | :-----------: | :------: | :------------: | :------: | :-------: |
|  signed  |   _Alignas    |   case   |      for       |  sizeof  | _Alignof  |
|   char   |     goto      |  static  |    _Atomic     |  const   |    if     |
|  struct  |     _Bool     | continue |     inline     |  switch  | _Complex  |
| default  |      int      | typedef  |    _Generic    |    do    |   long    |
|  union   |  _Imaginary   |  double  |    register    | unsigned | _Noreturn |
|   else   |   restrict    |   void   | _Static_assert |   enum   |  return   |
| volatile | _Thread_local |          |                |          |           |

##### 存储类别

|   存储类别   | 存储期 | 作用域 | 链接 |        声明方式         |
| :----------: | :----: | :----: | :--: | :---------------------: |
|     自动     |  自动  |   块   |  无  |          块内           |
|    寄存器    |  自动  |   块   |  无  |   块内 register 声明    |
| 静态外部链接 |  静态  |  文件  | 外部 |       所有函数外        |
| 静态内部链接 |  静态  |  文件  | 内部 | 所有函数外 static 声明  |
|  静态无连接  |  静态  |   块   |  无  | 块内，使用关键字 static |

###### 作用域和链接

作用域和链接描述了标识符的可见性

变量作用域包含块（一对花括号之间声明的变量，C99 允许在块中任意位置声明变量，C99 把块的概念扩展到 for、while、do while、if）、函数（仅用于 goto 语句的标签，即使一个标签首次出现在函数的内层块中，它的作用域也延伸到整个函数）、函数原型（用于函数原型中形参名，在变长数组中形参名才有用）、文件（定义在函数外，从它的定义处到所在文件的末尾均可见）。

变量有 3 种链接属性：外部链接的文件作用域（可以在多文件程序中使用即全局作用域）、内部链接的文件作用域（只能在一个翻译单元中使用即文件作用域）、无链接（块作用域、函数作用域、函数，这些变量属于它们的块、函数、原型私有）。具有文件作用域的变量可以是外部链接或内部链接。

```c
int giants = 5; 	// 外部链接文件作用域，同一程序其他文件可用
static int dodgers = 3;		// 内部链接文件作用域，该文件内可用
double gamma(double);	// 默认为外部函数，可以被其他文件的函数访问
static double beta(int, int);	// 只能用于其定义所在的文件
extern double delta(double, int);	// 声明外部函数，当前文件可以定义与之同名的函数
```

###### 存储期

存储期描述了通过这些标识符访问的对象的生存期。C 对象有 4 种存储期：

* 静态存储期

  在程序的执行期间一直存在，文件作用域变量具有静态存储期。关键字 static 表明了其链接属性非存储期。以 static 声明的文件作用域变量具有内部链接。无论是内部链接还是外部链接所有的文件作用域变量都具有静态存储期。

* 线程存储期

  线程存储期得对象，从被声明时到线程结束一直存在。以关键字 `_Thread_local` 声明一个对象时，每个线程都获得该变量私有拷贝

* 自动存储期

  块作用域得变量通常具有自动存储期。当程序进入定义这些变量得块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。

  变长数组的存储期从声明处到块的末尾，而不是从块的开始到块的末尾

* 动态分配存储期

###### 变量类型

* 自动变量

  可以使用 auto 关键字显式声明块变量为自动变量。自动变量不会初始化，其值可能为任何值

* 寄存器变量

  存储在最快的可用内存种（可能存储在寄存器中），所以无法获取寄存器变量的地址，大多数时寄存器变量是块作用域、无链接和自动存储。可声明为 register 的数据类型有限

* 块作用域静态变量（内部静态存储）

  该变量在内存中不动，并非值不变。具有文件作用域的变量自动具有（也必须是）静态存储期。具有静态存储期、块作用域、无连接的局部变量。和自动变量作用域相同，但函数执行完成后这些变量不会消失。在函数块中使用 static 声明

* 外部链接的静态变量（外部存储）

  外部链接的静态变量具有文件作用域、外部链接和静态存储期。属于该类别的变量称为外部变量。将变量的定义声明放在所有函数的外面。可以函数声明中使用关键字 extern 声明（引用式声明，指示编译器去别处查询其定义）。如果一个源码文件使用的外部变量定义在另一个源代码文件中，则必须用 extern在该文件中声明该变量。外部变量只能初始化一次，且必须在定义该变量时进行。可以作用于同一程序所有文件中

* 内部链接的静态变量

  该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部使用 static 声明，只能作用于当前文件中。

###### 类型限定符

C99 为类型限定符增加了新属性，它们是幂等（可以在一条声明多次使用同一个限定符，多余的限定符将被忽略），且语法上有如下更新

```c
void ofmouth(int * const a1， int * restrict a2， int n); 
void ofmouth(int * const a1， int * restrict a2， int n); // 等价 c99 之后声明
```

* const

  用于声明不变性，其值不能通过赋值修改，即只能初始化

  ```c
  // 指向一个 float 类型的 const 值，pf 指向的值不饿能修改
  const float *pf; // 等价 float const *pf;
  // 指向一个 const 指针，指针 pt 本身的值不能更改，pt 必须指向同一个地址，但它指向的值可以改变
  float *const pt;
  // ptr 既不能指向别处，指向值也不能改变
  const float * const ptr;
  ```

  const 放在 * 左侧，限定了指向的数据不能改变，放在 * 右侧，限定了指针本身不能改变。在文件间共享 const 数据时，可以在一个文件中定义，在另一个文件中使用 extern 引用；将 const 变量放在一个头文件中（头文件中使用关键字 static 声明全局 const 变量，如果去掉 static，则每个文件中都有一个相同标识的定义式声明，C 标准不允许这样，用 static 声明等于给每个文件提供了一个单独的数据副本，由于每个副本只对该文件可见，无法用这些数据和其他文件通信，但由于使用 const 声明，所以其是安全的只读副本），然后在其他文件中包含该头文件。

* volatile

  用于声明易变性。告知计算机可以改变该变量的值。通常它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。涉及编译器优化

  ```c
  val = x;
  /* 一些不使用 x 的代码 */
  val2 = x;
  ```

  编译器会注意到以上代码使用了两次 x，但并未改变它的值，编译器会将 x 的值临时存储到寄存器中，在 val2 需要使用 x 时，从寄存器读取 x 的值。如果声明中没有 volatile 关键字，编译器会假定变量的值在使用过程中不变而进行优化。可以同时用 const 和 volatile 限定一个值

* restrict

  C99 新增，提高编译器优化。只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

  ```c
  int * restrict restart = (int *) malloc(10 * sizeof(int)));
  ```

  restrict 限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。

* _Atomic

  C11 新增，支持并发程序涉设计

  ```c
  int hogs; 
  hogs = 12;
  _Atomic int hogs;
  atomic_store(&hogs, 12); 	// 原子赋值， stdatomic.h 中
  ```

##### 运算符

除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值。对于逻辑运算符，C 保证逻辑表达式的求值顺序是从左往右。&& 和 || 运算符都是序列点，程序在从一个运算符对象执行到下一个运算符对象之前，所有的副作用都会生效，一旦发现某个元素让整个表达式无效，便立即停止求值。

###### typedef

允许为现有类型创建别名

```c
typedef double real;
```

###### sizeof/size_t

sizeof 运算符以字节为单位返回运算对象的大小，返回 size_t 类型的值，这是一个无符号整型。size_t 是语言定义标准类型

##### 数据类型

基本数据类型 `int`、`long`、`short`、`unsigned`、`char`、`float`、`double`、`signed`、`_Bool`、`_Complex`、`_Imaginary` 可以使用 `sizeof`（以字节为单位给出指定类型的大小）来获取基本类型占用字节数。当浮点类型被降级为整数类型时，原来的浮点值会被截断。许多类型转换都是自动进行的。当 char/short 出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为 int 类型；float 类型在函数参数中时，会被升级为 double 类型。

```c
# C99/C11 使用 %zd 转换 sizeof 返回类型，之前使用 %u/%lu 代替
printf("long double size %zd bytes\n", sizeof(long double)); // 16 bytes
```

###### 常量

C90 新增了 const 关键字，用于限定一个变量为只读。

```c
#define NAME value
```

编译程序时，程序中所有的常量会被替换成常量值，这样定义的常量被称为明示常量（manifest constant）

###### Int

ISO C 规定 `int` 的取值范围最小为 -32768～32767，即不小于 16 位，格式化时：%d 十进制显示数字，%o 八进制显示数字，%x 十六进制显示数字，显示前缀 0、0x、0X，使用 %#o、%#x、%#X。

C 语言提供了：short、long、unsigned 修饰整数，整数溢出行为是未定义的，可能会从该类型最小值开始重新计数

* short int 

  占用空间可能比 int 少，有符号，标准规定 short 占用存储空间不能多于 int，格式化时用 hd 无符号使用 hu

  ```c
  int main()
  {
      short b = -336;
    	// b: -336 format signed short: -336; unsigned short: 65200
      printf("b: -336 format signed short: %hd; unsigned short: %hu\n", b, b);
      unsigned short a = 65200;
      // a:65200 format signed short: -336; unsigned short: 65200
      printf("a:65200 format signed short: %hd; unsigned short: %hu\n", a, a);
  }
  ```

  上述转换结果原因：short 大小是 2 字节，系统使用二进制补码来表示有符号整数，这种方法数字 0～32767 代表它们本身，而数字 32768 ～ 65535 则表示负数。65535 表示 -1，65534 表示 -2。所以 -336 解释成无符号 short 时为 65200，65200 被解释成有符号 short 时为 -336

* long int

  占用空间可能比 int 多，有符号，标准规定 long 占用空间不能少于 int，至少占 32 位

* long long int

  C99 加入，占用空间可能比 long 多，至少占 64 位，有符号，格式化时使用 ll LL ull LLU ULL 表示

###### char

存储字符，实际存储的是整型，C 语言把 1 字节定义为 char 类型占用的位数。C 语言将字符常量视为 int 类型而非 char 类型。直接表示字符常量时，使用单引号将字符括起来，支持在八进制或十六进制前加一个反斜杠表示 ASCII 中的一个字符（`\007`）

```c
int main()
{
  	short num = 336;
    // num as int and char: 336 P
  	printf("num as int and char: %d %c\n", num, num);
}
```

使用 printf 函数 %c 打印 336 时，它只会查看存储 336 的 2 字节中的后 1 字节。336 二进制为 「00000001 01010000」，取后一个字节为「01010000」即十进制 80，对应 ASCII 码为「P」。计算方式为除 256 取余即取 256 模值转 ASCII 码。

打印 char 时，使用 %d 将打印一个整数值，使用 %c 将打印字符值。有些编译器将 char 实现为有符号类型，表示范围为 -128～127，有些编译器将 char 实现为无符号类型，表示范围是 0～255。C90 标准，允许使用 signed 或 unsigned 修饰 char。

*特殊字符*

| 字符 |   含义   |                           标准                            |
| :--: | :------: | :-------------------------------------------------------: |
| `\a` |   警报   |                     不得改变活跃位置                      |
| `\b` |   退格   |                       活跃位置退格                        |
| `\f` |   换页   |                  活跃位置移到下一页开始                   |
| `\n` |   换行   |                活跃位置移至下一行开始出处                 |
| `\r` |   回车   |                活跃位置移动到当前行开始处                 |
| `\t` | 水平制表 | 活跃位置移至下一个水平制表点（第1、9、17、25 等字符位置） |
| `\v` | 垂直制表 |               活跃位置移至下一个垂直制表点                |

* 活跃位置，显示设备中下一个字符将出现的位置，如光标。换页、垂直制表符在 PC 屏幕会产生奇怪的符号，光标并不会移动，只有将其输出到打印机才会有效果

* `\\`、`\'`、`\"` 用于打印，`\0oo`、`\xhh`

  ```c
  # 如果要用八进制 ASCII 码表示一个字符，可以在编码值前加一个反斜杠并用单引号括起来
  # 使用 '\x' 或 '\x0' 表示十六进制
  beep = '\007'; # 可以省略前面的 0，'\07', '\7' 编译器都能识别
  ```

* 无论是普通字符还是转义字符，只要是双引号括起来的字符集合（字符串），就无需用单引号括起来

###### _Bool

C99 标准添加了 _Bool 类型用于表示布尔值，true/false，使用 1 表示 true，0 表示 false，仅占用 1 位存储空间

###### float

浮点类型有 float、double、long double（C90 新增），double 和 float 类型最小取值范围相同，至少能表示 10 位有效数字。一般情况下 double 占用 64 位。C 只保证 long double 至少与 double 类型精度相同。默认情况下，编译器假定浮点型（没有后缀）常量是 double 类型的精度。f/F 后缀表示 float 类型。l/L 后缀为 long double 类型。

使用 %f 打印 float/double 浮点数。使用 %Lf、%Le、%La 打印 long double 。未在函数原型中显式说明参数类型的函数，传递参数时，编译器会把 float 类型的值自动转换成 double 类型

*   上溢（数字过大，超过当前类型表达范围）浮点数溢出时显示一个表示无穷大的特定值（inf/infinity）
*   下溢（损失了指数精度），C 语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。把最小的浮点数除 2 将一个一个低于正常的值，如果除非常大的值，会导致所有的位都为 0
*   NaN 特殊浮点值，部分函数结果返回该值（asin 函数传入大于 1 的参数）

C99 新增了用十六进制表示浮点常量，在十六进制数前加上十六进制前缀，用 p/P 代替 e/E，用 2 的幂代替 10 的幂，并非所有编译器都支持 C99 这一特性。打印十六进制浮点数，用 a/A 代替 e/E。

C 编译器把浮点数转换成整数时，直接丢弃小数部分。

```c
float planck = 6.53e-34;
double a = -1.56E+12;
double b = .8E-5;
double c = 0xa.1fp10; // 10364.0
```

###### `_Complex/_Imaginary`

C99 标准支持复数和虚数类型。C11 标准把整个复数软件包作为可选项。

C 语言复数类型：float _Complex（包含两个 float 类型的值，表示复数的实部和虚部）、double _Complex、long double _Complex

C 语言的虚数类型：float _Imaginary、double _Imaginary、long double _Imaginary

引入 complex.h 头文件，可用 complex 代替 _Complex，用 imaginary 代替 _Imaginary，用 l 代替 -1 的平方根

##### 复合类型

###### 数组

C 使用新的语法来初始化数组，不支持该语法可以加上关键字 static 解决

```c
// type 是数组中每个元素的数据类型，name 是数组的名，size 是数组元素个数 
type name [size];
int powers[8] = {1, 2, 3, 4, 5, 6, 7, 8};
const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31};
```

C99 新增了指定初始化器

```c
// C99 之前的指定初始化
int arr[6] = {0, 0, 0, 0, 0, 212};
// C99 之后，可以在初始化列表中使用待方括号的下标指明初始化的元素
int arr[6] = {[5] = 212};
```

数组名是数组首元素的地址。指针访问和数组访问两种方式等效。对数组名加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。递增它所指向类型的大小，以字节为单位

```c
dates + 2 == &dates[2]     // 相同的地址
*(dates + 2) == dates[2]   // 相同的值
ar[i] 和 *(ar + i) 等价
```

在使用数组为参数的函数中，只有在函数原型或函数定义头中，才可以用 int ar[] 代替 int *ar（两者都表示 ar 是一个指向 int 的指针，但 int ar[] 只能用于声明形参，因为数组名是数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，只有在这种情况下，C 才会将两者解释成一样）。

```c
// 以下四种原型等价
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
// 以下两种定义等价
int sum(int *ar, int n){}
int sum(int ar[], int n){}
// 使用双指针标示数组开始和结束
int SIZE = 4;
int[SIZE] arr = {1, 2, 3, 4};
int int_sum = sum(arr, arr + SIZE);
// 使用数组首地址和尾部地址
int sum(int * start, int * end)
{
  	int total = 0;
  	while (start < end) {
      	total += *start++; // 一元运算符 * 和 ++ 的优先级相同，结合律从右往左
    }
  	return total;
}
```

C 保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。但对该指针处值未做任何保证（即 arr + SIZE 有效，但 arr[SIZE] 无效）

要创建一个处理任意大小的二维数组的函数，必须把数组作为一维数组传递，然后让函数计算每行的开始处。C99 新增了变长数组，允许使用变量表示数组的维度。变长数组必须是自动存储。无论在函数声明还是作为函数形参声明，都不能使用 static 或 extern。而且，不能在声明中初始化它们。C11 把变长数组作为一个可选特性。变长数组不能改变大小（不能修改已创建数组的大小，一旦创建了变长数组，它的大小则保持不变。变指的是，在创建数组时，可以使用变量指定数组的维度）变长数组名实际是一个指针。

```c
int quarters = 4;
int regions = 5;
double sales[regions][quarters]; // 变长数组，创建数组时，使用变量指定数组的维度
// 前两个形参用作第3个形参二维数组的两个维度，ar 声明要使用 rows，cols，在形参列表中必须在声明 ar 之前先声明这两个形参
int sum2d(int rows, int cols, int ar[rows][cols]);
// 实参声明变长数组，但不能使用声明并赋值的语法
int rs = 3; 
int cs = 2;
int i = 0;
int j = 0;
int var_arr_success[rs][cs]; // 正确，先声明编程数组，再为数组赋值
for (i = 0; i < rs; ++i) {
  for (j = 0; j < cs; ++j) {
    var_arr_success[i][j] = i * j + j;
  }
}
int var_arr_error[rs][cs] = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}; // 错误
// C99/C11 标准规定，可以省略原型中的形参名
int sum2d(int, int int ar[*][*]);
// 无效的顺序
int sum2d(int ar[rows][cols], int rows, int cols);
```

声明数组时使用 const 变量可能会无法移植。C90 标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合。由于 C 实现可以扩大整型常量表达式的范围，所以可能会允许使用 const，但这种代码可能无法移植

C99/C11 标准允许在声明变长数组时使用 const 变量。所以该数组的定义必须是声明在块中的自动存储类别数组。变长数组还允许动态内存分配，可以在程序运行时指定数组的大小。普通 C 数组都是静态内存分配，即在编译时确定数组大小。由于数组大小是常量，所以编译器在编译时就知道了

对于传统 C 数组，必须用常量表达式指明数组大小，数组大小在编译时就确定。C99/C11 支持的变长数组，可以用变量表示数组大小，变长数组的大小延迟到程序运行时才确定

```
const int SZ = 89;
double ar[SZ];
```

C99 新增了复合字面量（除符号常量外的常量）对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。复合字面量的类型名也代表首元素的地址。可以将它赋给指针后使用，可以将复合字面量作为实际参数传递给匹配形参的函数（把信息传入函数前不必先创建数组）复合字面量是提供只临时需要值的一种方法，具有块作用域。一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在

```c
// 普通数组声明
int diva[2] = {10, 20};
// 复合字面量（创建了和 diva 相同的匿名数组）
(int [2]){10, 20}
// 初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器自动计数数组当前的元素个数
(int []){59, 29, 89}
// 复合字面量是匿名{的，必须在创建的同时使用，使用指针记录地址
int *pt1;
pt1 = (int [2]){10, 20};
```

###### 字符串

C 语言没有专门用于存储字符串的变量类型，字符串都被存储在 char 类型的数组中。使用 `\0` 字符（不可打印字符）来标记字符串的结束。ANSI C 引入字符串连接，在两个双引号括起来的字符串之间用空白隔开，C 编译器会把多个字符串看作是一个字符串。

使用 sizeof 计算字符串字符数时会包含末尾不可见的空字符。sizeof 函数运算对象是类型时要使用圆括号，对于特定量可以省略圆括号

printf/scanf 输出输入时不用换行，刷新缓冲后会自动换行

*转换说明*

| 占位符 |                             说明                             |
| :----: | :----------------------------------------------------------: |
| %a/%A  |           浮点数、十六进制数和 p 记数法（C99/C11）           |
|   %c   |                           单个字符                           |
| %d/%i  |                       有符号十进制整数                       |
| %e/%E  |                       浮点数、e 记数法                       |
|   %f   |                     浮点数、十进制计数法                     |
| %g/%G  | 根据值自动选择 %f/%e（%e 格式用于指数小于 -4 或大于等于精度时） |
|   %o   |                       无符号八进制整数                       |
|   %p   |                             指针                             |
|   %s   | 字符串（指定宽度左对齐使用 `%-30s`，默认右对齐，精度限制打印个数） |
|   %u   |                       无符号十进制整数                       |
| %x/%X  |           无符号十六进制整数，使用十六进制数 Of/OF           |
|   %%   |                            百分号                            |

* printf()

  如果 printf() 语句有其他不匹配的地方，即使忽略警告的转换也会生成错误的结果（可能会截断或读取错误的字节）。函数执行时：1. 程序把传入的值放入栈中，根据变量类型（不是根据转换说明）把这些值放入栈中。2.控制转到 printf 函数，该函数根据转换说明（不是根据变量类型）从栈中读取值。

  该函数返回*打印字符*的个数，如果有输出错误，返回一个负数。格式化字符串中不能通过 Enter/Return换行。

  修饰符

  | 修饰符 |                             含义                             |
  | :----: | :----------------------------------------------------------: |
  |  数字  | 最小字段宽度，如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段（%4d） |
  | .数字  | 精度，%e/%E/%f，表示小数点右边数字的位数；%g/%G 表示有效数组最大位数；%s 转换，表示待打印字符的最大数量；对于整型，表示打印数字最小位数；只使用 . 表示其后跟随一个 0，%.f 和 %.0f 相同 |
  |   h    | 和整型转换说明一起使用，表示 short int/unsigned short int：%hu、%hx、%6.4hd |
  |   hh   | 和整型转换说明一起使用，表示 signed char/unsigned char 类型值：%hhu、%hhx、%6.4hd |
  |   j    | 和整型转换一起使用，表示 intmax_t/uintmax_t 类型的值：%jd、%8jx |
  |   l    | 和整型转换一起使用，表示 long int/unsigned long int 类型值：%ld、%81u |
  |   ll   | 和整型转换一起使用，表示 long long int/unsigned long long int 类型值：%11d、%10.4Le |
  |   L    |      和浮点转换一起使用，表示 long double：%Lf、%10.4Le      |
  |   t    | 和整数转换说明一起使用，表示 ptrdiff_t 类型值（两个指针差值的类型 C99），%td、%12ti |
  |   z    | 和整型转换一起使用，表示 size_t 类型（sizeof 返回的类型 C99）的值，%zd、%12zd |

* scanf()

  可以读取不同格式的数据。scanf 把输入的字符串转换成整数、浮点数、字符、字符串。与 printf 类似，使用格式字符串和参数列表。区别在与 printf 函数使用变量、常量、表达式，而 scanf 函数使用指向变量的指针（如果读取基本类型的值，使用指针操作符 &，读取字符串到字符数组中，不必使用指针操作符）

  scanf 使用空白（换行符、制表符、空格）把输入分成多个字段，在依次把转换说明和字段匹配时跳过空白（对于 %c 时例外）

  返回成功读取的项数，如果没有读取任何项或格式化项错误，返回 0，读到文件末尾时，返回 EOF

  ```c
  // 从输入中第一个字符开始读取
  scanf("%c", &ch);
  // 从第一个非空白字符开始读取
  scanf(" %c", &ch);
  // 用户必须输入 , 可在逗号前后包含任意个空格：88，121 88 ,123 88, 112
  scanf("%d,%d", &n, &m);
  ```

  *转换说明*

  |    转换说明    |                          含义                          |
  | :------------: | :----------------------------------------------------: |
  |       %c       |                    把输入解释成字符                    |
  |       %d       |              把输入解释成有符号十进制整数              |
  | %e、%f、%g、%a |         把输入解释成浮点数（C99 标准新增 %a）          |
  | %E、%F、%G、%A |        把输入解释成浮点数哦（C99 标准新增 %A）         |
  |       %i       |              把输入解释成有符号十进制整数              |
  |       %o       |              把输入解释成有符号八进制整数              |
  |       %p       |                    把输入解释成指针                    |
  |       %s       | 把输入解释成字符串，从第一个非空白字符到下一个空白字符 |
  |       %u       |              把输入解释成无符号十进制整数              |
  |     %x、%X     |             把输入解释成有符号十六进制整数             |

  *修饰符*

  | 修饰符 |                             用途                             |
  | :----: | :----------------------------------------------------------: |
  |   *    |                         抑制赋值 %*d                         |
  |  数字  | 最大字段宽度，输入达到最大字段宽度处，或第一次遇到空白字符时停止 %10s |
  |   hh   | 修饰整数为 signed char 或 unsigned char 类型（C99）%hhd、%hhu |
  |   ll   | 把整数作为 long long 或 unsigned long long 类型读取（C99）%lld、%llu |
  |   h    |  %hd %hi/%ho %hx 对应值存储为 short int/unsigned short int   |
  |   l    | %ld %li 对应值存储为 long，%lo %lx %lu 对应值存储为 unsigned long |
  |   lf   | %le、%lf、%lg 对应值存储为 double，e、f、g 前 L 大写为 long double |
  |   j    | 在整型转换后时，表明使用 intmax_t 或 uintmax_t（C99）：%jd、%ju |
  |   z    | 在整型转换后时，表明使用 sizeof 的返回类型（C99）：%zd、%zo  |

###### 指针

指针值为内存地址的变量。声明指针变量时必须指定指针所指向变量的类型，不同的变量类型占用不同的存储空间。一些指针操作要求知道操作对象的大小。程序必须知道存储在指定地址上的数据类型

大部分系统内部，该地址由一个无符号整数表示，一些处理整数的操作不能用来处理指针。指针的值为它所指向对象的地址，地址的表示方式依赖于计算机内部硬件（PC，Macintosh）都是按字节编码，内存中的每个字节都按顺序编号。一个较大对象的地址（如 double）通常是该对象第一个字节的地址

```c
// * 和指针名之间的空格可有可无，通常在声明时使用空格，在解引用时省略空格
int * pi; // pi 是指向 int 类型变量的指针
char * pc;  // pc 是指向 char 类型变量的指针
float * pf, * pg;  // pf、pg 是指向 float 类型变量的指针
```

可以把地址赋给指针（数组名、带地址运算符 & 的变量名、另一个指针），地址应该和指针类型兼容。指针变量也有自己的地址和值。对指针而言，& 运算符给出指针本身的地址。**创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。在使用指针之前，必须先用已分配的地址初始化它**

* 地址运算符 &

  获取变量对应的地址

* 间接运算符 `*` 也称为解引用运算符（获取指针变量指向地址存储的值）即该指针所指向对象的值，千万不要解应用未初始化的指针

  ```c
  val = *ptr;
  # val = bah; 等于以下语句
  ptr = &bah;
  var = *ptr;
  # 间接运算符优先级高于 +，*dates+2 相当于 (*dates)+2
  *(dates + 2) // dates 第三个元素的值
  *dates + 2 // 第一个元素的值加 2 
  ```

指针之间的赋值比数值类型之间的赋值要严格（不用类型转换就可以将较小范围的值赋值给较大范围的值，但两个类型的指针不能这样操作）

指针操作

* 指针与整数相加

  可以用 + 运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。如果相加的结果超出了指针指向数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C 保证指针有效

* 指针减去一个整数

  数组指针必须是第 1 个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。如果相减的结果超出初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C 保证该指针有效

* 递增指针

  递增指向数组元素的指针可以让该指针移动至数组的下一个元素。在 C 中，指针加 1 指的是增加一个存储单元

* 递减指针

* 指针求差

  可以计算两个指针的差值。通常求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。数组的两个指针所指向的两个元素的差为一个整数，意思这两个指针所指向的两个元素相隔两个 int。只有两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。

* 比较

  使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象

指针用途

对于基本类型，通常直接传值。只有程序需要在函数中改变该数值时，才会传递指针。对于数组必须传递指针。如果一个函数按值传递数组，必须分配足够的空间来存储原数组的副本，然后将原数组所有的数据拷贝至新数组。

如果函数不是修改数组中的数据内容，在函数原型和函数定义中声明型参时使用关键字 const（函数不能修改指针指向值，该函数在处理数组时将其视为常量，不可更改），把 const 数据或非 const 数据的地址初始化为指向 const 的指针或为其赋值是合法的，只能把非 const 数据的地址赋给普通指针，C 标准规定，使用非 const 标识符修改 const 数据导致的结果是未定义的。把 const 指针赋给非 const 指针不安全，这样可以使用新的指针改变 const 指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。把非 const 指针赋给 const 指针没问题，前提只进行一级解引用，超过一级则不安全

C 和 C++ 中 const 区别：C++ 允许在声明数组大小时使用 const 整数，而 C 不允许，C++ 的指针赋值检查更严格，C++ 不允许把 const 指针赋给非 const 指针

```c
const int y;
const int * p2 = &y;
int *p1;
p1 = p2; // c++ 不允许，c 可能给出警告
```

```C
double rates[5] = {99.1, 92,2, 93.3, 94.4, 95.5};
const double locked[4] = {0.08, 0.075, 0.72, 0.08}; // 有效，为 const 数据初始化赋值
const double *pc = rates;  // 有效，非 const 数据地址初始化为指向 const 的指针
double * pnc = rates; // 有效
pnc = locked; // 无效
pnc = &rate[3];  // 有效
// 声明一个不能指向别处的指针
double rate[5] = {88.99, 100.12, 59.45, 183.11, 340.55};
double * const pc = rates; // pc 指向数组开始且不会变
pc = &rate[2]; // 不允许
*pc = 92.99 // 允许，只改变了指针指向的值
const int **pp2; // 指向 int 型指针的指针，int 型指针的地址不容许修改
```

* 多维数组指针表示

  ```c
  // 数组名 zippo 是数组首元素的地址 zippo 的首元素是一个内含两个 int 值的数组，zippo 是这个内含两个 int 的数组地址，zippo 和 &zippo[0] 地址相同，zippo[0] 本身是一个内含两个整数的数组，zippo[0] 的值是它首元素地址(&zippo[0][0])相同。**zip 与 &zip[0][0] 等价
  int zip[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
  // zip 二维数组首元素的地址(每个元素都是内含两个 int 类型元素的一维数组)
  // zip+2 二维数组的第 3 个元素(即一维数组)的地址
  // *(zip+2) 二维数组的第 3 个元素(即一维数组)的首元素(一个 int 类型的值)地址
  // *(zip+2) + 1 二维数组的第 3 个元素(即一维数组)的第 2 个元素(也是一个 int 类型值) 地址
  // *(*(zip+2) + 1) 二维数组的第 3 个元素(即一维数组)的第 2 个 int 类型元素的值，即数组的 zip[2][1] = 3
  ```

  地址的地址或指针的指针就是双重间接。增加数组维数会增加指针的复杂度，最好使用数组表示法

* 指向多维数组的指针

  ```c
  // 指向一个内含两个 int 类型值的数组，[]的优先级高于 * 要使用括号
  int (* pz)[2]; 
  // pax 是一个内含两个指针元素的数组，每个元素都指向 int 的指针，[] 优先级高，先与 pax 结合，pax 成为内涵两个元素的数组，* 表示 pax 数组内含两个指针，int 表示 pax 数组中的指针都指向 int 类型的值
  int * pax[2];
  // 可用用数组或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名来访问数组
  int zip[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
  int (* pz)[2];
  pz = zip;
  printf("pz[2][1] = %d==*(*(pz+2)+1)=%d=3\n", pz[2][1], *(*(pz + 2) + 1));
  // 一般声明一个指向 N 维数组的指针时，只能省略最左边方括号中的值
  int sum3d(int ar[][12][23][3], int rows);
  // 等价
  int sum3d(int (*ar)[12][23][3], int rows);
  ```


* 指向函数的指针数组

* 函数间传递信息

  如果希望在被调函数中改变主调函数的变量，必须使用指针。

###### 结构

使用关键字 struct 声明一个结构，结构成员（C 数据类型）列表中每个成员需要进行声明，使用 ；分割成员。结构的标记名是可选的。但一处定义结构，在另一处定义实际的结构变量时，必须使用标记。

```c
struct book {
	char title[32];
	char author[32];
	float price;
};
// 分配结构占用内存空间
struct book libar;
// 局部结构
struct {
    char title[32];
    char author[32];
    float price;
} libar;
// 嵌套结构
struct names {
    char first[LEN];
    char last[LEN];
};
struct guy {
    struct names handle;
    char favfood[LEN];
    char job[LEN];
    float income;
};
// 声明结构指针,指针访问成员使用 ->/(*) 如：him = &barnery him->income = barney.income 或 (*him).income
struct book *ptbook; // pthook = &guy; 为指针赋值
// 结构数组
struct book library[2]; // 访问结构数组成员 library[2].title
// 初始化结构
struct book lib {
    "The C Primer Plus",
    "Renee Vivotte",
    1.95
}
// C99/C11 指定初始化器
struct book surpirce = {.value = 10.99};
struct book gift = {.value = 25.99, .author = "James Broadfool", .title = "Rue for the Toad"};
```

结构名并不是结构的地址，将结构地址赋值给结构指针时必须使用 & 符号。有些系统中，一个结构的大小可能大于它各成员大小之和。这是因为系统对数据进行校准的过程中产生了一些“缝隙”。例如，有些系统必须把每个成员都放在偶数地址上，或4的倍数的地址上。在这种系统中，结构的内部就存在未使用的“缝隙

##### 函数

C90 标准新增了函数原型，即函数的声明，描述了函数的返回值和参数。在 ANSI C 之前，C 使用的是函数声明（指明了函数名和返回类型，没有指明参数类型）推荐将函数原型、常量、预处理语句定义在头文件中，编译多个文件时，将头文件放在依赖文件前面



