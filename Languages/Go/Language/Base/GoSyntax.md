### go base syntax

#### 基本结构和基本数据类型

##### 文件名关键字标识符

* 源文件以 `.go` 为后缀名，由小写字母组成，使用下划线分隔，不支持空格和其他特殊字符源文件可以包含任意多行的代码，区分大小写，有效的标识符必须以字符（任何 UTF-8 编码的字符和 `_`）开头

* 保留字

  *关键字*

  |  break   |   default   |  func  | interface | select |
  | :------: | :---------: | :----: | :-------: | :----: |
  |   case   |    defer    |   go   |    map    | struct |
  |   chan   |    else     |  goto  |  package  | switch |
  |  const   | fallthrough |   if   |   range   |  type  |
  | continue |     for     | import |  return   |  var   |

  *预定义标识符*

  |  append   |    bool    |  byte  |  cap  |  close  | complex |
  | :-------: | :--------: | :----: | :---: | :-----: | :-----: |
  | complex64 | complex128 | uint16 | copy  |  false  | float32 |
  |  float64  |    imag    |  int   | int8  |  int16  | uint32  |
  |   int32   |   int64    |  iota  |  len  |  make   |   new   |
  |    nil    |   panic    | uint64 | print | println |  real   |
  |  recover  |   string   |  true  | uint  |  uint8  | uintptr |

* 程序一般由关键字、常量、变量、运算符、类型和函数

  程序中可能会使用这些分隔符： `()`，`[]`，`{}`

  程序中可能会使用这些标点符号：`.`，`,`，`;`，`:`，`...`

  每个语句不需要以 `;` 结尾，如果将多个语句写在同一行，必须使用 `;` 区分

##### 基本类型

* 布尔类型 bool

  布尔类型的值可以是常量 true 或 false，两个类型相同的值可以使用相等 `==` 或 `!=` 运算符来进行比较并获得一个布尔型的值，当运算符两边的值是完全相同的值的时候会返回 true，否则返回 false，并且只有在两个的值的类型相同的情况下才可以使用。

  go 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口，它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同后才可以进行比较。

  在格式化输出时，可以使用 `%t` 来表示要输出得值为布尔型

* 整型

  `int`、`uint`、`uintptr` 长度是根据运行程序所在得操作系统决定得：

  `int` 和 `uint` 在 32 位操作系统上，均使用 32 位（4 个字节），在 64 位操作系统上，均使用 64 位（8个字节）

  `uintptr` 得长度被设定为足够存放一个指针即可

  与操作系统架构无关得类型都有固定的大小：

  *整数*

  `int8`(-128~127)

  `int16`(-32768 ~ 32767)

  `int32`(-2147483648 ~ 2147483647)

  `int64`(-9223372036854775808~9223372036854775807)

  *无符号整数*

  `uint8`(0 ~ 255)

  `uint16`(0 ~ 65535)

  `uint32`(0 ~ 4294967295)

  `uint64`(0 ~ 18446744073709551615)

  go 中不允许不同类型之间的混合使用，在格式化字符串里，`%d` 用于格式化整数，`%x` 和 `%X` 用于格式化 16 进制表示的数字

* 浮点型

  Go 语言中没有 float 类型（Go 语言中只有 `float32` 和 `float64`）没有 `double` 类型。`float32 ` 精确到小数点后 7 位，`float64` 精确到小数点后 15 位。应该尽可能使用 `float64`，`math` 包中所有有关数学运算的函数都会要求接收这个类型

  `%g` 用于格式化浮点型，`%f` 输出浮点数，`%e` 输出科学计数表示法，`%0d` 输出定长的整数（开头的数字 0 是必须的）`%n.mg` 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f。

* 字符类型

  字符只是整数的特殊用例。`byte` 类型是 `uint8` 的别名，对于只占用 1 个字节的传统 ASCII  编码的字符来说，完全没问题。

* 字符串

  字符串是 UTF-8 字符的一个序列（当字符为  ASCII 码时则占用 1 个字节，其他字符根据需要占用 2 - 4 个字节）。

  字符串是一种值类型，值不可变，是字节的定长数组，Go 支持以下 2 种形式的字面值：

  解释字符串：该类字符串使用双引号括起来，其中的相关的转义字符被替换，转义字符包括：`\n`、`\r`，`\t`，`\u`，`\\`

  非解释字符串：该类字符串使用反引号括起来，支持换行

  `string` 类型的零值为长度为零的字符串，即空字符串 `""`，一般的比较运算符通过在内存中按字节比较来实现字符串的对比。使用 `len()` 来获取字符串所占的字节长度

  对于纯 ASCII 码的字符串，可以使用索引访问内容，索引从 0 开始计数。**获取字符串中某个字节的地址的行为是非法的**，使用 `+` 拼接字符串

#### 指针

Go 提供了控制数据结构的指针的能力，但不能进行指针运算。程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，取地址符是 `&`，放到一个变量前使用就会返回相应变量的内存地址，这个地址可以存储在一个叫做指针的特殊数据类型中

指针的格式化标识符是 `%p`，一个指针变量可以指向任何一个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。可以声明指针指向任何类型的值来表明它的原始性或结构性；

可以在指针类型前加上 `*` 前缀来获取指针所指向的内容，这里的 `*` 号是一个类型更改器，使用一个指针引用一个值被称为间接引用。对于一个空指针的反向引用是不合法的，并且会使程序崩溃

当一个指针被定义后没有分配到任何变量时，它的值为 `nil`，不能得到一个字面量或常量的地址

指针可以指向另一个指针，并且可以进行任意深度的嵌套，可以有多级的间接引用，但在大多数情况下这会使代码结构不清晰。

#### 常量

常量使用关键字 `const` 定义，用于存储不会改变的数据，存储在常量中的数据类型只可以是布尔型、数字型（整数、浮点、复数）和字符串型

```go
const identifier [type] = value
```

可以省略类型说明符 `[type]`，编译器可以根据变量的值来推断其类型

一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型，未定义类型的常量会在必要时根据上下文获得相关类型。

常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但所有用于计算的值必须在编译期间就能获得。在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用。

数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出，当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间引发错误

```go
// 常量运行使用并行赋值形式
const beef, two, c = "eat", 2, "veg"
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
const (
    Monday, Tuesday, Wednesday = 1, 2, 3
    Thursday, Friday, Saturday = 4, 5, 6
)
```

#### 变量

声明变量一般形式是使用 `var` 关键字

```go
var identifier type
```

当一个变量被声明后，系统自动赋予它该类型的零值：`int` 为 0，`float` 为 `0.0`，`bool` 为 false，string 为 `""`，指针为 `nil`。所有的内存在 Go 中都是经过初始化的

变量的命名规则采用小驼峰，如果全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

如果变量在函数体外声明则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用

在函数体内声明的变量称为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量

在 `if` 和 `for` 这些控制结构中声明的变量作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块判断

一般情况下，当变量 `a` 和变量 `b` 之间类型相同时，才能进行 `a = b` 的赋值，声明与赋值语句可以组合使用

```go
// 声明包级别的全局变量
var (
    HOME = os.Getenv("HOME")
    USER = os.Getenv("USER")
    GOROOT = os.Getenv("GOROOT")
)
// 函数体内声明局部变量
a := 1
```

##### 值类型和引用类型

`int`，`float`，`bool`，`string` 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值，数值和结构这些复合类型也是值类型，当使用 `=` 将一个变量的值赋值给另一个变量时，在内存中对值进行了拷贝。值类型的变量的值存储在栈中。

指针，`slices`，`maps`，`channel` 属于引用类型，被引用的变量会存储在堆中，以便进行垃圾回收

#### 控制结构

Go 提供了下面这些条件结构和分支结构：

* `if-else` 结构

  ```go
  if condition {
      
  } else if condition1 {
      
  } else {
      
  }
  ```

* `switch` 结构

  ```go
  switch var1 {
      case varl:
      case var2:
      default:
  }
  ```

  变量 `var1` 可以是任何类型，而 `var1` 和 `var2` 则可以是同类型的任意值，类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式

  可以同时测试多个可能符合条件的值，使用逗号分隔

  ```go
  case var1, var2, var3
  ```

  不需要使用 `break` 语句来表示结束，因此，程序也不会自动地去执行下一个分支的代码，如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 `fallthrough` 关键字来达到目的

  任何支持进行相等判断的类型都可以作为测试表达式的条件，包括 `int`，`string`，指针等

  ```go
  // switch 语句包含一个初始化语句
  switch a, b := x[i], y[j]; {
      case a < b: t = -1
      case a == b: t = 0
      case a > b: t = 1
  }
  ```

* `select` 结构，用于 `channel` 的选择

* for 结构

  ```go
  // 基于计数器的迭代
  for i :=0; i < 5; i++ {
      ...
  }
  // 基于条件判断的迭代
  for i >= 0 {
      
  }
  // 无限循环
  for {
      
  }
  // for-range for ix, val := range col {}
  for pos, char := range str {
      
  }
  ```

  for-range 是 go 特有的一种迭代结构，它可以迭代任何一个集合，`val` 始终为集合中对应索引的值拷贝，对它所做的任何修改都不会影响到集合中原有的值（如果 `val` 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）

  使用 `break` 退出循环，一个 `break` 的作用范围为该语句出现后的最内部的结构，它可以被用于任何形式的 for 循环（计数器，条件判断）。在 `switch` 或 `select` 语句中，`break` 语句的作用结果是跳过整个代码块，执行后续代码

  关键字 continue 只能被用于 for 循环中

Go 完全省略了 `if`，`switch`，`for` 结构中条件语句两侧的括号。`for`，`switch`，`select` 语句都可以配合标签形式的标识符使用（即某一行第一个以冒号 `:` 结尾的单词，标签是大小写敏感的，一般建议使用全部大写字母

