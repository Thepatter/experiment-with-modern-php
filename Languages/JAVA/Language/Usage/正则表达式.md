## Java 正则表达式

### 正则表达式的匹配

1.通过调用静态方法 `Pattern.compile()` 来创建一个模式

2.为每个String（或其他字符序列）调用 `pattern.matcher(CharSequence)`，以从模式中请求一个 `Matcher`

3.在结果 `Matcher` 中调用（一次或多次）方法

正则表达式用于指定字符串的模式，可以在任何需要定位匹配某种特定模式的字符串的情况下使用正则表达式。

正则表达式的常用就是测试某个特定的字符串是否与它匹配。在 Java 中，首先用表示正则表达式的字符串构建一个 `Pattern` 对象。然后从这个模式获得一个 `Matcher`，并调用它的 `matches` 方法

```java
Pattern pattern = Pattern.compile(patternSing);
Matcher matcher = pattern.matcher(input);
if (matcher.matches()) {
    m.group();
}
```

这个匹配器的输入可以实任何实现了 `CharSequence` 接口的类的对象

在编译这个模式时，可以设置一个或多个标志

```java
Pattern pattern = Pattern.compile(expression, Pattern.CASE_INSENSIVE + Pattern.UNICODE_CASE);
```

标志：

* `Pattern.CASE_INSENSITIVE` 或 `r`：匹配字符时忽略字母的大小写，默认情况下，这个标志只考虑 `US ASCII` 字符
* `Pattern.UNICODE_CASE` 或 `u`：当与 `CASE_INSENSITIVE` 组合使用时，用 `Unicode` 字母的大小写来匹配
* `Pattern.UNICODE_CHARACTER_CLASS` 或 `U`：选择 `Unicode` 字符流代替 `POSIX` ，其中蕴含了 `UNICODE_CASE`
* `Patern.MULITLINE` 或 `m`：`^` 和 `$` 匹配行的开头和结尾，而不是整个输入的开头和结尾
* `Pattern.UNIX_LINES` 或 `d`：在多行模式中匹配 `^` 和 `$` 时，只有 `\n` 被识别成行终止符
* `Pattern.DOTALL` 或 `s`：当使用这个标志时，`.` 符号匹配所有字符，包括行终止符
* `Pattern.COMMENTS` 或 `x`：空白字符和注释（从 # 到行末尾）将被忽略
* `Pattern.LITERAL`：该模式将被逐字地采纳，必须精确匹配，因字母大小写而造成的差异除外
* `Pattern.CANON_EQ`：考虑 `Unicode` 字符规范的等价

最后两个标志不能在正则表达式内部指定

如果想要在集合或流中匹配元素，可以将模式转换为谓词

```java
Stream<String> strings = ...;
Stream<String> result = strings.filter(pattern.asPredicate());
```

其结果中包含了正则表达式的所有字符串

如果正则表达式包含群组，那么 `Matcher` 对象可以揭示群组的边界。

`Matcher` 有多个 `finder` 方法，能比 `String` 的 `match` 操作提供更大的灵活性，这些方法返回布尔值，返回 `true` 意味着匹配成功，`false` 意味着匹配不成功。

* `matches()` 

  将整个字符串和模式比较，这和 `java.lang.String` 中一样。因为它匹配整个字符串

* `lookingAt()`

  只在字符串的开始匹配

* `find()`

  在字符串中匹配模式（不一定非从字符串的第一个字符开始），从字符串的首字符开始，或者如果之前已成功调用该方法，则从未能符合前面匹配的第一个字符开始匹配

匹配成功后，可以使用以下方法获取匹配信息：

* `start()，end()`

  分别返回匹配结果在字符串中的开始或结束位置

* `groupCount()`

  返回用括号括起来的捕捉组的数量，如果没有分组则返回 0

* `group(int i)`

  如果 `0 <= i <= groupCount()`，则返回当前匹配中与分组 i 匹配的字符。如果组号是 0，则表示完全匹配。`group(0)` 或 `group()` 将返回匹配的整个字符串

### 替换

Java 正则表达式提供了一些相应的替换方法，对于各种形式的替换方法而言，都需要传递替换文本或替换“右手边”这样的参数（在命令行文本编辑器的替换命令中，左手边是模式，右手边是替换文本）

* `replaceAll(newString)`

  用 `newString` 替换所有匹配的地方

* `appendReplacement(StringBuffer, newString)`

  将匹配结果之前的字符串填加到 `StringBuffer`，再将匹配结果替换为 `newString`，并追加到 `StringBuffer`。即获取替换后的 `StringBuffer`

* `appendTail(StringBuffer)`

  将上次替换过的内容连接后面未替换过的内容，并放入 `StringBuffer`（通常在调用 `appendReplacement()` 之后调用 `appendTail()`，即获取原始`StringBuffer`

  

  