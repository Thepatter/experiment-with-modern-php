## 注解

### 使用注解

注解是那些插入到源代码中使用其他工具可以对其进行处理的标签。这些工具可以在源码层次上进行操作，或者可以处理编译器在其中放置了注解的类文件。

注解不会改变程序的编译方式。Java 编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令                                                                                  

为了能够受益于注解，需要选择一个处理工具，然后向处理工具可以理解的代码中插入注解，之后运用该处理工具处理代码。注解的一些可能的用法

* 附属文件的自动生成，例如部署描述符或 `bean` 信息类
* 测试、日志、事务语义等代码的自动生成

在 Java 中，注解是当作一个修饰符来使用的，它被置于被注解项之前，中间没有分号，每一个注解的名称前都加了 `@` 符号，类似于 `Javadoc` 的注释，`Javadoc` 注释出现在注释符内部，而注解是代码的一部分

除了方法外，还可以注解类、成员以及局部变量，这些注解可以存在于任何可以放置一个像 `public` 或者 `static` 这样的修饰符的地方。还可以注解包、参数变量、类型参数和类型用法。每个注解都必须通过一个注解接口进行定义，这些接口中的方法与注解中的元素相对应。

`JUnit` 的注解 `Test` 可以用下面的接口进行定义：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
    long timeout() default 0L;
}
```

`@interface` 声明创建了一个真正的 Java 接口。处理注解的工具将接收那些实现了这个注解接口的对象。这类工具可以调用 `timeout` 方法来检索某个特定 `Test` 注解的 `timeout` 元素。注解 `Target` 和 `Retention` 是元注解。它们注解了 `Test` 注解，即将 `Test` 注解标识成一个只能运用到方法上的注解。并且当类文件载入到虚拟机的时候，仍可以保留下来。

### 注解语法

#### 注解接口

注解是由注解接口来定义的：

```java
mofifiers @interface AnnotationName {
    elementDeclaration1
    elementDeclaration2
}
```

每个元素声明都具有下面这种形式：

```java
type elementName();
```

或者

```java
type elementName() default value;
```

```java
// 下面这个注解具有两个元素：assignedTo 和 severity
public @interface BugReport {
    String assignedTo() default "[none]";
    int severity;
}
```

所有的注解接口都隐式地扩展 `java.lang.annotation.Annotation` 接口。这个接口是一个常规接口，不是一个注解接口。无法扩展注解接口，即所有的注解接口都直接扩展自 `java.lang.annotation.Annotation`

#### 注解类型用法

声明注解提供了正在被声明的项的相关信息。

### 标准注解

Java SE 在 `java.lang`、`java.lang.annotation`、`javax.annotation` 包中定义了大量的注解接口。其中四个是元注解，用于描述注解接口的行为属性，其他的三个是规则接口，用它们来注解源代码中的项

`Deprecated`   应用于全部，将项标记为过时的

`SuppressWarnings` 除了包和注解之外的所有情况，阻止某个给定类型的警告信息

`SafeVarargs` 方法和构造器，断言 `varargs` 参数是安全使用

`Override` 方法，检查该方法是否覆盖了某一个超类方法

`FunctionalInterface`接口，将接口标记为只有一个抽象方法的函数式接口

`PostConstruct` 、`PreDestroy` 方法，被标记的方法应该在构造之后或移除之前立即被调用

`Resource` 类，接口、方法、域，在类或接口上；标记为在其他地方要用到的资源，在方法或域上；为注入而标记

`Resources` 类、接口，一个资源数组

`Generated` 全部

`Target` 注解，指明可以应用这个注解的那些项

`Retention` 注解，指明这个注解可以保留多久

`Documented` 注解，指明这个注解应该包含在注解项的文档中

`Inherited` 注解，指明当这个注解应用于一个类的时候，能够自动被它的子类继承

`Repeatable` 注解，指明这个注解可以在同一个项上应用多次

#### 用于编译的注解

`@Deprecated` 注解可以被添加到任何不再鼓励使用的项上。所以，当你使用一个已过时的项时，编译器将会发出警告。这个注解与 `Javadoc` 标签 `@deprecated` 具有同等功效。

`@SuppressWarnings` 注解会告知编译器阻止特定类型的警告信息

`@Override` 这种注解只能应用到方法上。编译器会检查具有这种注解的方法是否真正覆盖了一个来自于超类的方法

`@Generated` 注解的目的是提供代码生成工具来使用。任何生成的源代码都可以被注解，从而与程序员提供的代码区分开。

#### 用于管理资源的注解

`@PostConstruct` 和 `@PreDestroy` 注解用于控制对象生命周期的环境中，如 `web` 容器和应用服务器。标记这些注解的方法应该在对象被构建之后，或者在对象被移除之前，紧接着调用

`@Resource` 注解用于资源注入。如，访问数据库的 `web` 应用。当然，数据库访问信息不应该被硬编码到 `Web` 应用中。而是应该让 `Web` 容器提供某种用户接口，以便设置连接参数和数据库资源的 `JNDI` 名字。

```java
@Resource(name="jdbc/mydb")
private DataSource source;
```

当包含这个域的对象被构造时，容器会“注入”一个对该数据源的引用

#### 元注解

`@Target` 元注解可以应用于一个注解，以限制该注解可以应用到那些项上。一条没有 `@Target` 限制的注解可以应用于任何项上。编译器将检查是否将一条注解只应用到了某个允许的项上。

`@Retention` 元注解用于指定一条注解应该保留多长时间

`@Documented` 元注解为像 `Javadoc` 这样的归档工具提供了一些提示。

`@Inherited` 元注解只能应用于对类的注解。如果一个类具有继承注解，那么它的所有子类都自动具有同样的注解，这使得创建一个与 `Serializable` 这样的标记接口具有相同运行方式的注解变得很容易

实际上，`@Serializable` 注解应该比没有任何方法的 `Serializable` 标记接口更适用。一个类之所以可以被序列化，是因为存在着对它的成员域进行读写的运行期支持，而不是因为任何面向对象的设计原则。注解比接口继承更擅长描述这一事实

