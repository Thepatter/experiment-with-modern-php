## 创建和销毁对象

### 用静态方法代替构造器

#### 生成实例

对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个**公有构造器**。类还可以提供一个公有的静态工厂方法，它只是一个返回类的实例的静态方法

#### 静态工厂方法优势

##### 静态工厂方法可以指定适当名称

一个类只能有一个带有指定签名的构造器，通过提供两个构造器，它们的参数列表只在参数类型的顺序上有所不同来规避。但面对这样的 API 调用时候实际上容易混淆。由于静态工厂方法有名称，所以它们不受上述限制。当一个类需要多个带有相同签名的构造器，就用静态工厂方法代替构造器，并且仔细地选择名称以便提出静态工厂方法之间的区别

##### 不必每次调用它们的时候都创建一个新对象

这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复使用，从而避免创建不必要的重复对象。如果程序经常请求创建相同的对象，并且创建对象的代价很高，则此可以提高性能。静态工厂方法能够为重复调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作**实例受控的类**。编写实例受控的类有几个原因。实例受控的类可以确保它是一个 Singleton 或者是不可实例化的。它还使得不可变的的值类可以确保不会存在两个相等的实例，即：当且仅当 a==b 时，a.equals(b) 才为 true。枚举类型保证了这一点

##### 可以返回原返回类型的任何子类型的对象

在选择返回对象的类时就有了更大的灵活性：

* API 可以返回对象，同时又不会使对象的类变成公有的。以这种方式隐藏实现类会使 API 变得非常简洁。这项技术适用于**基于接口**的框架，因为在这种框架中，接口为静态工厂方法提供了自然返回类型。在 Java8 之前，接口不能有静态方法，因此按照惯例，接口 Type 的静态工厂方法被放在一个名为 Types 的**不可实例化的伴生类**中。如：`Java Collections Framework` 的集合接口有 45 个工具实现，分别提供了不可修 改的集合、同步集合等。几乎所有这些实现都通过静态工厂方法在一个不可实例化的类（`java.util.Collections`）中导出。所有返回对象的类都是非公有的。

  从 Java 8 开始，接口中不能包含静态方法的这一限制成为历史，因此一般没有任何理由给接口提供一个不可实例化的伴生类。已经被放在这种类中的许多公有的静态成员，应该被放到接口中去。不过仍然有必要将这些静态方法背后的大部分实现代码，单独放进一个包级私有类中。在 Java 8 中仍要求接口的所有静态成员都必须是公有的。在 Java 9 中允许接口有私有的静态方法，但是静态域和静态成员类仍然需要是公有的

##### 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值

只要是已声明的返回类型的子类型，都是允许的。返回对象的类可能随着发型版本的不同而不同如：EnumSet没有公有构造器，只有静态工厂方法。在 OpenJDK 实现中，它返回两种子类之一的实例，具体则取决于底层枚举类型的大小：如果元素有 64 个或更少，返回一个 `RegalarEnumSet` 实例，用单个 long 进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回 `JumboEnumSet` 实例，用一个 long 数组进行支持

##### 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在

这种灵活的静态工厂方法构成了**服务提供者框架（Service Provider Framework）**的基础。服务提供者框架系统结构：**多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。服务提供着框架中有三个重要的组件：服务接口（Service Interface），这是提供者实现的；提供者注册 API （Provider Registration API），这是提供者用来注册实现的；服务访问 API （Service Access API），这是客户端用来获取服务的实例。服务访问 API 时客户端用来制定某种选择实现的条件。如果没有这样的规则，API 就会返回默认实现的一个实例，或者允许客户端遍历所有可用的实现。服务访问 API 是灵活的静态工厂，构成了服务提供者框架的基础。服务提供者接口（Service Provider Interface）是可选的，它表示产生服务接口之实例的工厂对象。如果没有服务提供者接口，实现就通过反射方式进行实例化。** 对于 JDBC 来说，Connection 就是其服务接口的一部分，`DriverManager.registerDriver` 是提供者注册 API，`DriverManager.getConnection` 是服务访问 API，`Driver` 是服务提供者接口

服务提供者框架模式有着多种变体：服务访问 API 可以返回比提供者需要的更丰富的服务接口，即桥接模式。依赖注入框架可以被看作是一个强大的服务提供者。从 Java 6 版本开始，Java 平台就提供了一个通用的服务提供者框架 `java.util.ServiceLoader`，因此不需要一般来说也不应该再自己编写了。JDBC 不用  `ServiceLoader` 因为 JDBC 早出现于 `ServiceLoader`

#### 静态工厂方法缺点

##### 类如果不含公有或者受保护的构造器，就不能被子类化

##### 静态工厂方法的第二个缺点在于，程序员很难发现它们

它们没有像构造器那样在 API 文档中明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来说，要想查明如果实例化一个类是很困难的。静态工厂方法的常用名称：

* `from` 类型转换方法，只有单个参数，返回该类型的一个相对应的实例

  `Date d = Date.from(instant)`

* `of` 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来

  `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)`

* `valueOf` 比 `from` 和 `of` 更繁琐的一种替代方法

  `BigInteger prime = BigInteger.valueOf(Integer,MAX_VALUE)`

* `instance` 或 `getInstance` 返回的实例是通过方法的参数来描述的，但是不能说与参数具有同样的值

  `StackWalker luke = StackWalker.getInstance(options)`

* `create` 或 `newInstance` 像 `instance` 和 `getInstance` 一样，但 `create` 或者  `newInstance` 能够确保每次调用都返回一个新的实例

* `getType` 像 `getInstance` 一样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法能返回的对象类型

  `FileStore fs = Files.getFileStore(path)`

* `newType` 像 `newInstance` 一样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法所返回的对象类型

  `BufferedReader br = Files.newBufferedReader(path)`

* `type` —— `getType` 和 `newType` 的简版

  `List<Complaint> litany = Collections.list(legacyLitany)`

###遇到多个构造器参数时要考虑使用构造器

静态工厂和构造器有个共同的局限性：不能很好地扩展到大量的可选参数。对于这种类：

可采用**重叠构造器（telescoping constructor）**，在这种模式下，提供的第一个构造器只有必要的参数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依次类推，最后一个构造器包含所有可选参数。重叠构造器模式虽然可行，但当有许多参数的时候，客户端代码会很难编写，并且比较难以阅读。

还可以采用**JavaBeans 模式**，在这种模式下，先调用一个无参数构造器来创建对象，然后再调用 `setter` 方法来设置每个必要的参数，以及每个相关的可选参数。但 JavaBeans 模式自身由很严重的缺点，因为构造过程被分到了几个屌用中，**在构造过程中 JavaBean 可能处于不一致的状态**类无法仅仅通过检验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象将会导致失败，这种失败与包含错误代码大相径庭，调试十分困难。**JavaBeans 模式使得把类做成不可变的可能性不复存在，需要程序员付出额外精力来确保它的线程安全**当对象的构造完成，并且不允许在冻结之前使用时，通过手工"冻结"对象可以弥补这些不足，但是这种方式十分笨拙，在实践中很少使用。此外，它甚至会在运行时导致错误，因为编译器无法确保程序员会在使用之前先调用对象上的 `freeze` 方法进行冻结

使用**Builder模式**既能保证像重叠构造器模式那样的安全性，也能保证像 JavaBeans 模式那么好的可读性。它不直接生成想要的对象，而是让客户端在 `builder` 对象上调用类似于 `setter` 的方法，来设置每个相关的可选参数。最后，客户端调用无参的 `build` 方法来生成通常时不可变的对象。这个 `builder` 通常是它构建的类的静态成员类

```java
public class NutritionFacts {
  	private final int servingSize;
  	private final int servings;
  	private final int calories;
  	private final int fat;
  	private final int sodium;
  	private final int carbohydrate;
  	public static class Builder {
      	private final int servingSize;
      	private final int servings;
      	private int calories = 0;
      	private int fat = 0;
      	private int sodium = 0;
      	private int carbohydrate = 0;
      	public Builder(int servingSize, int servings) {
          	this.servingSize = servingSize;
          	this.servings = servings;
        }
      	public Builder calories(int val) {
          	calories = val;
          	return this;
        }
      	public Builder fat(int val) {
          	fat = val;
          	return this;
        }
      	public Builder sodium(int val) {
          	sodium = val;
          	return this;
        }
      	public Builder carbohydrate(int val) {
          	carbohydrate = val;
          	return this;
        }
      	public NutritionFacts build() {
          	return new NutritionFacts(this);
        }
    }
  	private NutritionFacts(Builder builder) {
      	servingSize = builder.servingsSize;
      	servings = builder.servings;
      	calories = builder.calories;
      	fat = builder.fat;
      	sodium = builder.sodium;
      	carbohydrate = builder.carbohydrate;
    }
}
// 实例化
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35)
  													.carbohydrate(27).build();
```

`NutritionFacts` 是不可变的，所有默认参数值都单独放在一个地方。`builder` 的设值方法返回 `builder` 本身，以便把调用链接起来，得到一个流式 API。这样的客户端代码很容易编写，更为重要的是易于阅读。**Builder模式模拟了具名的可选参数**

**Build模式也适用于类层次结构**使用平行层次结构的 `builder` 时，各自嵌套在相应的类中。抽象类有抽象的 `builder`，具体类有具体的 `builder`。

```java
// 抽象类 builder
public abstract class Pizza {
		public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}
		final Set<Topping> toppings;
		abstract static class Builder<T extends Builder<T>> {
				EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);
				public T addTopping(Topping topping) {
						toppings.add(Objects.requireNonNull(topping));
						return self;
				}
				abstract Pizza build();
				protected abstract T self();
		}
		Pizza(Builder<?> builder) {
				toppings = builder.toppings.clone();
		}
}
```

`Pizza.Builder` 类型是泛型，带有一个递归型参数。它和抽象的 `self`  方法一样，允许在子类中适当地进行方法链接，不需要转换类型。这个针对 Java 缺乏 self 类型的解决方案，被称为模拟的 self 类型

```java
# 具体类 builder
public class NyPizza extends Pizza {
		public enum Size {SMALL, MEDIUM, LARGE}
		private final Size size;
		public static class Builder extends Pizza.Builder<Builder> {
				private final Size size;
				public Builder(Size size) {
						this.size = Objects.requireNonNull(size);
				}
				@Override
				public NyPizza build(this) {
						return new NyPizza(this);
				}
				@Override
				protected Builder self() {
						return this;
				}
		}
		private NyPizza(Builder builder) {
				super(builder);
				size = builder.size;
		}
}
public class Calzone extends Pizza {
		private final boolean sauceInside;
		public static class Builder extends Pizza.Builder<Builder> {
				private boolean sauceInside = false;
				public Builder sauceInside() {
						sauceInside = true;
						return this;
				}
				@Override
				public Calzone build() {
						return new Calzone(this);
				}
				@Override
				protected Builder self() {
						return this;
				}
				private Calzone(Builder builder) {
						super(builder);
						sauceInside = builder.sauceInside;
				}
		}
}
```

每个子类的构建器中的 `build` 方法，都声明返回正确的子类。在该方法中，子类方法声明返回超类中声明的返回类型的子类型，即协变返回类型。它允许客户端无需转换类型就能使用这些构建器。这些"层次化构建器"的客户端代码本质上与简单 `NutritionFacts` 构建器一样。

```java
//客户端代码，假设是在枚举常量上静态导入
NyPizza pizza = new NyPizza.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build();
Calzone calzone = new Calzone.Builder().addTopping(HAM).sauceInside().build();
```

与构造器相比，`builder` 优势在于，它可以有多个可变参数，因为 `builder` 是利用单独的方法来设置每一个参数。此外，构造器还可以将多次调用某一个方法而传入的参数集中到一个域中，如前面的调用了两次 `addTopping` 方法

`Builder` 模式十分灵活，可以利用单个 `builder` 构建多个对象。`builder` 的参数可以在调用 `build` 方法来创建对象期间进行调整，也可以随着不同的对象而改变。`builder` 的参数可以在调用 `build` 方法来创建对象期间进行调整，也可以随着不同的对象而改变。`builder` 可以自动填充某些域。

`Builder` 模式也有它自身的不足。为了创建对象，必须先创建它的构建器。虽然创建这个构建器的开销在实践中不那么明显，但是在某些十分注重性能的情况下，可能就成问题了。`Builder` 模式比重叠构造器模式更加冗长，因此它**只在有很多参数的时候才使用，比如 4 个或者更多参数。将来可能需要添加参数，如果一开始就使用构造器或者静态工厂，等到类需要多个参数时才添加构造器，就会无法控制，那些过时的构造器或者静态工厂显得十分不协调。因此最好开始就使用构建器**

如果**类的构造器或静态工厂中具有多个参数，设计这种类时，Builder 模式就是一种好的选择**，特别是当大多数参数都是可选或类型相同的时候。与使用重叠构造器相比，使用 Builder 模式的客户端代码将更易于阅读和编写，构建器也比 JavaBeans 更加安全