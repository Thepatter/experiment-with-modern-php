# 创建和销毁对象

## 用静态方法代替构造器

### 生成实例

对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个**公有构造器**。类还可以提供一个公有的静态工厂方法，它只是一个返回类的实例的静态方法

### 静态工厂方法优势

#### 静态工厂方法可以指定适当名称

一个类只能有一个带有指定签名的构造器，通过提供两个构造器，它们的参数列表只在参数类型的顺序上有所不同来规避。但面对这样的 API 调用时候实际上容易混淆。由于静态工厂方法有名称，所以它们不受上述限制。当一个类需要多个带有相同签名的构造器，就用静态工厂方法代替构造器，并且仔细地选择名称以便提出静态工厂方法之间的区别

#### 不必每次调用它们的时候都创建一个新对象

这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复使用，从而避免创建不必要的重复对象。如果程序经常请求创建相同的对象，并且创建对象的代价很高，则此可以提高性能。静态工厂方法能够为重复调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作**实例受控的类**。编写实例受控的类有几个原因。实例受控的类可以确保它是一个 Singleton 或者是不可实例化的。它还使得不可变的的值类可以确保不会存在两个相等的实例，即：当且仅当 a==b 时，a.equals(b) 才为 true。枚举类型保证了这一点

#### 可以返回原返回类型的任何子类型的对象

在选择返回对象的类时就有了更大的灵活性：

* API 可以返回对象，同时又不会使对象的类变成公有的。以这种方式隐藏实现类会使 API 变得非常简洁。这项技术适用于**基于接口**的框架，因为在这种框架中，接口为静态工厂方法提供了自然返回类型。在 Java8 之前，接口不能有静态方法，因此按照惯例，接口 Type 的静态工厂方法被放在一个名为 Types 的**不可实例化的伴生类**中。如：`Java Collections Framework` 的集合接口有 45 个工具实现，分别提供了不可修 改的集合、同步集合等。几乎所有这些实现都通过静态工厂方法在一个不可实例化的类（`java.util.Collections`）中导出。所有返回对象的类都是非公有的。

  从 Java 8 开始，接口中不能包含静态方法的这一限制成为历史，因此一般没有任何理由给接口提供一个不可实例化的伴生类。已经被放在这种类中的许多公有的静态成员，应该被放到接口中去。不过仍然有必要将这些静态方法背后的大部分实现代码，单独放进一个包级私有类中。在 Java 8 中仍要求接口的所有静态成员都必须是公有的。在 Java 9 中允许接口有私有的静态方法，但是静态域和静态成员类仍然需要是公有的

#### 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值

只要是已声明的返回类型的子类型，都是允许的。返回对象的类可能随着发型版本的不同而不同如：EnumSet没有公有构造器，只有静态工厂方法。在 OpenJDK 实现中，它返回两种子类之一的实例，具体则取决于底层枚举类型的大小：如果元素有 64 个或更少，返回一个 `RegalarEnumSet` 实例，用单个 long 进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回 `JumboEnumSet` 实例，用一个 long 数组进行支持

#### 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在

这种灵活的静态工厂方法构成了**服务提供者框架（Service Provider Framework）**的基础。服务提供者框架系统结构：**多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。服务提供着框架中有三个重要的组件：服务接口（Service Interface），这是提供者实现的；提供者注册 API （Provider Registration API），这是提供者用来注册实现的；服务访问 API （Service Access API），这是客户端用来获取服务的实例。服务访问 API 时客户端用来制定某种选择实现的条件。如果没有这样的规则，API 就会返回默认实现的一个实例，或者允许客户端遍历所有可用的实现。服务访问 API 是灵活的静态工厂，构成了服务提供者框架的基础。服务提供者接口（Service Provider Interface）是可选的，它表示产生服务接口之实例的工厂对象。如果没有服务提供者接口，实现就通过反射方式进行实例化。** 对于 JDBC 来说，Connection 就是其服务接口的一部分，`DriverManager.registerDriver` 是提供者注册 API，`DriverManager.getConnection` 是服务访问 API，`Driver` 是服务提供者接口

服务提供者框架模式有着多种变体：服务访问 API 可以返回比提供者需要的更丰富的服务接口，即桥接模式。依赖注入框架可以被看作是一个强大的服务提供者。从 Java 6 版本开始，Java 平台就提供了一个通用的服务提供者框架 `java.util.ServiceLoader`，因此不需要一般来说也不应该再自己编写了。JDBC 不用  `ServiceLoader` 因为 JDBC 早出现于 `ServiceLoader`

### 静态工厂方法缺点

#### 类如果不含公有或者受保护的构造器，就不能被子类化

#### 静态工厂方法的第二个缺点在于，程序员很难发现它们

它们没有像构造器那样在 API 文档中明确标识出来。因此对于提供了静态工厂方法而不是构造器的类来说，要想查明如果实例化一个类是很困难的。静态工厂方法的常用名称：

* `from` 类型转换方法，只有单个参数，返回该类型的一个相对应的实例

  `Date d = Date.from(instant)`

* `of` 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来

  `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)`

* `valueOf` 比 `from` 和 `of` 更繁琐的一种替代方法

  `BigInteger prime = BigInteger.valueOf(Integer,MAX_VALUE)`

* `instance` 或 `getInstance` 返回的实例是通过方法的参数来描述的，但是不能说与参数具有同样的值

  `StackWalker luke = StackWalker.getInstance(options)`

* `create` 或 `newInstance` 像 `instance` 和 `getInstance` 一样，但 `create` 或者  `newInstance` 能够确保每次调用都返回一个新的实例

* `getType` 像 `getInstance` 一样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法能返回的对象类型

  `FileStore fs = Files.getFileStore(path)`

* `newType` 像 `newInstance` 一样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法所返回的对象类型

  `BufferedReader br = Files.newBufferedReader(path)`

* `type` —— `getType` 和 `newType` 的简版

  `List<Complaint> litany = Collections.list(legacyLitany)`

  