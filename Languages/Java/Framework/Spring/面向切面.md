### 面向切面

#### 切面概述

##### 横切关注点

面向切面编程（AOP）允许把遍布应用各处的功能分离出来形成可重用的组件。面向切面编程往往被定义为促使软件系统实现关注点的分离一项技术。

系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点（cross-cutting concern），因为它们会跨越系统的多个组件。

通常，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面编程所要解决问题，DI 有助于应用对象之间的解耦，而 AOP 可以实现横切关注点与它们所影响对象之间的解耦

如果将这样关注点分散到多个组件中去，代码将会带来双重的复杂性

* 实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果要改变这些关注点的逻辑，必须修改各个模块中的相关实现。即使把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中

* 组件会因为那些与自身核心业务无关的代码而变得混乱。一个业务功能应该只关注如何实现业务，而不应该关注它是不是安全的或者是否需要支持事务

  ​							*模块服务的复杂性*

![](Images/模块复杂性.png)

左边的业务对象与系统级服务结合得过于紧密。每个对象不但要知道它需要记日志、进行安全控制和参与事务，还有亲自执行这些服务

AOP 能够使这些服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。AOP 能够确保 POJO 的简单性。

​				*利用AOP，系统范围内的关注点覆盖在它们所影响组件之上*

![](Images/利用AOP降低复杂.png)

可以把切面想象为覆盖在很多组件之上的一个外壳。应用是由那些实现各自业务功能的模块组成的。借助 AOP，可以使用各种功能层去包裹核心业务层。这些层以声明的方式灵活地应用到系统中，核心应用甚至根本不知道它们的存在。可以将安全、事务、日志关注点与核心业务逻辑相分离

##### 快速使用

Spring 的 AOP 配置命名空间声明切面。首先需要把 Minstrel 声明为一个 bean

```xml
<bean id="minstrel" class="com.springinaction.knights.Minstrel">
	<constructor-arg value="#{T(System).out}" />
<bean>
```

```xml
<aop:config>
    <!-- 应用该 bean -->
	<aop:aspect ref="minstrel">
         <!-- 定义 embark 切入点，配置 expression 属性来选择所应用的通知，语法采用 AspectJ 的切点语法 -->
		<aop:pointcut id="embark" expression="execution(* *.embarkOnQuest(..)) "/>
         <!-- 前置通知：在 embarkOnQuest() 方法之前调用 minstrel 的 singBeforeQuest() 方法 -->
		<aop:before pointcut-ref="embark" method="singBeforeQuest"/>
         <!-- 后置通知: 在 embarkOnQuest() 方法执行后调用 singAfterQuest() 方法 -->
		<aop:after pointcut-ref="embark" method="singAfterQuest" />
    </aop:aspect>
</aop:config>
```

此时，Spring 在骑士执行探险任务前后会调用 Minstrel 的 singBeforeQuest() 和 singAfterQuest() 方法

通过少量的 XML 配置，就可以把 Minstrel 声明为一个 Spring 切面。首先，Minstrel 仍然是一个 POJO，没有任何代码表明它要被作为一个切面使用。当按照上面那样进行配置后，在 Spring 的上下文中，Minstrel 实际上已经变成一个切面了。Minstrel 可以被应用到 BraveKnight 中，而 BraveKnight 不需要显式地调用它。实际上，BraveKnight 完全不知道 Minstrel 的存在

#### 面向切面的 Spring

##### AOP 术语

AOP 常用术语有：通知（advice）、切点（pointcut）、连接点（join point）。

通知包含了需要用于多个应用对象横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（有哪些切点）。其中关键的概念是切点定义了哪些连接点会得到通知

###### 通知 Advice

切面的工作被称为通知，通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题（之前，之后，异常，之前之后）。

Spring 切面可以应用 5 种类型的通知

* Before

  前置通知，在目标方法被调用之前调用通知功能

* After

  后置通知，在目标方法完成之后调用通知，此时不会关心方法的输出是什么

* After-returning

  返回通知，在目标方法成功执行之后调用通知

* After-throwing

  异常通知，在目标方法抛出异常后调用通知

* Around

  环绕通知，通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为

###### 连接点 Join point

连接点是在应用执行过程种能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。

###### 切点 Pointcut

一个切面并不需要通知应用的所有连接点。切点有助于缩小切面所通知的连接点的范围。如果说”通知“定义了切面的 “什么“和”何时“，切点定义了”何处“。

切点的定义会匹配通知所要织入的一个或多个连接点。通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些 AOP 框架允许创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知

###### 切面 Aspect

切面是通知和切点的结合。通知和切点共同定义了切面的全部内容（它是什么，在何处和何时完成其功能）

###### 引入 Introduction

引入允许向现有的类添加新方法或属性。

###### 织入 Weaving

织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：

* 编译期

  切面在目标类编译时被织入。需要特殊的编译器。AspectJ  的织入编译器就是以这种方式织入切面的

* 类加载期

  切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5 的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面

* 运行期

  切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的

##### Spring 对 AOP 的支持

并非所有的 AOP 框架都是相同的，它们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别应用通知，而另一些只支持与方法调用相关的连接点。它们织入切面的方式和世纪也有所不同，但创建切点来定义切面所织入的连接点是 AOP 框架的基本功能。

Spring 对 AOP 的支持在很多方面借鉴了 AspectJ 项目，Spring 提供了 4 种类型的 AOP 支持：

* 基于代理的经典 Spring AOP
* 纯 POJO 切面
* @AspectJ 注解驱动的切面
* 注入式 AspectJ 切面（适用于 Spring 各版本）

<u>前三种都是 Spring AOP 实现的变体，Spring AOP 构建在动态代理基础上，因此 Spring 对 AOP 支持局限于方法拦截</u>

借助 Spring 的 AOP 命名空间，可以将纯 POJO 转换为切面。实际上，这些 POJO 只是提供了满足切点条件时所要调用的方法。这种技术需要 XML 配置，这是声明式将对象转换为切面的简便方式。

Spring 借鉴了 AspectJ 的切面，以提供注解驱动的 AOP。本质上，它依然是  Spring 基于代理的 AOP，但是编程模型几乎与编写成熟的 AspectJ 注解切面完全一致。这种 AOP 风格的好处在于能够不使用 XML 来完成功能。

如果 AOP 需求超过了简单的方法调用（如构造器或属性拦截），那么需要考虑使用 AspectJ 来实现切面。在这种情况下，第四种类型能够帮助将值注入到 AspectJ 驱动的切面种。

* 使用 POJO 编写通知

  Spring 所创建的通知都是用标准的 Java 类编写的，而且定义通知所应用的切点通常会使用注解或在 Spring 配置文件里采用  XML 来编写

* 运行时通知对象

  通过在代理类中包裹切面，Spring 在运行期把切面植入到 Spring 管理的 bean 中。代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑。

  直到应用需要被代理的 bean 时，Spring 才创建代理对象。如果使用的是  ApplicationContext ，在 ApplicationContext 从 BeanFactory 中加载所有 bean 的时候，Spring 才会创建被代理的对象。因为 Spring 运行时才创建代理对象，所以不需要特殊的编译器来织入 Spring AOP 的切面

* 只支持方法级别的连接点

  通过使用各种 AOP 方案可以支持多种连接点模型。因为 Spring 基于动态代理，所以 Spring 只支持方法连接点。Spring 缺少对字段连接点的支持，无法创建细粒度的通知，不支持构造器连接点。无法在 bean 创建时应用通知。

#### Spring 中使用 AOP

##### AspectJ 注解

###### 通过切点来选择连接点

切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面的最级别元素。

在 Spring AOP 中，要使用 AspectJ 的切点表达式语言来定义切点。Spring 仅支持 AspectJ 切点指示器（pointcut designator）的一个子集。

*Spring借助AspectJ的切点表达式语言来定义Spring切面，Spring AOP 所支持的 AspectJ 切点指示器*

| AspectJ 指示器 |                             描述                             |
| :------------: | :----------------------------------------------------------: |
|     arg()      |            限制连接点匹配参数为指定类型的执行方法            |
|    @args()     |          限制连接点匹配参数由指定注解标注的执行方法          |
|  execution()   |                  用于匹配是连接点的执行方法                  |
|     this()     |      限制连接点匹配 AOP 代理的 bean 引用为指定类型的类       |
|     target     |             限制连接点匹配目标对象为指定类型的类             |
|   @target()    | 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 |
|    within()    |                   限制连接点匹配指定的类型                   |
|    @within     | 限制连接点匹配指定注解所标注的类型（当使用 Spring AOP时，方法定义在由指定的注解所标注的类里） |
|  @annotation   |                 限定匹配带有指定注解的连接点                 |

在Spring中尝试使用AspectJ其他指示器时，将会抛出 *IllegalArgumentException* 异常。只有 execution 指示器是实际执行匹配的，而其他执行器都是用来限制匹配的。

###### 编写切点

```java
package concert;
public interface Performance {
    public void perform();
}
```

```xml
<!-- 使用 execution 指示器选择 Performance 的 perform() 方法。方法表达式以 * 号开始，表明了不关心返回值的类型，指定了全限定类名和方法名。对于方法参数列表，使用 .. 表明切点要选择任意的 perform() 方法，无论该方法的入参是什么 -->
execution(* concert.Performance.perform(..))
<!-- 配置的切点仅匹配 concert 包，使用 within() 指示器来限制匹配 -->
execution(* concert.Performance.perform(..)) and within(concert.*)
```

###### 在切点中选择 bean

Spring 还引入了一个新的 bean() 指示器，它允许在切点表达式中使用 bean 的 ID 来标识 bean。bean() 使用 bean Id 或 bean 名称来限制切点只匹配特定的 bean

```xml
// 在执行 Performance 的 perform() 方法时应用通知，但限定 bean 的 id 为 woodstock
execution(* concert.Performance.perform()) and bean('woodstock')
```

##### 使用注解创建切面

###### @AspectJ 定义切面

```java
package concert;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
@AspectJ
public class Audience {
    @Before("execution(** concert.Performance.perfore(...))") // 表演之前
    public void silenceCeCellPhones() {
        System.out.println("Silencing cell phones");
    }
    @Before("execution(** concert.Performance.perform(..))") // 表演之前
    public void takeSeats() {
        System.out.println("Taking seats");
    }
    @AfterReturning("execution(** concert.Performance.perform(..))") // 表演之后
    public void appliause() {
        System.out.println("CLAP CLAP CLAP!!!");
    }
    @AfterThrowing("execution(** concert.Performance.perform(...))") // 表演失败之后
    public void demandRefund() {
        System.out.println("Demanding a refund");
    }
}
```

Audience 类使用 @AspectJ 注解进行标注。表明这不仅是 POJO 还是一个切面。Audience 类中的方法都使用注解来定义切面的具体行为。

*Spring使用AspectJ注解来声明*

|      注解       |                   通知                   |
| :-------------: | :--------------------------------------: |
|     @After      | 通知方法会在目标方法返回或抛出异常后调用 |
| @AfterReturning |      通知方法会在目标方法返回后调用      |
| @AfterThrowing  |    通知方法会在目标方法抛出异常后调用    |
|     @Around     |       通知方法会将目标方法封装起来       |
|     @Before     |     通知方法会在目标方法调用之前执行     |

###### @Around 定义环绕通知

环绕通知是最为强大的通知类型。它能让逻辑将被通知的目标方法安全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。

```java
package concert;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class Audience {
    @Pointcut("execution(** concert.Performance.perform(..))") // 定义命名的切点
    public void performance() {}
    @Around("performance()")  //  watchPerformance() 方法会作为 performance() 切点的环绕通知
    // ProceedingJoinPoint 作为参数，这个对象必须要有，要在通知中通过它来调用被通知的方法。通知方法中可以做任何事，当要将控制器交给被通知的方法时，它需要调用 ProceedingJoinPoint 的 proceed() 方法。如果不调用 proceed() 方法，通知实际上会阻塞对被通知方法的调用。可以不调用 proceed() 方法，从而阻塞对被通知方法的访问，与之类似，也可以在通知中对它进行多次调用（如重试逻辑）
    public void watchPerformance(ProceedingJoinPoint jp) {
        try {
            System.out.println("Silencing cell phones");
            System.out.println("Taking seats");
            jp.proceed();
            System.out.println("CLAP CLAP CLAP!!!");
        } catch (Throwable e) {
            System.out.println("Deamanding a refund");
        }
    }
}
```

###### @Pointcut 声明切点表达式

@Pointcut 注解能够在一个 @AspectJ 切面内定义可重用的切点。

```java
package concert;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThhrowing;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
@AspectJ
public class Audience {
    @Pointcut("execution(** concert.Performance.perform(..))") // 定义命名的切点
    public void performance() {}
    @Before("performance()") // 表演之前
    public void takeSeats() {
        System.out.println("Taking seats");
    }
    @Before（"performance()")
    public void silenceCallPhones() {
        System.out.println("Silencing cell phones");
    }
    @AfterReturning("performance()")
    public void applause() {
        System.out.println("CLAP CLAP CLAP!!!!");
    }
    @AfterThrowing("performance()")
    public void deamndRefund() {
        System.out.println("Demanding a refund");
    }
}
```

在 Audience 中，performance() 方法使用了 @Pointcut 注解。为 @Pointcut 注解设置的值是一个切点表达式，通过在 performance() 方法上添加 @Pointcut 注解，这样可以在任何的切点表达式中使用 performance()。

performance() 方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供 @Pointcut 注解依附。除了注解和没有实际操作的 performance() 方法，Audience 类依然是一个 POJO，只不过通过注解表明会作为切面使用。

##### 通过注解引入新功能

Java 不是动态语言，一旦类编译完成了，就很难为该类添加新的功能了。利用 AOP，切面可以为 Spring bean 添加新方法。

在 Spring 中，切面只是实现了它们所包装 bean 相同接口的代理。当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，一个 bean 的实现被拆分到多个类中

@DeclareParents 注解将接口引入 bean 中

* value

  指定了那种类型的 bean 要引入该接口

* defaultImpl

  指定了为引入功能提供实现的类

Spring 的自动代理机制将会获取到它的声明，当 Spring 发现一个 bean 使用 @Aspect 注解时，Spring 就会创建一个代理，然后将调用委托给被代理的 bean 或被引入的实现，这取决于调用的方法属于被代理的 bean 还是属于被引入的接口

在 Spring 中，注解和自动代理提供了一种便利方式来创建切面，并且只涉及到最少的配置，但是，面向注解的切面声明有一个明显的劣势，必须能够为类添加注解

##### 使用切面

###### 使用注解启用自动代理

```java
package concert;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentSacn;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
@Configuration
@EnableAspectJAutoProxy // 启用自动代理功能
@ComponentScan
public class ConcertConfig {
    // 声明 Audience bean
    @Bean
    public Audience audience() {
        return new Audience();
    }
}
```

###### 使用 XML 装配

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
    <context:component-scan base-package="concert" />
    <!-- 启用 AspectJ 自动代理 -->
    <aop:aspectj-autoproxy/>
    <!-- 声明 Audience bean -->
    <bean class="concert.Auience" />
</beans>
```

不论使用 JavaConfig 还是 XML，AspectJ 自动代理都会为使用 @Aspect 注解的 bean 创建一个代理，这个代理会围绕所有该切面的切点所匹配的 bean。

Spring 的 AspectJ 自动代理仅仅使用 @AspectJ 作为创建切面的指导，切面依然是基于代理的。本质上，依然是 Spring 基于代理的切面。意味着尽管使用的是  @AspectJ 注解，但仍然限于代理方法的调用。如果想利用 AspectJ 的所有能力，必须在运行时使用 AspectJ 并且不依赖 Spring 来创建基于代理的切面

*Spring 的 aop 命名空间中，提供了多个元素来在 XML 中声明切面*

|       AOP 配置元素        |                             用途                             |
| :-----------------------: | :----------------------------------------------------------: |
|      `<aop:advisor>`      |                       定义 AOP 通知器                        |
|       `<aop:after>`       |      定义 AOP 后置通知（不管被通知的方法是否执行成功）       |
|  `<aop:after-returning>`  |                      定义 AOP 返回通知                       |
|  `<aop:after-throwing>`   |                      定义 AOP 异常通知                       |
|      `<aop:around>`       |                      定义 AOP 环绕通知                       |
|      `<aop:aspect>`       |                        定义其一个切面                        |
| `<aop:aspectj-autoproxy>` |                 启用 @AspectJ 注解驱动的切面                 |
|      `<aop:before>`       |                    定义一个 AOP 前置通知                     |
|      `<aop:config>`       | 顶层的 AOP 配置元素，大多数的 `<aop:*>` 元素必须包含在 `<aop:config>` 元素内 |
|  `<aop:declare-parents>`  |           以透明的方式为被通知的对象引入额外的接口           |
|     `<aop:pointcut>`      |                         定义一个切点                         |

*通过 XML 将无注解的 Audience 声明为切面*

```xml
<aop:config>
    <!-- 声明切面，引用 audience Bean，ref 元素引用的 bean 提供了切面中通知所调用的方法 -->
    <aop:aspect ref="audience">
        <!-- 定义 id 为 performance 的切点，并在通知中引用该切点  -->
        <aop:pointcut id="performance" expression="execution(** concert.Performance.perform(..))"/>
        <!-- 定义了匹配切点的方法执行之前调用前置通知方法 taksSeats 和 solenceCellPhones  -->
    	<aop:before pointcut="performance" method="solenceCellPhones"/>
        <aop:before pointcut="performance" method="takeSeats"/>
        <!-- 定义了一个返回通知，在切点所匹配的方法调用之后再调用 applause 方法 -->
        <aop:after-returning pointcut="performance" method="applause"/>
        <!-- 定义了异常通知，如果所匹配的方法执行时抛出任何异常，都会调用 demandRefund() 方法 -->
        <aop:after-throwing pointcut="performance" method="demandRefund"/>
        <!-- 声明环绕通知 -->
        <aop:around pointcut-ref="performance" method="watchPerformance"/>
    </aop:aspect>
</aop:config>
```

大多数 AOP 配置元素必须在 config 元素的上下文内使用，把 bean 声明为一个切面时，总是从 config 元素开始配置。在 config 元素内，可以声明一个或多个通知器、切面或切点。

pointcut 元素定义的切点可以被同一个 aspect 元素之内的所有通知元素引用。如果想让定义的切点能够在多个切面使用，可以将 pointcut 元素放在 config 元素的范围内

