### 访问数据库

#### RDBMS

##### MySQL

###### 依赖

* mvn

  ```xml
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.18</version>
  </dependency>
  ```

###### 配置

```properties
spring.datasource.url = jdbc:mysql://localhost:3306/web
spring.datasource.username = root
spring.datasource.password = secret
spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver
```

##### SQL-Server

###### 依赖

* mvn

  ```xml
  <dependency>
  	<groupId>com.microsoft.sqlserver</groupId>
      <artifactId>mssql-jdbc</artifactId>
      <scope>runtime</scope>
  </dependency>
  ```

###### 配置

```properties
spring.datasource.url = jdbc:sqlserver://localhost:1433;databaseName=web
spring.datasource.username=root
spring.datasource.password=secret
spring.datasource.driver-class-name=com.microsoft.sqlseerver.jdbc.SQLServerDriver
```

#### NOSQL

##### Mongo

###### 依赖

* mvn

  ```xml
  <dependencies>
  	<dependency>
      	<groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-mongodb</artifactId>
      </dependency>
  </dependencies>
  ```

###### 配置

```properties
spring.data.mongodb.uri = mongodb://localhost:27017/test
# 有密码
spring.data.monogdb.url = mongodb://user:pass@localhost:27017/test
```

##### neo4j

###### 依赖

* mvn

  ```xml
  <dependency>
  	<groupId>org.springframework.boot</group>
  	<artifactId>spring-boot-startter-data-neo4j</artifactId>
  </dependency>
  ```

###### 配置

```properties
spring.data.neo4j.uri = http://localhost:7474
spring.data.neo4j.username = root
spring.data.neo4j.password = password
```

##### redis

###### 依赖

* mvn

  ```xml
  <dependency>
  	<groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>
  ```

###### 配置

```properties
spring.redis.database = 0
spring.redis.host = localhost
spring.redis.port = 6379
spring.redis.password = 
# 连接池最大连接数
spring.redis.pool.max-active = 
# 连接池最大阻塞等待时间，负值无限制
spring.redis.pool.max-wait = -1
# 连接池最大空闲连接
spring.redis.pool.max-idle = 
# 连接池中的最小空闲连接
spring.redis.pool.min-idle = 
# 连接超时
spring.redis.timeout = 
```

###### 使用

使用泛型 *RedisTemplate*，必须采用 spring 生成 bean 方式，否则不能使用，设置一个包装类

```java
@Service
public class RedisService<String, T extends Serializable> {
    @Autowired
    private RedisTemplate<String, T> redisTemplate;
    public void set(String key, T value, Class<T> tClass) {
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<>(tClass));
        ValueOperations<String, T> vo = redisTemplate.opsForValue();
        vo.set(key, value);
    }
    public T get(String key) {
        ValueOperations<String, T> vo = redisTemplate.opsForValue();
        return vo.get(key);
    }
}
```

使用

```java
@GetMapping("/memebers/{id}")
public Object show(@PathVariable int id) throws NoSuchAlgorithmException {
    HashString hashString = new HashString();
    Member member = redisService.get(hashString.StringHashHex(String.valueOf(id), Algorithm.SHA256));
    if (member == null) {
        member = repository.getOne(id);
        redisService.set(hashString.StringHashHex(String.valueOf(id), Algorithm.SHA256), member, Member.class);
    }
    return member;
}
```

##### memcached

###### 依赖

* mvn

  ```xml
  <dependency>
  	<groupId>net.spy</groupId>
      <artifactId>spymemcached</artifactId>
      <version>2.12.2</version>
  </dependency>
  ```

###### 配置

```xml
memcache.ip = localhost
memchache.prot = 11211
```

#### 使用 JDBC

##### 配置

###### 依赖

* mvn

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jdbc</artifactId>
  </dependency>
  ```
  
  配置 jdbc 依赖和对应数据库依赖，starter-jdbc 使用 hikari 连接池

###### 配置数据源

spring boot 默认配置数据源无法使用，需要自定义数据源 bean

```java
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource(Environment environment) {
        HikariDataSource hikariDataSource = new HikariDataSource();
        hikariDataSource.setJdbcUrl(environment.getProperty("spring.datasource.url"));
        hikariDataSource.setUsername(environment.getProperty("spring.datasource.username"));
        hikariDataSource.setPassword(environment.getProperty("spring.datasource.password"));
        hikariDataSource.setDriverClassName(environment.getProperty("spring.datasource.driver-class-name"));
        return hikariDataSource;
    }
}
```

##### 简单使用

* 普通

  ```java
  @RestController
  public class UserController {
      @Autowired
      private JdbcTemplate jdbcTemplate;
      @PostMapping("/users/user")
      public int store(@RequestParam String firstName, @RequestParam String lastName, @RequestParam String phone) {
          return jdbcTemplate.update("INSERT INTO users ( first_name, last_name, phone) values (?, ?, ?)", firstName, lastName, phone);
      }
      
  }
  ```

* 查询支持返回 list，map（单个map），object 等

  ```java
  @GetMapping("/users/page/{page}")
      public List<User> get(@PathVariable int page, @RequestParam int perPage) {
          String sql = "select * from users limit ?, ?";
          return jdbcTemplate.query(sql, new Object[]{page * perPage - perPage, perPage}, new BeanPropertyRowMapper<>(User.class));
      }
  
      @GetMapping("/users/index/{id}")
      public Map<String, Object> index(@PathVariable int id) {
          try {
              return jdbcTemplate.queryForMap("select * from users where id = ?", id);
          } catch (EmptyResultDataAccessException ignore) {
              return null;
          }
      }
  
      @GetMapping("/users/single/{id}")
      public User singleUser(@PathVariable int id) {
          String sql = "select * from users where id = ?";
          try {
              return jdbcTemplate.queryForObject(sql, new Object[]{id}, new BeanPropertyRowMapper<>(User.class));
          } catch (EmptyResultDataAccessException ignore) {
              return null;
          }
      }
  ```

#### 使用 JPA

JPA 是 Java Persostemce  API 的简称，是 JCP 组织发布的 Java EE 标准，是面向对象查询语言，定义了独特的 JPQL（Java Persistence Query Language），是一种针对实例的查询语言，无论是查询还是修改，全部操作的都是对象实体

##### 配置

###### 依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>sprint-boot-starter-web</artifactId>
</dependency>
```

###### 配置

```properties
##validate  加载hibernate时，验证创建数据库表结构
##create   每次加载hibernate，重新创建数据库表结构，这就是导致数据库表数据丢失的原因。
##create-drop        加载hibernate时创建，退出是删除表结构
##update                 加载hibernate自动更新数据库结构
##none  启动时不做任何操作
spring.jpa.hibernate.ddl-auto=create
##控制台打印sql
spring.jpa.show-sql=true
```

##### 使用

###### 定义实体

使用 @Entity 注解定义 POJO 为实体

```java
@Entity(name = "books") // 指定表名
public class Book {
    @Id  // 指定注解与自增
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    @Column // 指定字段
	private String author;
}
```

###### 定义 Repostiory 接口

继承 *JpaRepository<T, Id>* 泛型接口，JPA 支持接口中自定义方法使用注解执行 sql

```java
public interface BookRepository extends JpaRepository<Book, Integer> {
    @Query("select b from books b where b.author = :author")
    List<Book> findAuthorBooks(@Param("author") String author);
}
```

###### curd

```java
@RestController
public class BookController {
    @Autowired
    private BookRepository bookRepository;

    @PostMapping("/books/book")
    public Book store(@RequestParam String author) {
        Book book = new Book();
        book.setAuthor(author);
        return bookRepository.save(book);
    }

    @PatchMapping("/books/{id}")
    public Book update(@PathVariable int id, @RequestParam String author) {
        Book book = bookRepository.getOne(id);
        book.setAuthor(author);
        return bookRepository.save(book);
    }

    @DeleteMapping("/books/{id}")
    public void destroy(@PathVariable int id) {
        bookRepository.deleteById(id);
    }

    @GetMapping("/books/book/{id}")
    public Optional<Book> one(@PathVariable int id) {
        return bookRepository.findById(id);
    }

    @GetMapping("/books/index/{page}")
    public Page<Book> index(@PathVariable int page, @RequestParam int perPage) {
        Pageable pageable = PageRequest.of(page, perPage);
        return bookRepository.findAll(pageable);
    }
}
```

#### 使用 MyBatis

MyBatis 是一款优秀的持久层框架，支持定制化 SQL，存储过程和高级映射，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集，可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 java 的 POJO 映射成数据库中的记录

##### 配置

###### 依赖

* mvn

  ```xml
  <dependency>
  	<groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
  </dependency>
  ```

###### 配置

```properties
##检查 mybatis 配置是否存在，一般命名为 mybatis-config.xml
mybatis.check-config-location =true
##配置文件位置
mybatis.config-location=classpath:mybatis/mybatis-config.xml
## mapper xml 文件地址
mybatis.mapper-locations=classpath*:mapper/*.xml
##日志级别
logging.level.com.springboot.dao.UserMapper=debug
```

##### 使用

1. 建立 Mapper 接口

   ```java
   @Mapper
   public interface UserMapper {
    	// 使用 xml mapper
       User findUserByUsername(String username);
       // 使用注解
       @Select("select * from users")
       List<User> findAll();
   }
   ```

2. 配置 mapper.xml 

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
   <mapper namespace="web.boot.action.dao.UserMapper">
       <resultMap id="user" type="web.boot.action.entity.User"/>
       <parameterMap id="user" type="web.boot.action.entity.User"/>
       <select id="findUserByUsername" parameterType="String" resultMap="user">
           SELECT * FROM users WHERE username=#{1}
       </select>
   </mapper>
   ```

3. 使用

   ```java
   @RestController
   public class UserMyBatisController {
       @Autowired
       private UserMapper userMapper;
       @GetMapping("/user/mybatis/username")
       public User getUser(@RequestParam String username) {
           return userMapper.findUserByUsername(username);
       }
       @GetMapping("/user/mybatis/list")
       public List<User> index() {
           return userMapper.findAll();
       }
   }
   ```

   

