### 面向对象编程

#### 结构

##### 对象

###### 对象特性

* 对象的行为（behavior）

  可以对对象进行的操作

* 对象的状态（state）

  每个对象都保存着描述当前特征的信息。行为改变状态

* 对象的标识（identity）

  每个对象都有一个唯一的身份

* 变量作用域

  实例变量和静态变量的作用域是整个类，如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量将被隐藏

* 在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，**仍会在任何方法（包括构造器）被调用之前得到初始化**

###### 实例化

1. 加载器加载类的字节码
2. 如果类存在基类，对它继续进行加载
3. 根基类中的 static 初始化会被执行，然后是下一个导出类
4. 类加载完毕，开始创建对象
5. 对象中所有的基本类型都会被设为默认值，对象引用被设为 null（通过将对象内存设为二进制0值）
6. 基类的构造器会被调用（基类构造器以相同的顺序来经历相同的过程）
7. 基类构造器完成后，实例变量按其次序被初始化
8. 构造器的其余部分被执行

构造器应该尽可能简单，如果可以避免调用其他方法，在构造器内唯一能够安全调用的那些方法是基类中的 final 方法

###### 对象析构与 finalize 方法

finalize 被设计成在对象被垃圾收集前调用，finalize 的执行是和垃圾收集关联在一起的，一旦实现了非空的 finalize 方法，就会导致相应对象回收呈现数量级上的变慢。finalize 会生吞资源回收时的出错信息，推荐资源用完即显式释放，或者利用资源池来重用

java 不支持析构器。可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源，因为很难知道这个方法什么时候才能够调用。调用 *System*.runFinalizersOnExit(true) 能够确保 finalizer 方法在 java 关闭前被调用。不过这个方法并不安全，替代的方法是使用方法 *Runtime*.addShutdownHook 添加关闭钩（shutdown hook）。在 jdk9 中 finalize 方法标注为 @Deprecated

Java 平台目前在逐步使用 `java.lang.ref.Cleaner` 来替换掉原有的 finalize 实现。Cleaner 实现利用了幻象引用。利用幻象引用和引用队列，可以保证对象被彻底销毁前做一些类似资源回收的工作（关闭文件描述符等），它比 finalize 更加轻量，更加可靠，每个 Cleaner 的操作都是独立的，它有自己的运行线程，可以避免意外死锁等问题，实践中可以为模块构建一个 Cleaner，然后实现相应的清理逻辑

```java
public class CleaningExample implements AutoCloseable {
    // cleaner 实现
    private static final Cleaner cleaner = Cleaner.create();
    static class State implements Runnable {
        @Override
        public void run() {
            // 清理逻辑，最多执行一次
        }
    }
    private final Cleaner.Cleanable cleanable;
    private final State state;
    public CleaningExample() {
        this.state = new State();
        this.cleanable = cleaner.register(this, state);
    }
    @Override
    public void close() throws Exception {
        cleanable.clean();
    }
}
```

从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然有限，如果由于其他原因导致幻象引用堆积，同样会出现问题，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收

###### 对象引用

* 对象是通过引用变量来访问的，该变量包含对对象的引用，从本质上来说，一个类是一个程序员定义的类型。类是一种引用类型对象引用变量中只包含了对该对象的引用，严格来说，对象引用变量和对象是不同的，但是大多数情况下，这种差异是可以忽略的
* 给方法传递一个对象，是将对象的引用传递给方法
* 对象引用存储的是对象的存储地址

引用类型安装对象的不同可达性（reachable）状态和对垃圾收集的影响，分为：

*   强引用（Strong Reference）

    普通对象引用，只要还有强引用指向一个对象，就表明对象还存活，垃圾收集器不会收集该对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式将相应（强）引用赋值为 null，就可以被垃圾收集器收集，具体回收时机取决于垃圾收集策略

*   软引用（Soft Reference）

    相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 jvm 判断内存不足时，才会去试图回收软引用指向的对象。jvm 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。

    软引用通常来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉。

*   弱引用（Weak Reference)

    并不能使对象豁免垃圾收集，仅仅提供一种访问在弱引用状态下对象的途径。

*   幻象引用

    不能通过它访问对象，幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制

当使用各种引用进行编程时，在创建各种引用并关联到相应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，可以从队列里获取引用进行后续逻辑（尤其是幻象引用，get 方法只返回 null，如果不指定引用队列，则没有意义）

```java
<T> void example(T obj) {
    ReferenceQueue<T> referenceQueue = new ReferenceQueue<>();
    PhantomReference<T> p = new PhantomReference<>(obj, referenceQueue);
    obj = null;
    System.gc();
    try {
    	Reference<T> reference = (Reference<T>) referenceQueue.remove();
    	if (reference != null) {
    		System.out.println(reference.get());
    	}
    } catch (InterruptedException e) {
    	e.printStackTrace();
    }
}
```

java 9 开始可以通过底层 API 来达到强引用的效果，即 reachability fence（按照 Java 语言规范，如果一个对象没有指向强引用，就符合垃圾收集标准，有时，对象本身没有强引用，但它的部分属性还在被使用，如各种异步调用）

```java
class Resource {
    private int myIndex;
    private static ExternalResource[] externalResourceArray;
    public Resource(int i) {
        myIndex = i;
        externalResourceArray[myIndex] = i;
    }
    public void action() {
        try {
            int i = myIndex;
            Resource.update(externalResourceArray[i]);
        } finally {
            Reference.reachabilityFence(this);
        }
    }
    private static void update(ExternalResource exter) {
        ext.status = ...;
    }
}
new Resource().action();
```

reachabilityFence 大多使用在 Executors 或新的 HTTP/2 客户端代码中，大部分都是异步调用。实践中，可以在 finally 里使用 `Reference.reachabilityFence(Object)` 明确声明对象强可达

###### 对象可达性状态       

*   强可达（Strongly Reachable）

    当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况（新创建一个对象，创建它的线程对它就是强可达）

*   软可达（Softly Reachable）

    只能通过软引用才能访问到对象的状态

*   弱可达（Weakly Reachable）

    无法通过强引用或软引用访问，只能通过弱引用访问时的状态。此时临近 finalize 状态的时机，当弱引用被清楚的时候，就符合 finalize 的条件了

*   幻象可达（Phantom Reachable）

    没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候

*   不可达（unreachable）

    此时对象可以被垃圾收集器回收

判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑，所有引用类型，都是抽象类 `java.lang.ref.Reference` 的子类，除了幻象引用，如果对象还没有被销毁，都可以通过 get 方法获取原有对象并重新指向强引用，因此对于软引用、弱引用、垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。

###### 修饰符

即使一个类只具有包访问权限，其 public main 仍然可访问

*对象成员修饰符*

|    修饰符    |  类   | 构造方法 | 实例方法 | 实例属性 | 静态块 | 静态方法 | 静态属性 |
| :----------: | :---: | :------: | :------: | :------: | :----: | :------: | :------: |
|   default    | true  |   true   |   true   |   true   |        |   true   |   true   |
|    public    | true  |   true   |   true   |   true   |        |   true   |   true   |
|  protected   | inner |   true   |   true   |   true   |        |   true   |   true   |
|   private    | inner |   true   |   true   |   true   |        |   true   |   true   |
|    static    | inner |          |   true   |   true   |  true  |   true   |   true   |
|    final     | true  |          |   true   |   true   |        |          |   true   |
|   abstract   | true  |          |   true   |          |        |          |          |
|    native    |       |          |   true   |          |        |   true   |          |
| synchronized |       |          |   true   |          |        |   true   |          |
|   strictfp   | true  |          |   true   |          |        |   true   |          |
|  transient   |       |          |          |   true   |        |          |   true   |

###### 方法调用

虚拟机调用过程：

1. 获取所有可能被调用的候选方法

   编译器查看对象的声明类型和方法名，编译器将会一一列举所有类中同名方法和其超类中访问属性为 protected 的同名方法

2. 重载解析（overloading resolution）

   查看调用方法提供的参数类型，从候选列表中选择一个与提供的参数类型完全匹配的方法。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。

   因此虚拟机预先为每个类创建了一个方法表（method  table），其中列出了所有方法的签名和实际调用的方法。在真正调用方法的时候，虚拟机仅查找方法表

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用，把对某个对象的引用视为对其基类型的引用的做法被称作向上转型

* 前期绑定

  在程序执行前进行绑定（由编译器和连接器实现），为面向过程的语言中不需要选择就默认的绑定方式

* 静态绑定

  private 方法，static 方法，final 方法或者构造器，那么编译器将可以准确地知道应该调用那个方法，编译时确定如何调用

* 动态绑定

  调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。（编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用）

  一个对象变量可以指示多种实际类型的现象，在运行时能够自动地选择调用那个方法的现象为动态绑定（dynamic binding），动态绑定是默认的处理方式

##### 类

###### 静态成员

被类中的所有对象所共享，静态方法不能访问类实例成员，静态方法只能访问类静态成员，静态变量将变量值存储在一个公共的内存地址，如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响。

* 当声明一个域或方法是 static 时，即这个域或方法不会与包含它的那个类的任何对象实例关联在一起

###### 代码块

* 静态初始化块

  在一个类的声明中，可以包含多个代码块。如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块，在类第一次加载的时候，将会进行静态域的初始化。**所有的静态初始化语句以及静态初始化块都将按照类定义的顺序执行**，但先于 main 函数执行

* 实例化初始化块

  非 static 代码块，会在对象实例化时执行，先于构造函数执行

###### 包

从编译器的角度来看，嵌套的包之间没有任何关系，一个类可以使用所属包中的所有类，以及其他包中的公有类。

导入包中类的关键字是 import，定义包的关键字是 package，如果没有在源文件中定义包，这个源文件的类就被放置在一个默认包中，如果类在一个包里，包的名字也会作为类名的一部分。

###### 类路径

**类存储在文件系统的子目录中，类的路径必须与包名匹配，否则可以编译，但不能运行，虚拟机找不到类**

类路径是所有包含类文件的路径的集合：

* UNIX 环境

  类路径中不同项目之间采用冒号 : 分隔

  ```shell
  java -classpath .:/path/to/thrid.jar Class
  // SE 6 开始，可以在 jar 目录使用 * 通配符
  java -classpath .:/path/to/'*' Class
  ```

* Windows 环境

  类路径中不同项目之间采用冒号 ; 分隔

为了使类能够被多个程序共享，需要做到下面几点：

1）把类放到一个目录中，这个目录是包树状结构的基目录。

2）将 jar 文件放在一个目录中

3）设置类路径（class path）。类路径是所有包含类文件的路径的集合

###### 设置类路径

首选使用 -classpath 或 -cp 选项指定类路径

```shell
java -Dfile.encoding=UTF-8 -classpath .:/path/to/jar/'*' jdbc.mysql.CityCurd
```

可以通过设置 CLASSPATH 环境变量

* UNIX

  ```shell
  export CLASSPATH=.:/path/to/classdir/'*'
  ```

* Windows

  ```powershell
  set CLASSPATH=.;c:\path\to\classdir\*
  ```

不建议将 jar 或类文件放在 *jre/lib/ext* 路径

编译器总会在当前的目录中查找文件，但虚拟机仅在类路径中有 . 目录的时候才查看当前目录，默认的类路径包含 . 目录。设置类路径却未包含 . 目录，则程序仍然可以通过编译，但不能运行

###### 类的关系

* 依赖（uses-a）

  如果一个类的方法操纵另一个类的对象，则一个类依赖于另一个类

* 聚合（has-a）

  一个类对象包含一些其他类的对象，即关联

* 继承（is-a）

  用于表示特殊与一般关系的。

* 类关系的 UML 符号

<img src="../Images/类关系UML符号.png" style="zoom:67%;" />

###### super 关键字

关键字 super 指父类，可用于调用父类中的普通方法和构造方法。

调用父类方法时 super 必须出现在子类方法第一行，这是显式调用父类方法的唯一方法

###### final 关键字

一个即是 static 又是 final 的域只占据一段不能改变的存储空间，类常量使用大写蛇形表示，在定义时，必须对其进行赋值

* final 用于对象引用时，**final 使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象，对象其自身是可以被修改的（java 并未提供使任何对象恒定不变的途径）**
* 对于基本类型，final 使值恒定不变

空白 final 

允许生成空白 final（被声明为 final 但又未给定初值的域），无论什么情况，编译器都确保空白 final 在使用前必须被初始化（必须在域的定义处或构造器中用表达式对 final 进行赋值）

使用 final 关键字修饰以阻止继承：

* 使用 final 修饰类，表示不允许扩展该类，其中方法自动成为 final，但不包括域
* 类中所有 private 方法都隐式指定为 final 的，对 private 方法添加 final 修饰符没有意义
* 域声明为 final 时，赋值之后不容许修改

###### 类与对象最佳实践

* 依赖于类的具体实例的变量或方法必须是一个实例变量或方法如果一个变量被类的所有实例所共享，那么应该将它声明为静态的。如果方法不依赖与某个具体的实例，那就应该将它声明为静态方法。应该使用类名（而不是引用变量）引用静态变量和方法。不要从构造方法中传入参数来初始化静态数据域。最好使用 set 方法改变静态数据域

* 一个方法只需要访问类的静态域则应将它实现为静态方法

  如果一个变量或方法依赖于类的某个具体实例，那就应该将它定义为实例变量或实例方法。如果一个变量或方法不依赖于类的某个具体实例，就应该将它定义为静态变量或静态方法

* 保证数据私有：绝对不要破坏封装性，按需提供访问器和修改器

* 一定要对数据初始化：java 不对局部变量进行初始化，但是会对对象的实例域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据

* 不要在类中使用过多的基本类型：建议局部变量设置为基本类型，类数据域使用包装类

* 将职责过多的类进行分解：类应该描述一个单一的实体，而所有的类操作应该在逻辑上相互配合，支持一个一致的目的

* 类名和方法名要能够体现它们的职责：与变量应该有一个能够反映其含义的名字一样，命名类名的良好习惯是采用一个名词如（Order）、前面有形容词修饰的名词（RushOrder）；对于方法来说，习惯是访问器方法用小写 get 开头，更改器方法用小写的 set 开头

* 优先使用不可变的类：更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预测的。如果类是不可变的，就可以安全地在多个线程间共享其对象

* 组合技术通常用于想在新类中使用现有类的功能而非它的接口

#### 类关系

##### 继承

###### 继承关系

* 继承（extends）

  is-a 关系是继承的一个明显特征，关键字  extends 表示继承。在子类中可以增加域、增加方法或者覆盖超类的方法，然而绝对不能删除继承的任何域或方法。所有类都继承自 Object 类，如果定义一个类时，没有指定继承性，那么这个类的父类就被默认为 Object

* 继承链（inheritance hierarchy）

  继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定的类到其祖先的路径为该类的继承链（inheritance chain）

###### Object 始祖类

Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。在子类中定义 equals 方法时，首先调用超类的 equals。如果检查失败，则不可能相等。语言规范要求 equals 方法具有下面的特性：

* 自反性

  对于任何非空引用 x，x.equals(x) 应该返回 true

* 对称性

  对于任何引用 x 和 y，y.equals(x) 返回 true，x.equals(y) 也应该返回 true

* 传递性

  对于任何引用 x、y、z，如果 x.equlas(y) 返回 true，y.equals(z) 返回 true，x.equals(z) 也应该返回 true

* 一致性

  如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果

hashCode 散列码是由对象导出的一个整数值。每个对象默认的散列码为对象的存储地址**如果重写定义 equals 方法，就必须重新定义 hashCode 方法**

###### 方法覆写

要覆写一个方法，需要在子类中使用和父类一样的签名以及一样的返回值类型来对该方法进行定义，在子类的方法前面放一个 @Override 来重写标注 

* 仅当实例方法是可访问时，它才能被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系
* 静态方法也能被继承，但是静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏，可使用 SuperClass.staticMethod 调用隐藏的静态方法
* 方法覆写（具有同样的签名和返回值类型）发生在通过继承或实现接口而相关的不同类中
* 方法重载（具有同样的名字，但是不同的参数列表）可以发生在同一类中，也可以发生在由于继承而相关的不同类中；

###### 继承设计原则

* 将公共操作或域放在超类
* 不要使用受保护的域
* 使用继承实现 is-a 关系
* 除非所有继承的方法都有意义，否则不要使用继承
* 在覆盖方法时，不要改变预期行为
* 使用多态而非类型信息
* 不要过多使用反射

###### 协变返回类型

SE 5 中添加了协变返回类型，在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型

##### 多态

多态意味着定义为父类的变量可以指向子类对象，每个子类实例都是其父类的实例，但反过来不成立，使用父类对象的地方都可以使用子类的对象

多态（动态绑定，后期绑定，运行时绑定）通过分离做什么和怎么做，将接口和实现分离开。封装通过合并特征和行为来创建新的数据类型，实现隐藏通过将细节私有化，把接口和实现分离开来。

###### 对象转换和 instanceof 运算符

对象的引用类型可以转换为对另外一种对象的引用，使用 instanceof 测试对象类型，使用转换操作符转换

* 向上转型总能成功
* 在尝试转换之前确保该对象是目标类型的实例，如果 x 为 null，x instanceof C 不会产生异常，只是返回 false。因为 null 没有引用任何对象

* 基本类型值转换返回一个新值，而转换一个对象引用不会创建一个新的对象

###### 抽象类

* 抽象类不可以用于创建对象，抽象类可以包含抽象方法，这些方法将在具体的子类中实现
* 抽象方法不能包含在非抽象类中，如果抽象父类的子类不能实现所有的抽象方法，那么子类也必须定义为抽象的，在抽象类扩展的非抽象子类中，必须实现所有的抽象方法。抽象方法是非静态的。
* 抽象类不能使用 new 操作符来初始化。但是，仍然可以定义它的构造方法，这个构造方法在它的子类的构造方法中调用。
* 包含抽象方法的类必须是抽象的。但是，可以定义一个不包含抽象方法的抽象类，在这种情况下，不能使用 new 操作符创建该类的实例，这种类是用来定义新子类的基类
* 即使子类的父类是具体的，这个子类也可以是抽象的

##### 接口

###### 特性

接口不是类，是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义

* 接口中所有方法自动属于 public abstract，在接口中声明方法时，不必提供关键字 public abstract
* 接口可以被扩展，可以嵌套在类或其他接口中。类中嵌套的 private 接口，只能够被实现为一个 private 内部类。当实现某个接口时，并不需要实现嵌套在其内部的任何接口，private 接口不能在定义它的类之外被实现
* 接口中的域自动是 static 和 final 的，接口中定义的域不能是空 final，可以被非常量表达式初始化（值被存储在该接口的静态存储区域内）
* SE 8 中，允许在接口中增加静态方法。

对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂，任何抽象性都应该是应真正的需求而产生的，当必要时，应该重构接口而不是到处添加额外级别的间接性，并由此带来的额外复杂性。恰当的原则应该是优先选择类而不是接口，从类开始，如果接口的必需性变得非常明确，就进行重构，接口是一种重要的工具，但是它们容易被滥用

###### 默认方法

可以为接口方法提供一个默认实现。必须用 default 修饰符标记这样的的方法

如果在接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。对于此种二义性：

1. 超类优先

   如果超类提供了一个具体方法，接口的同名而且有相同参数类型的默认方法会被忽略

2. 接口冲突

   如果一个超接口提供了一个默认方法。另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须类中覆写这个方法来解决冲突

对于只有一个抽象方法的接口，需要这种情况的对象时，可以提供一个 lambda 表达式。这种接口即函数式接口

##### 内部类

内部类是定义在另一个类中的类，内部类是一种非常有用的特性，它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性，内部类与组合是完全不同的概念。

* 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据
* 内部类可以对同一个包中的其他类隐藏起来
* 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较方便
* 内部类中声明的所有静态域都必须是 final，内部类不能有 static 方法，除非是静态内部类
* 一个内部类无论被嵌套多少层，都能访问所有它所嵌入的外围类的所有成员

###### 外围类对象引用

当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会有一个指向那个外围类对象的引用。通过这个引用，可以访问外围类的方法和域，内部类自动拥有对其外围类所有成员的访问权（外部类未拥有内部类访问权限）

在内部类中使用 *OuterClass*.this 表示外围类对象的引用，在编译器被检查，没有任何运行时开销。

###### 内部类对象

```java
// 外部类对象创建内部类对象 OuterInstance.new InnerClassName()
Outer out = new Outer;
Outer.Inner inner = out.new Inner();
```

要创建内部类对象

* 非 static 内部类，只能使用外部类对象创建（.new 方式），因为其与外部类对象引用绑定，即拥有外部类对象之前不可能创建内部类对象
* static 内部类可以直接使用 new 创建对象

###### 局部类

局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，即对外部世界可以完全地隐藏起来。即使外部类中的其他代码也不能访问它。

与其他内部类比较，局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过那些局部变量必须事实上为 final

###### 匿名内部类

将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类即为匿名内部类。通过 new 表达式返回的引用被自动向上转型

如果基类需要一个有参构造器，可以将参数传给基类的构造器，在匿名内部类中不能有命名构造器，可以通过实例初始化（即类中的非 static 块内代码），就能够达到为匿名内部类创建一个构造器的效果

###### 静态内部类

**如果使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象，可以将内部类声明为 static，以便取消产生的引用，static 内部类没有指针指向外围对象**

*   要创建嵌套类的对象，并不需要其外围类的对象
*   不能从嵌套类的对象中访问非静态的外围类对象

###### 接口内部类

静态内部类可以作为接口的一部分，放到接口中的任何类都自动地是 public 和 static 的。只是将嵌套类置于接口的命名空间内，可以在嵌套类中提供外围接口的实现

###### 闭包与回调

闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域（内部类是面向对象的闭包，它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员）

#### 常用对象类型

##### 字符串

###### *String*

java 字符串就是 Unicode 字符序列（一个 Unicode 字符对应 Unicode 编码表中码点，可能需要1个或 2 个代码单元表示）。使用 + 拼接字符串。*String* 类实例不可变。

* 空串

  空串是一个 java 对象，有自己的串长度 0 和内容空。

* null

  *String* 变量可以存放一个特殊的值 null，表示目前没有任何对象与该变量关联

使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 *IndexOutOfBoundsException* 的风险

###### *StringBuilder*、*StringBuffer*

* *StringBuffer*

  线程安全，在每个操作方法上添加了 **synchronized**

* *StringBuilder*

  SE 5 新增，非线程安全

###### *Formatter*

所有新的格式化功能都由 *java.util.Formatter* 类处理，它将格式化字符串与数据翻译成需要的结果

*类型转换字符*

| 字符 |                             含义                             |
| :--: | :----------------------------------------------------------: |
|  d   |                          十进制整型                          |
|  e   |                      浮点数（科学计数）                      |
|  c   |                         Unicode 字符                         |
|  x   |                         十六进制整型                         |
|  b   | Boolean 值（对于 bool 和 Boolean 结果为对应值，其他类型不为 NULL，则始终 true） |
|  h   |                        十六进制散列码                        |
|  s   |                            String                            |
|  %   |                            字符 %                            |
|  f   |                         十进制浮点数                         |

###### String 的正则操作

在 java 中双反斜线表示正则中的反斜线，即普通的反斜线为 `\\\\` ，换行符和制表符只需使用单反斜线 `\n\t`

* *String* 提供了 matches()、replaceFirst()、replaceAll()、split() 方法来进行正则操作。

* *java.util.regex.* 包操作正则
  1. 编译正则
  2. 生成匹配对象

##### 大数据

###### BigDecimal

为了防止精度损失，禁止使用构造方法 BigDecimal(double) 的方式把 double 值转化为 BigDecimal 对象

BigDeciaml(double) 存在精度损失风险，再精确计算或值比较的场景中可能会导致业务逻辑异常。

优先推荐入参数为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法

###### BigInteger

##### 运行时信息

###### class

Class 对象表示运行时的类型信息，每个类都有一个 Class 对象。

* 对一个已加载的类，使用 Class.forName 再进行加载时不会出错，Class.forName() 会立即进行初始化。

类字面常量（.class）也可以生成对 Class 对象的引用，它在编译时就会受到检查，不需要置于 try 语句块中，也不需要对 forName 方法进行调用，当使用类字面常量来创建 Class 对象的引用时，不会自动地初始化 Class 对象，初始化被延迟到对静态方法或者非常数静态域（对于编译期常量，那么这个值不需要对类进行初始化就可以被读取，如果一个 static 域不是 final，那么在对它访问时，总是要求在它被读取之前，为这个域分配存储空间和初始化该存储空间）进行首次引用时才执行。

* 在 Java SE5 中 Class<?> 优于 Class 类型，即便它们是等价的

* Java SE5 还添加了用于 class 引用的转型语法，即 cast() 方法，cast() 方法接受参数对象，并将其转型为 Class 引用类型，对于无法使用普通转型的情况非常有用，在编写泛型时，如果存储了 Class 引用，并希望以后通过这个引用来执行转型。

  ```java
  class Building {}
  class House extends Buiding {}
  public class ClassCasts {
  	Building b = new House();
  	Class<House> houseType = House.class; 
      House h = houseType.cast(B); //  等价	h = (House) b;
  }
  ```

##### 数组

jvm 确保数组会被初始化，而且不能再它的范围之外被访问。创建数组对象时，实际上就是创建一个引用数组，并且每个引用都会自动被初始化为一个特定值，当数组元素引用未指向某个对象时为 null，在使用数组元素引用前，必须为其指定一个对象或基本类型，否则会 *NullPointException*

* 基本类型的数组初始化为 0
* boolean 数组会初始化为 false
* 对象数组元素会初始化为 null
* 可以向导出类型的数组赋予基类型的数组引用。数组对象可以保留有关它们包含的对象类型的规则

##### Enum 类

对于有限集合的变量取值，可以自定义枚举类型，枚举类型包括有限个命名的值，枚举只能存储声明的枚举值或 null 值。

```java
enum Size {SMALL, MEDIUM, LARGE, EXTRE_LARGE};
// 声明枚举变量
Size s = Size.MEDIUM;
```

###### *Enum* 

* values() 方法返回 enum 实例的数组，而且该数组中的元素严格保持其在 enum 中声明的顺序，values() 是由编译器添加的 static 方法
* 创建 enum 时，编译器会生成一个相关的类，这个类继承自 *java.lang.Enum*，可以使用 == 来比较 enum 实例，编译器会自动为 enum 提供 equal() 和 hashCode()，*Enum* 实现了 Comparable 和 Serializable 接口
* ordinal() 方法返回 enum 实例在声明时的次序，从 0 开始
* name() 方法返回 enum 实例声明时的名字，与 toString() 方法效果一样。
* valueOf() 根据给定的名字返回相应的 enum 实例
* 如果打算定义 enum 实例定义方法，那么必须在 enum 实例序列的最后添加一个分号，enum 实例之间用逗号分隔，必须先定义 enum 实例，如果在定义 enum 实例之前定义了任何方法或属性，会编译错误
* 只能在 enum 内部使用其构造器创建 enum 实例，一旦 enum 的定义结束，编译器就不允许使用构造器创建任何实例了

可以在接口的内部，创建实现该接口的枚举，以此将元素进行分组。

可以为 enum 实例编写方法，从而为每个 enum 实例赋予各自不同的行为，需要为 *Enum* 添加一个或多个 abstract 方法，然后为每个 enum 实例实现该方法

###### EnumSet

SE 5 引入了 EnumSet，是为了通过 enum 创建一种替代品，以替代传统的基于 int 的 『位标志』，这种标志可以用来表示某种『开关』信息。

EnumSet 中的元素必须来自一个 enum。EnumSet 的基础是 long，一个 enum 实例只需一位 bit 表示其是否存在，在不超过一个 long 的表达能力的情况下，EnumSet 可以应用于最多不超过 64 个元素的 enum，超过之后性能会下降。

enum 实例定义时的次序决定了其在 EnumSet 中的顺序

###### EnumMap

EnumMap 是一种特殊的 Map，它要求其中的键必须来自一个 enum，EnumMap 内部由数组实现，性能很高。可以使用 enum 实例在 EnumMap 中进行查找操作，只能将 enum 的实例作为键来调用 put()

enum 实例定义时的次序决定了其在 EnumMap 中的顺序