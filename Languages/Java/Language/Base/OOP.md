### 面向对象编程

#### 结构

##### 对象

###### 对象特性

* 对象的行为（behavior）

  可以对对象进行的操作

* 对象的状态（state）

  每个对象都保存着描述当前特征的信息。行为改变状态

* 对象的标识（identity）

  每个对象都有一个唯一的身份

* 对象使用 . 操作符操作

* 变量作用域

  实例变量和静态变量的作用域是整个类，如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量将被隐藏

* this 引用

  关键字 this 引用对象自身，它也可以在构造方法内部用于调用同一个类的其他构造方法，关键字 this 是指向调用对象本身的引用名，可用 this 关键字引用对象的实例成员
  
* 在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，她们仍旧会在任何方法（包括构造器）被调用之前得到初始化

###### 重载

如果多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行那个方法。它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，编译时会错误。

###### 实例化

1. 加载器加载类的字节码
2. 如果类存在基类，对它继续进行加载
3. 根基类中的 static 初始化会被执行，然后是下一个导出类
4. 类加载完毕，开始创建对象
5. 对象中所有的基本类型都会被设为默认值，对象引用被设为 null（通过将对象内存设为二进制0值）
6. 基类的构造器会被调用（基类构造器以相同的顺序来经历相同的过程）
7. 基类构造器完成后，实例变量按其次序被初始化
8. 构造器的其余部分被执行

构造器应该尽可能简单，如果可以避免调用其他方法，在构造器内唯一能够安全调用的那些方法是基类中的 final 方法

###### 静态初始化块

在一个类的声明中，可以包含多个代码块。如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块，在类第一次加载的时候，将会进行静态域的初始化。默认的初始值是 0、false、null。<u>所有的静态初始化语句以及静态初始化块都将按照类定义的顺序执行</u>

###### 对象析构与 finalize 方法

java 不支持析构器。可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源，因为很难知道这个方法什么时候才能够调用。调用 *System*.runFinalizersOnExit(true) 能够确保 finalizer 方法在 java 关闭前被调用。不过这个方法并不安全，替代的方法是使用方法 *Runtime*.addShutdownHook 添加关闭钩（shutdown hook）。

###### 对象引用

* 对象是通过对象引用变量来访问的，该变量包含对对象的引用，从本质上来说，一个类是一个程序员定义的类型。类是一种引用类型对象引用变量中只包含了对该对象的引用，严格来说，对象引用变量和对象是不同的，但是大多数情况下，这种差异是可以忽略的
* 数组被看作是对象，数组是用 new 操作符创建的，一个数组变量实际上是一个包含数组引用的变量
* 给方法传递一个对象，是将对象的引用传递给方法

###### 对象数据域默认值

* 引用类型数据域的默认值是 null
* 数值类型域的默认值是 0
* Boolean 类型数据域默认值是 false
* char 类型的数据域的默认值是 \u0000

###### 基本类型变量和引用类型变量的区别

每个变量都代表一个存储值的内存位置。声明一个变量时，就是在告诉编译器这个变量可以存放什么类型的值。对基本类型变量来说。对应内存所存储的值是基本类型的值。对引用类型变量来说，对应内存所存储的值是一个引用，是对象的存储地址。

将一个变量赋值给另一个变量时，另一个变量就被赋予同样的值。对基本类型就是将一个变量的实际值复制一份赋给另一个变量。对引用变量就是将一个变量的引用赋给另一个变量

###### 可见性

| 类中成员修饰符 | 在同一类中可访问 | 在同一包中可访问 | 在子类内可访问 | 在不同包可访问 |
| :------------: | :--------------: | :--------------: | :------------: | :------------: |
|     public     |        是        |        是        |       是       |       是       |
|   protected    |        是        |        是        |       是       |   不同包子类   |
|    default     |        是        |        是        |       是       |       否       |
|    private     |        是        |        否        |       否       |       否       |

如果一个变量或方法依赖于类的某个具体实例，那就应该将它定义为实例变量或实例方法。如果一个变量或方法不依赖于类的某个具体实例，就应该将它定义为静态变量或静态方法

* 即使一个程序中含有多个类，也只有命令行所调用的那个类的 main 方法会被调用
* 即使一个类只具有包访问权限，其 public main 仍然可访问

*对象成员修饰符*

|    修饰符    |  类   | 构造方法 | 实例方法 | 实例属性 | 静态块 | 静态方法 | 静态属性 |
| :----------: | :---: | :------: | :------: | :------: | :----: | :------: | :------: |
|   default    | true  |   true   |   true   |   true   |        |   true   |   true   |
|    public    | true  |   true   |   true   |   true   |        |   true   |   true   |
|  protected   | inner |   true   |   true   |   true   |        |   true   |   true   |
|   private    | inner |   true   |   true   |   true   |        |   true   |   true   |
|    static    | inner |          |   true   |   true   |  true  |   true   |   true   |
|    final     | true  |          |   true   |   true   |        |          |   true   |
|   abstract   | true  |          |   true   |          |        |          |          |
|    native    |       |          |   true   |          |        |   true   |          |
| synchronized |       |          |   true   |          |        |   true   |          |
|   strictfp   |       |          |   true   |          |        |   true   |          |
|  transient   |       |          |          |   true   |        |          |   true   |

###### 方法调用

虚拟机调用过程：

1. 获取所有可能被调用的候选方法

   编译器查看对象的声明类型和方法名，编译器将会一一列举所有类中同名方法和其超类中访问属性为 public 的同名方法

2. 重载解析（overloading resolution）

   查看调用方法提供的参数类型，从候选列表中选择一个与提供的参数类型完全匹配的方法。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。

3. 如果是 private 方法，static 方法，final 方法或者构造器，那么编译器将可以准确地知道应该调用那个方法

4. 当程序允许时，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实际类型最适合的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此虚拟机预先为每个类创建了一个方法表（method  table），其中列出了所有方法的签名和实际调用的方法。这样，在真正调用方法的时候，虚拟机仅查找方法表就可以。

##### 类组成

###### 静态成员

被类中的所有对象所共享，静态方法不能访问类实例成员，静态方法只能访问类静态成员，静态变量将变量值存储在一个公共的内存地址，如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响。

* 当声明一个域或方法是 static 时，即这个域或方法不会与包含它的那个类的任何对象实例关联在一起

###### 静态代码块

仅执行一次，在首次生成这个类的一个对象或首次访问类的静态成员时

###### 包

从编译器的角度来看，嵌套的包之间没有任何关系。java.util 包与 java.util.jar 包毫无关系。每一个都拥有独立的类集合。一个类可以使用所属包中的所有类，以及其他包中的公有类。

导入包中类的关键字是 import，定义包的关键字是 package，如果没有在源文件中放置包，这个源文件的类就被放置在一个默认包中。

如果类在一个包里，包的名字也作为类名的一部分。

###### 导入

* 类导入

  一个类可以使用所属包中的所有类，以及其他包中的公有类，使用 import 关键字或类全名使用

* 静态导入

  使用 import static 导入静态方法和静态域来省略类名直接调用，但不建议

###### 类路径

<u>类存储在文件系统的子目录中，类的路径必须与包名匹配，否则可以编译，但不能运行，虚拟机找不到类</u>

类文件可以存储在 jar 文件中。在一个 jar 文件中，可以包含多个压缩形式的类文件和子目录，在程序中用到第三方的库文件时，通常会给出一个或多个需要包含的 jar 文件。jdk 也提供了许多的 jar 文件

类路径是所有包含类文件的路径的集合：

* UNIX 环境

  类路径中不同项目之间采用冒号 : 分隔

  ```shell
  java -classpath .:/path/to/thrid.jar Class
  // SE 6 开始，可以在 jar 目录使用 * 通配符
  java -classpath .:/path/to/'*' Class
  ```

* Windows 环境

  类路径中不同项目之间采用冒号 ; 分隔

为了使类能够被多个程序共享，需要做到下面几点：

1）把类放到一个目录中，这个目录是包树状结构的基目录。

2）将 jar 文件放在一个目录中

3）设置类路径（class path）。类路径是所有包含类文件的路径的集合

###### 设置类路径

首选使用 -classpath 或 -cp 选项指定类路径

```shell
java -Dfile.encoding=UTF-8 -classpath .:/Users/zhangyaowen/LearnJava/webapps/se-exercises/jar/'*' jdbc.mysql.CityCurd
```

可以通过设置 CLASSPATH 环境变量

* UNIX

  ```shell
  export CLASSPATH=.:/path/to/classdir/'*'
  ```

* Windows

  ```powershell
  set CLASSPATH=.;c:\path\to\classdir\*
  ```

不建议将 jar 或类文件放在 `jre/lib/ext` 路径

javac 编译器总是在当前的目录中查找文件，但 java 虚拟机仅在类路径中有 `.` 目录的时候才查看当前目录。如果没有设置类路径，那并不会产生什么问题，默认的类路径包含 . 目录。然而如果设置了类路径却忘记了包含 . 目录，则程序仍然可以通过编译，但不能运行

###### 类的关系

* 依赖（uses-a）

  如果一个类的方法操纵另一个类的对象，则一个类依赖于另一个类（应该尽可能地将相互依赖地类减少至最少。如果类 A 不知道 B 的存在，它就不会关心 B 的任何改变，意味着 B 的改变不会导致 A 产生任何 bug）

* 聚合（has-a）

  一个类对象包含一些另一个类的对象，也称为关联是一种常见的二元关系，描述两个类之间的活动，关系中涉及的每个类可以有一个角色表示，描述在该关系中担当的角色，关联中涉及的每个类可以给定一个多重性，多重性可以是一个数字或一个区间，决定在关系中涉及类的多少个对象

* 继承（is-a）

  用于表示特殊与一般关系的。

* 类关系的 UML 符号

<img src="../Images/类关系UML符号.png" style="zoom:67%;" />

###### super 关键字

关键字 super 指这个 super 关键字所在类的父类，可用于调用父类中的普通方法和构造方法。

* 调用父类方法时 super 必须出现在子类方法第一行，这是显式调用父类方法的唯一方法

###### final 关键字

定义数据恒定不变（一个不会改变的编译时常量；一个在运行时被初始化的值）在 Java 中这类常量是基本数据类型，并且以关键字 final 表示，在对这个常量进行定义的时候，必须对其进行赋值。

* 一个即是 static 又是 final 的域只占据一段不能改变的存储空间
* 对对象引用时，**final 使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象，对象其自身是可以被修改的（Java 并未提供使任何对象恒定不变的途径）**
* 对于基本类型，final 使数值恒定不变

空白 final 

Java 允许生成空白 final（被声明为 final 但又未给定初值的域），无论什么情况，编译器都确保空白 final 在使用前必须被初始化（必须在域的定义处或构造器中用表达式对 final 进行赋值）

使用 final 关键字修饰以阻止继承：

* 使用 final 修饰类，表示不允许扩展该类，其中方法自动成为 final，但不包括域
* 方法如果声明为 final，则子类不能覆写这个方法（类中所有 private 方法都隐式指定为 final 的，对 private 方法添加 final 修饰符没有意义）
* 域声明为 final，对于 final 域，赋值之后不容许修改

###### 类与对象最佳实践

* 一致性：应该具有一致性的提供一个公共无参构造方法，用于构建默认实例。
* 依赖于类的具体实例的变量或方法必须是一个实例变量或方法如果一个变量被类的所有实例所共享，那么应该将它声明为静态的。如果方法不依赖与某个具体的实例，那就应该将它声明为静态方法。应该使用类名（而不是引用变量）引用静态变量和方法。不要从构造方法中传入参数来初始化静态数据域。最好使用 set 方法改变静态数据域
* 一个方法只需要访问类的静态域则应将它实现为静态方法
* 保证数据私有：绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。
* 一定要对数据初始化：java 不对局部变量进行初始化，但是会对对象的实例域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据，具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值
* 不要在类中使用过多的基本类型：建议局部变量设置为基本类型，类数据域使用包装类
* 不是所有的域都需要独立的域访问器和域更改器：需要获得或设置域数据时才需要
* 将职责过多的类进行分解：类应该描述一个单一的实体，而所有的类操作应该在逻辑上相互配合，支持一个一致的目的
* 类名和方法名要能够体现它们的职责：与变量应该有一个能够反映其含义的名字一样，命名类名的良好习惯是采用一个名词如（Order）、前面有形容词修饰的名词（RushOrder）；对于方法来说，习惯是访问器方法用小写 get 开头，更改器方法用小写的 set 开头
* 优先使用不可变的类：更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预测的。如果类是不可变的，就可以安全地在多个线程间共享其对象
* 组合技术通常用于想在新类中使用现有类的功能而非它的接口

#### 类关系

##### 继承

###### 继承关系

* 继承（extends）

  is-a 关系是继承的一个明显特征，关键字  extends 表示继承。在子类中可以增加域、增加方法或者覆盖超类的方法，然而绝对不能删除继承的任何域或方法。所有类都继承自 Object 类，如果定义一个类时，没有指定继承性，那么这个类的父类就被默认为是 Object

* 继承链（inheritance hierarchy）

  继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定的类到其祖先的路径为该类的继承链（inheritance chain）

###### Object 始祖类

Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。在子类中定义 equals 方法时，首先调用超类的 equals。如果检查失败，则不可能相等。Java 语言规范要求 equals 方法具有下面的特性：

* 自反性

  对于任何非空引用 x，x.equals(x) 应该返回 true

* 对称性

  对于任何引用 x 和 y，当前仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true

* 传递性

  对于任何引用 x、y、z，如果 x.equlas(y) 返回 true，y.equals(z) 返回 true，x.equals(z) 也应该返回 true

* 一致性

  如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果

hashCode 散列码是由对象导出的一个整数值。每个对象默认的散列码为对象的存储地址**如果重写定义 equals 方法，就必须重新定义 hashCode 方法**

###### 方法覆写

要覆写一个方法，需要在子类中使用和父类一样的签名以及一样的返回值类型来对该方法进行定义，在子类的方法前面放一个 @Override 来重写标注 

* 仅当实例方法是可访问时，它才能被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系
* 静态方法也能被继承，但是静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏，可使用 SuperClass.staticMethod 调用隐藏的静态方法
* 方法覆写（具有同样的签名和返回值类型）发生在通过继承或实现接口而相关的不同类中
* 方法重载（具有同样的名字，但是不同的参数列表）可以发生在同一类中，也可以发生在由于继承而相关的不同类中；

###### 继承设计原则

* 将公共操作或域放在超类
* 不要使用受保护的域
* 使用继承实现 is-a 关系
* 除非所有继承的方法都有意义，否则不要使用继承
* 在覆盖方法时，不要改变预期行为
* 使用多态而非类型信息
* 不要过多使用反射

###### 协变返回类型

SE 5 中添加了协变返回类型，在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型

##### 多态

多态意味着定义为父类的变量可以指向子类对象，每个子类实例都是其父类的实例，但反过来不成立，使用父类对象的地方都可以使用子类的对象

多态（动态绑定，后期绑定，运行时绑定）通过分离做什么和怎么做，将接口和实现分离开。封装通过合并特征和行为来创建新的数据类型，实现隐藏通过将细节私有化，把接口和实现分离开来。

###### 向上转型

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用，把对某个对象的引用视为对其基类型的引用的做法被称作向上转型

###### 方法绑定

方法绑定：将一个方法调用同一个方法主体关联起来

* 前期绑定

  在程序执行前进行绑定（由编译器和连接器实现），为面向过程的语言中不需要选择就默认的绑定方式

* 静态绑定

  private 方法，static 方法，final 方法或者构造器，那么编译器将可以准确地知道应该调用那个方法，编译时确定如何调用

* 动态绑定

  调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。（编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用）

  一个对象变量可以指示多种实际类型的现象，在运行时能够自动地选择调用那个方法的现象为动态绑定（dynamic binding），动态绑定是默认的处理方式

方法可以在沿着继承链的多个类中实现，jvm 决定运行时候调用那个方法，jvm 会依次在本类及继承链查找方法的实现，一旦找到一个实现就停止查找，然后调用这个首先找到的实现。虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样，在真正调用方法的时候，虚拟机仅查找这个表就行了。

###### 对象转换和 instanceof 运算符

对象的引用类型可以转换为对另外一种对象的引用，使用 instanceof 测试对象类型，使用转换操作符转换

* 向上转型总能成功
* 在尝试转换之前确保该对象是目标类型的实例，如果 x 为 null，x instanceof C 不会产生异常，只是返回 false。因为 null 没有引用任何对象

* 基本类型值转换返回一个新值，而转换一个对象引用不会创建一个新的对象

###### 抽象类

* 抽象类不可以用于创建对象，抽象类可以包含抽象方法，这些方法将在具体的子类中实现
* 抽象方法不能包含在非抽象类中，如果抽象父类的子类不能实现所有的抽象方法，那么子类也必须定义为抽象的，在抽象类扩展的非抽象子类中，必须实现所有的抽象方法。抽象方法是非静态的。
* 抽象类不能使用 new 操作符来初始化。但是，仍然可以定义它的构造方法，这个构造方法在它的子类的构造方法中调用。
* 包含抽象方法的类必须是抽象的。但是，可以定义一个不包含抽象方法的抽象类，在这种情况下，不能使用 new 操作符创建该类的实例，这种类是用来定义新子类的基类
* 即使子类的父类是具体的，这个子类也可以是抽象的

##### 接口

###### 特性

接口不是类，是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义

* 接口中所有方法自动属于 public abstract，在接口中声明方法时，不必提供关键字 public abstract
* 接口只包含常量和抽象方法，目的是指明相关或者不相关的多个对象的共同行为。不能使用 new 操作符创建接口的实例
* 一个类可以实现多个接口，但是只能继承一个父类
* 接口可以被扩展，可以嵌套在类或其他接口中。类中嵌套的 private 接口，只能够被实现为一个 private 内部类。当实现某个接口时，并不需要实现嵌套在其内部的任何接口，private 接口不能在定义它的类之外被实现
* 接口中的域自动是 static 和 final 的，接口中定义的域不能是空 final，可以被非常量表达式初始化（值被存储在该接口的静态存储区域内）

对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂，任何抽象性都应该是应真正的需求而产生的，当必要时，应该重构接口而不是到处添加额外级别的间接性，并由此带来的额外复杂性。恰当的原则应该是优先选择类而不是接口，从类开始，如果接口的必需性变得非常明确，就进行重构，接口是一种重要的工具，但是它们容易被滥用

###### 静态方法

SE 8 中，允许在接口中增加静态方法。

###### 默认方法

可以为接口方法提供一个默认实现。必须用 default 修饰符标记这样的的方法

如果在接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。对于此种二义性：

1. 超类优先

   如果超类提供了一个具体方法，接口的同名而且有相同参数类型的默认方法会被忽略

2. 接口冲突

   如果一个超接口提供了一个默认方法。另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须类中覆写这个方法来解决冲突

对于只有一个抽象方法的接口，需要这种情况的对象时，可以提供一个 lambda 表达式。这种接口即函数式接口

##### 内部类

内部类是定义在另一个类中的类，内部类是一种非常有用的特性，它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性，内部类与组合是完全不同的概念。

* 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据
* 内部类可以对同一个包中的其他类隐藏起来
* 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较方便
* 内部类中声明的所有静态域都必须是 final，内部类不能有 static 方法，除非是静态内部类

###### 外围类对象引用

当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密的捕获一个指向那个外围类对象的引用。通过这个引用，可以访问外围类的方法和域，内部类自动拥有对其外围类所有成员的访问权（外部类未拥有内部类访问权限）

在内部类中使用 *OuterClass*.this 表示外围类对象的引用，在编译器被检查，没有任何运行时开销。

###### 内部类对象

```java
// 外部类对象创建内部类对象 OuterInstance.new InnerClassName()
Outer out = new Outer;
Outer.Inner inner = out.new Inner();
```

要创建内部类对象

* 非 static 内部类，只能使用外部类对象创建（.new 方式），因为其与外部类对象引用绑定，即拥有外部类对象之前不可能创建内部类对象
* static 内部类可以直接使用 new 创建对象

###### 局部类

局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，即对外部世界可以完全地隐藏起来。即使外部类中的其他代码也不能访问它。

与其他内部类比较，局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过那些局部变量必须事实上为 final

###### 匿名内部类

将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类即为匿名内部类

###### 静态内部类

如果使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为 static，以便取消产生的引用，，static 内部类没有指针指向外围对象

#### 常用对象类型

##### 字符串

java 字符串就是 Unicode 字符序列（一个 Unicode 字符对应 Unicode 编码表中码点，可能需要1个或2个代码单元表示）。使用 + 拼接字符串。*String* 类实例不可变。

* 空串

  空串是一个 java 对象，有自己的串长度 0 和内容空。

* null

  *String* 变量可以存放一个特殊的值 null，表示目前没有任何对象与该变量关联

使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 *IndexOutOfBoundsException* 的风险

##### BigDecimal

为了防止精度损失，禁止使用构造方法 BigDecimal(double) 的方式把 double 值转化为 BigDecimal 对象

BigDeciaml(double) 存在精度损失风险，再精确计算或值比较的场景中可能会导致业务逻辑异常。

优先推荐入参数为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法