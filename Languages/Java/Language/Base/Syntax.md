### Syntax

#### 基本数据类型

在 java 语言中，一共有 8 种基本类型，包含 4 种整型、2 种浮点类型、1 种用于表示 Unicode 编码的字符类型、布尔类型，基本类型值传递时采用复制传值。

##### 整型

| 名称  |  字长  |                    范围                    |
| :---: | :----: | :----------------------------------------: |
| byte  | 1 byte |                 -128 ~ 127                 |
| Short | 2 byte |               -32768 ~ 32767               |
|  int  | 4 byte |          -2147483648 ~ 2147483747          |
| long  | 8 byte | -9223372036854775808 ~ 9223372036854775807 |

##### 浮点型

|  名称  |  字长  |                             范围                             |
| :----: | :----: | :----------------------------------------------------------: |
| float  | 4 byte |        大约 -3.402823-47e ~ 38F (有效位数 6 ～ 7 位)         |
| double | 8 byte | 大约 - 1.79769313486231570-70E ～ 1.79769313486231570-70E（有效位 15 位） |

所有的浮点数值计算都遵循 IEEE 754 规范。表示溢出和出错情况的三个常量：

* 正无穷大：常量 **Double.POSITIVE_INFINITY**
* 负无穷大：常量 **Double.NEGATIVE_INFINITY**
* NaN （不是一个数字）：常量 **Double.NaN**

###### 比较

浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equlas 来判断（浮点数采用 ”尾数 + 阶码“ 的编码方式，类似于科学计数法的 ”有效数字 + 指数“ 的表示方式。二进制无法精确表示大部分的十进制小数）。比较方式：

* 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的

  ```java
  float a = 1.0f - 0.9f;
  float b = 0.9f - 0.8f;
  float diff = 1e-6f;
  if (Math.abs(a - b) < diff) {
      System.out.print("true");
  }
  ```

* 使用 *BigDecimal* 来定义值，再进行浮点数的运算操作

  ```java
  BigDecimal a = new BigDecimal("1.0");
  BigDecimal b = new BigDecimal("0.9");
  BigDecimal c = new BigDecimal("0.8");
  BigDecimal x = a.subtract(b);
  BigDecimal y = b.subtract(c);
  if (x.compareTo(y) == 0) {
	System.out.println("true");
  }
  ```
  

##### char

char 类型原本用于表示单个字符。有些 Unicode 字符用一个 char 值，另一些 Unicode 字符用两个 char 值。<u>char 类型的字面量要用单引号括起来</u>。可以用十六进制值（范围 \u0000 ~ \UFFFF 即 0 ～ 65535），字长为 2 byte 来表示，char 表示单个代码单元。

###### Unicode 

Unicode 打破了传统字符编码机制的限制，在 Unicode 出现之前，已经有许多不同的标准：美国的 ASCII，西欧的 ISO 8859-1，俄罗斯的 KOI-8，中国的 GB 18030 和 BIG-5 等。这样问题是：对于任意的给定的代码值，在不同的编码方案下有可能对应不同字母；采用大字符集的语言其编码长度有可能不同。设计 Unicode 编码就是解决该问题。1991 年发布的 Unicode 1.0，当时占用 65536 个代码值中不到一半。

在设计 java 时采用 16 位 Unicode 字符集。现在 Unicode 字符超过了 65536，16 位的 char 类型已经不能满足描述所有 Unicode 字符的需要。java 解决方案：

* 码点（code point）

  Unicode 编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用十六进制书写，并加上前缀 U+。一个码点有可能需要两个 char。

* 代码级别（code plane）

  Unicode 的码点可以分成 17 个代码级别：

  * 第一个代码级别称为基本的多语言级别（basic multilingual plane），码点从 U+0000 ～ U+FFFF（0～ 65535），包括经典的 Unicode；

  * 其余的 16 个级别码点从 U+10000 ～ U+10FFFF（65536 ～ 1114111），其中包括一些辅助字符（supplementary character）

* 代码单元（code unit）

  在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元

* 辅助字符

  采用一对连续的代码单元进行编码。

UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。在 java 中 char 类型描述了 UTF-16 编码中的一个代码单元

##### boolean

boolean 类型有两个值: false 和 true，用来判定逻辑条件。<u>整型值和布尔值之间不能进行相互转换</u>

##### 数值类型转换

使用两个数进行二元操作时，较小单位会隐式转换为较大单位再计算，结果为较大单位。允许使用 () 操作符进行强制类型转换，但可能丢失信息。

##### 自动装开箱

基本数据类型值不是一个对象，可用包装类来包装成一个对象，根据上下文环境，基本数据类型值可以使用包装类自动转换成一个对象，将基本类型值转换为包装类的过程为装箱，将包装类转换为基本类型为开箱，java 支持自动装开箱

* 包装类没有无参构造方法，所有包装类都是不可变的，一旦创建该对象，它们内部值就不能再改变
* 每一个数值包装类都有常量 **MAX_VALUE** 和 **MIN_VALUE** 表示对象基本数据类型的最大值和最小值
* 数值包装类中包含 compareTo 方法用于比较两个数值，如果该数值大于，等于，小于另外一个数值时，分别返回 1，0，-1

#### 变量

每个变量都有一个类型。在声明变量时，变量的类型位于变量名之前。大小写敏感，没有长度限制。声明一个变量之后，必须用赋值语句对变量进行赋值。不能使用未初始化的变量。变量的声明尽可能地靠近变量第一次使用的地方。

```java
// 声明变量
int size;
// 赋值
size = 32;
// 初始化
String = "jaca";
```

#### 常量

使用关键字 final 指示常量，关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能再修改。习惯上常量名使用全大写蛇形。

类常量使用 static final  定义，当类常量被声明为 public 时，其他类也可以该常量​     

#### 运算符号

元素符优先级递减

|                      运输符号                      | 运算顺序 |
| :------------------------------------------------: | :------: |
|                        [] .                        |  左到右  |
|        ！～  ++  --  ()  new  +(正)  -(负)         |  右到左  |
|                       * / %                        |  左到右  |
|                        - +                         |  左到右  |
|                    <<  >>  >>>                     |  左到右  |
|              <  <=  > >=  instanceof               |  左到右  |
|                       ==  !=                       |  左到右  |
|                         &                          |  左到右  |
|                         ^                          |  左到右  |
|                         ｜                         |  左到右  |
|                         &&                         |  左到右  |
|                        \|\|                        |  左到右  |
|                        ? :                         |  右到左  |
| =  +=  -=  *=  /=  %=  &=  \|=  ^=  <<=  >>=  >>>= |  右到左  |

##### 位运算符

处理整数类型时，可以直接对组成整形数值的各个位完成操作。可以使用掩码得到整数中的各个位。

左移或右移（会用符号位填充高位，要完成模 32 的位运算，除非左操作数是 long 类型，此时要对右操作数模 64 ）操作符在需要建立位模式来完成位掩码时很方便。>>> 运算符会用 0 填充高位

#### 规范

##### 语法规范

* 类名采用大驼峰
* 源代码的文件名必须与公共类的名字相同，用 .java 作为扩展名
* 每个 java 应用必须有 main 方法且必须是 public 和 static

##### 块级作用域

块指由一对大括号括起来的若干条简单的 java 语句。块确定了变量的作用域。块可以嵌套，但不能在嵌套的两个块中声明同名的变量。

##### 关键字

|    关键字    |                             含义                             |
| :----------: | :----------------------------------------------------------: |
|   abstract   |                         抽象类或方法                         |
|    assert    |                             断言                             |
|   boolean    |                           布尔类型                           |
|    break     |                    跳出一个 switch 或循环                    |
|     byte     |                           8 位整数                           |
|     case     |                         switch 分支                          |
|    catch     |                          try 块子句                          |
|     char     |                       Unicode 字符类型                       |
|    class     |                            类声明                            |
|    const     |                             保留                             |
|   continue   |                  跳出当前循环继续下一次循环                  |
|   default    |                      swich 默认条件子句                      |
|      do      |                      do/while 循环子句                       |
|    double    |                         双精度浮点数                         |
|     else     |                         if/else 子句                         |
|     enum     |                           枚举类型                           |
|   extends    |                             继承                             |
|    final     |                          不允许覆盖                          |
|   finally    |                     try 中 finally 子句                      |
|    float     |                         单精度浮点数                         |
|     for      |                             循环                             |
|     goto     |                             保留                             |
|      if      |                           条件判断                           |
|  implements  |                           实现接口                           |
|    import    |                        导入类或静态块                        |
|  instanceof  |                      测试对象是否属于类                      |
|     int      |                          32 位整形                           |
|  interface   |                           声明接口                           |
|     long     |                          64 长整形                           |
|    native    |                     由宿主系统实现的方法                     |
|     new      |                            实例化                            |
|     null     |                         null 直接量                          |
|   package    |                            声明包                            |
|   private    |                             私有                             |
|  protected   |                             保护                             |
|    public    |                             公有                             |
|    return    |                             返回                             |
|    short     |                          16 位整形                           |
|    static    |                             静态                             |
|   strictfp   | 使用精确浮点数计算模式，保证在所有的 java 虚拟机中计算结果都相同 |
|    super     |                      超类或超类对象引用                      |
|    switch    |                         代替 if/else                         |
| synchronized |                对线程而言是原子的方法或代码块                |
|     this     |                         当前对象引用                         |
|    throw     |                            抛异常                            |
|    throws    |                  声明一个方法可能抛出的异常                  |
|  transient   |                       标志非永久的数据                       |
|     try      |                       捕获异常的代码块                       |
|     void     |                         指定不返回值                         |
|   volatile   |                 确保一个域可以由多个线程访问                 |
|    while     |                             循环                             |

##### 文档注释

###### javadoc

Jdk 包含 javadoc 工具，它可以由源文件生成一个 HTML 文件。javadoc 从下面几个特性中抽取信息：

* 包
* 公有类与接口
* 公有的和受保护的构造器及方法
* 公有的和受保护的域

为上面几部分编写注释，注释放在描述特性前面，注释以 /** 开始以 */ 结束，文档注释在标记之后为自由标记文件。标记由 @ 开始，自由格式文本的第一句是一个概要性的句子，在自由格式文本中，可以使用 HTML 修饰符，与 <h1> 或 <hr> 冲突。等宽代码使用 {@code ...}

###### 注释标记

* 通用注释

  * @since

  * @deprecated

  * @see

    指定超链接

    ```java
    @see <a href="www.javadoc.com/lang/string">string page</a>
    ```

    链接类方法

    ```java
    @see com.mysql.jdbc.Result#setInt(String)
    ```

* 类注释

  类注释必须放在 import 语句之后，类定义之前

  * @author

    可以使用多个

  * @version

* 方法注释

  每一个方法注释必须放在所描述的方法之前，除了通用标记之外，可以使：

  * @param
  * @return
  * @throws

* 域注释

  只需要对公有域建立文档

* 包注释

  需要在每个包目录中添加一个单独的文件：

  * 以 package.html 命名的 HTML 文件，<body>...</body> 之间所有文本都会被抽取
  * 以 package-info.java 命名的 java 文件，在一个包语句后以 javadoc 注释，不包含其他注释和语句

###### 注释抽取

假定 HTML 文件将被存放在目录 docDirectory 下。执行以下步骤：

1）切换到包含想要生成文档的源文件目录。如果有嵌套的包要生成文档，如 com.horstmann.corejava，就必须切换到包含子目录 com 的目录

2）如果是一个包，执行命令：

```shell
javadoc -d docDirectory nameOfPackage
# 或对于多个包生成文档
javadoc -d docDirectory nameOfPackage1 nameOfPackage2
# 如果文件在默认包中，就应该运行
javadoc -d docDirectory *.java
```

如果省略了 -d docDirectory 选项，HTML 文件就会被提取到当前目录下。

