## 继承

### 类、超类、子类

#### 继承特性

* extends

  `is-a` 关系时继承的一个明显特征，关键字 `extends` 表示继承。在子类中可以增加域、增加方法或者覆盖超类的方法，然而绝对不能删除继承的任何域或方法

* override 覆盖方法

  父类的方法对子类不一定适用，子类可以使用一个新的方法来**覆盖（override）** 超类中的这个方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中这个相同签名的方法。覆盖一个方法的时候，子类方法不能低于超类方法的可见性。

* super 关键字

  super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。Java 使用关键字 super 调用超类的方法

* 子类构造器

  子类构造器不能访问父类的私有域，可以使用 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显示地调用超类的构造器，则将自动调用超类默认（无参）的构造器。如果超类没有无参构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误

* polymorphism 多态

  一个对象变量可以指示多种实际类型的现象，在运行时能够自动地选择调用那个方法的现象为动态绑定（dynamic binding）。动态绑定时默认的处理方式

* inheritance hierarchy 继承层次

  继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定的类到其祖先的路径为该类的**继承链**（inheritance chain）

#### 方法调用

对于 `x.f(args)`，隐式参数 x 声明为类 c 的一个对象。虚拟机调用过程：

1. 编译器查看对象的声明类型和方法名。假设调用 `x.f(param)`，且隐式参数 x 声明为 C 类的对象，有可能存在多个名字为 f，但参数类型不一样的方法。编译器将会一一列举所有 C 类中名为 `f` 的方法和其超类中访问属性为 `public` 的且名为 `f` 的方法，此时编译器获得所有可能被调用的候选方法
2. 编译器将查看调用方法时提供的参数类型。如果在所有名为 `f` 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。即**重载解析**（overloading resolution）。由于允许类型转换，所以这个过程很复杂，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。
3. 如果是 private 方法，static 方法，final 方法或者构造器，那么编译器将可以准确地知道应该调用那个方法，这种方式即**静态绑定**（static binding），与之对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定
4. 当程序允许时，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实际类型最适合的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此虚拟机预先为每个类创建了一个**放发表**（method  table），其中列出了所有方法的签名和实际调用的方法。这样，在真正调用方法的时候，虚拟机仅查找方法表就可以。

#### 阻止继承

如果在定义类的时候使用了 `final` 修饰符就表明这个类是  `final` 类，不允许扩展该类。类中特定的**方法如果声明为 `final` ，则子类不能覆盖这个方法**。域也可以被声明为 `final`。**对于 `final` 域，构造对象之后就不允许改变它们的值了**。如果将类声明为 `final`，只有其中的方法自动成为 `final`，而不包括域。

### Object 始祖类

Object 类是所有 Java 中所有类的始祖，在 Java 中每个类都是由它扩展而来的，如果没有明确指定超类，则 Object 被认为是这个类的超类

#### Object 方法

##### equals 方法

Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。在子类中定义 equals 方法时，首先调用超类的 equals。如果检查失败，则不可能相等。Java 语言规范要求 equals 方法具有下面的特性：

* 自反性

  对于任何非空引用 x，`x.equals(x)` 应该返回 true

* 对称性

  对于任何引用 x 和 y，当前仅当 `y.equals(x)` 返回 true，`x.equals(y)` 也应该返回 true

* 传递性

  对于任何引用 x、y、z，如果 `x.equlas(y)` 返回 true，`y.equals(z)` 返回 true，`x.equals(z)` 也应该返回 true
  
* 一致性

  如果 x 和 y 引用的对象没有发生变化，反复调用 `x.equals(y)` 应该返回同样的结果

##### hashCode

散列码是由对象导出的一个整数值。每个对象默认的散列码为对象的存储地址**如果重写定义 equals 方法，就必须重新定义 hashCode 方法**

##### toString

返回表示对象值的字符串，绝大多数的 `toString ` 方法都遵循这样的格式：类的名字，随后是中括号括起来的域的值。只要对象与一个字符串通过操作符 `+` 连接起来，Java 编译器就会自动地调用 `toString` 方法，以便获得这个对象的字符串描述。

### ArrayList

ArrayList 是一个采用类型参数的泛型类。需要指定数组列表保存的元素对象类型

### 开箱装箱

自动装箱规范要求 `boolean` 、`byte`、`char` <= 127，介于 `-128 ~ 127` 之间的 `short` 和 `int` 被包装到固定的对象中。`Integer`、`Long`、`Float`、`Double`、`Short`、`Byte`、派生于公共的超类 Number，`Character` 、`void`、`Boolean` 对象包装器类是不可变的，一旦构造器包装器，就不允许更改包装器的值。包装器类是 final 的 

### 继承的设计技巧

- 将公共操作和域放在超类
- 不要使用受保护的域
- 使用继承实现 “is-a” 关系
- 除非所有继承的方法都有意义，否则不要使用继承
- 在覆盖方法时，不要改变预期的行为：置换原则不仅应用于语法，而且也可以应用于行为。在覆盖一个方法的时候，不应该毫无原由地改变行为的内涵。
- 使用多态，而非类型信息，使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展
- 不要过多地使用反射：反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序，这种功能对于编写系统程序来说极其实用，但是通常不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。 

