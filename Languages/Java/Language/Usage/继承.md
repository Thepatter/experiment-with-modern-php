## 继承

### 类、超类、子类

#### 继承特性

* extends

  `is-a` 关系时继承的一个明显特征，关键字 `extends` 表示继承。在子类中可以增加域、增加方法或者覆盖超类的方法，然而绝对不能删除继承的任何域或方法

* override 覆盖方法

  父类的方法对子类不一定适用，子类可以使用一个新的方法来**覆盖（override）** 超类中的这个方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中这个相同签名的方法。覆盖一个方法的时候，子类方法不能低于超类方法的可见性。

* super 关键字

  super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。Java 使用关键字 super 调用超类的方法

* 子类构造器

  子类构造器不能访问父类的私有域，可以使用 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显示地调用超类的构造器，则将自动调用超类默认（无参）的构造器。如果超类没有无参构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误

* polymorphism 多态

  一个对象变量可以指示多种实际类型的现象，在运行时能够自动地选择调用那个方法的现象为动态绑定（dynamic binding）。动态绑定时默认的处理方式

* inheritance hierarchy 继承层次

  继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定的类到其祖先的路径为该类的**继承链**（inheritance chain）

#### 方法调用

对于 `x.f(args)`，隐式参数 x 声明为类 c 的一个对象。虚拟机调用过程：

1. 编译器查看对象的声明类型和方法名。假设调用 `x.f(param)`，且隐式参数 x 声明为 C 类的对象，有可能存在多个名字为 f，但参数类型不一样的方法。编译器将会一一列举所有 C 类中名为 `f` 的方法和其超类中访问属性为 `public` 的且名为 `f` 的方法，此时编译器获得所有可能被调用的候选方法
2. 编译器将查看调用方法时提供的参数类型。如果在所有名为 `f` 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。即**重载解析**（overloading resolution）。由于允许类型转换，所以这个过程很复杂，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。
3. 如果是 private 方法，static 方法，final 方法或者构造器，那么编译器将可以准确地知道应该调用那个方法，这种方式即**静态绑定**（static binding），与之对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定
4. 当程序允许时，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实际类型最适合的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此虚拟机预先为每个类创建了一个**放发表**（method  table），其中列出了所有方法的签名和实际调用的方法。这样，在真正调用方法的时候，虚拟机仅查找方法表就可以。

#### 阻止继承

如果在定义类的时候使用了 `final` 修饰符就表明这个类是  `final` 类，不允许扩展该类。类中特定的**方法如果声明为 `final` ，则子类不能覆盖这个方法**。域也可以被声明为 `final`。**对于 `final` 域，构造对象之后就不允许改变它们的值了**。如果将类声明为 `final`，只有其中的方法自动成为 `final`，而不包括域。

### Object 始祖类

Object 类是所有 Java 中所有类的始祖，在 Java 中每个类都是由它扩展而来的，如果没有明确指定超类，则 Object 被认为是这个类的超类

