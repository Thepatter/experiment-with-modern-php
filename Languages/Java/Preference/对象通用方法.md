## 所有对象的通用方法

### 覆盖 equals 时遵守通用约定

不覆盖 `equails` 方法，在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，即使期望的结果 

* **类的每个实例本质上都是唯一的**

  对于代表活动实体而不是值的类来说确实如此。

* **类没有必要提供逻辑相等的测试功能**

  如 `java.util.regex.Pattern` 可以覆盖 equals ，以检查两个 Pattern 实例是否代表同一个正则表达式。在这类情况下，从 Object 继承得到的 equals 实现已经足够

* **超类以及覆盖了 equals ，超类的行为对于这个类也是合适的**

  大多数的 Set、List、Map 实现都从 `Abstract` 类继承 `equals` 实现

* **类时私有的，或包级私有的，可以确定它的 equals 方法永远不会被调用**

如果类具有自己特有的 ”逻辑相等“ 概念（不等于对象等同的概念），而且超类还没有覆盖 `equals` 。这通常属于 ”值类” 的情形。值类仅仅是一个表示值的类，如 `Integer` 或 `String`。程序员在利用 `equals` 方法来比较值对象的引用时，希望直到它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。这样做也使得这个类的实例可以被用作映射表（map）的键（key），或者 Set 的元素，使映射或集合符合预期的行为。

实例受控确保每个值至多只存在一个对象的类，不需要覆盖 equals 方法，如枚举类。对于这种类型，逻辑相同和对象等同是同一件事。

#### 覆盖 `equals` 方法的通用约定

* **自反性（reflexive）**

  对于任何非 null 的引用值 x，`x.equlas(x)` 必须返回 true

* **对称性（symmetric）**

  对于任何非 null 的引用值 x 和 y，当且仅当 `y.equals(x)` 返回 true 时，`x.quals(y)` 必须返回 true

* **传递性（transitive）**

  对于任何非 null 的引用值 x，y，z，如果 `x.equals(y)` 返回 true，并且 `y.equals(z)` 也返回 `true`，那么 `x.quals(z)` 也必须返回 true

* **一致性（consistent）**

  对于任何非 null 的引用值 x 和 y，只要 `equals` 的比较操作在对象中所用的信息没有被修改，多次调用 `x.equals(y)`，就会一致的返回 true 或 false

* 对于任何非 null 的引用值 x，`x.equals(null)` 必须返回 false

使用 `==` 操作符检查“参数是否为这个对象的引用”。如果是，返回 true。这是一种性能优化，如果比较操作由可能很昂贵，就值得这么做

使用 `instanceof` 操作符检查“参数是否为正确的类型”。如果不是，则返回 false。一般来说：正确的类型是指 equals 方法所在的那个类。某些情况下，是指该类所实现的某个接口。如果类实现的接口改进了 `equals` 约定，允许在实现该接口的类之间进行比较，那么就使用接口。集合接口 `Set`、`List`、`Map`、`Map.Entry` 具有这样的特性