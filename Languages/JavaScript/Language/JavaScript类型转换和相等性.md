### JavaScript 类型转换和相等性

```
null == undefined		// true
"0" == 0				// true
0 == false				// true
"0" == false			// true
```

#### 显示类型转换

使用 Boolean(), Number(),String(),Object()函数

```
Number("3")			// 3
String(false)		// "false"
Boolean([])			// true
Object(3)			// new Number(3)
```

#### 对象转换为原始值

对象到布尔值的转换，所有的对象（包括数组和函数）都转换为 true，对于包装对象亦是如此。

对象到字符串和对象到数字的转换是通过调用待转换对象的一个方法来完成的，JavaScript 对象有两个不同的方法来执行转换。一种是通过 toString()，返回这个对象的字符串。`({x:1, y:2}).toString()  // => "[object Object]"`. 另一种为 valueOf()，如果存在任意原始值，它就默认将对象转换为表示它的原始值，如果对象是复合值，默认则返回对象本身。日期类返回 unix 毫秒数

### 变量作用域

一个变量的作用域(scope)是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在 JavaScript 代码中的任何地方都是有定义的。在函数内声明的变量只在函数体内有定义。是局部变量，作用域是局部性，函数参数也是局部变量，只在函数体内有定义

**在函数体内，局部变量的优先级高于同名的全局变量，如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所掩盖**

```
var scope = "global";		// 声明一个全局变量
function checkscope() {
  	var scope = "local";		// 声明一个同名的局部变量
  	return scope;
}
checkscope()				// "local"
```

**全局变量作用域声明是可以不加var,局部变量时则必须使用var**

```
scope = "global"; 			// 声明一个全局变量
function checkscope() {
  	scope = "local"			// 修改了全局变量
  	myscope = "local"		// 显示声明了新的全局变量
  	return [scope, myscope];	// 返回两个值
}
checkscope()			// ["local", "local"]
```

__函数作用域嵌套,每个函数都有它自己的作用域__

```
var scope = "global scope";			// 全局变量
function checkscope() {
  	var scope = "local scope";		// 局部变量
  	function nested() {
      	var scope = "nested scope";		// 嵌套作用域内的局部变量
      	return scope;					// 返回当前作用域内的值
  	}
  	return nested();					
}
checkscope()						// 嵌套作用域
```

#### 函数作用域和声明提前

**块级作用域 在类 C 语言的编程语言中，花括号内的每段代码都具有各自的作用域，而且变量在声明前它们的代码段之外是不可见的。JavaScript 中没有块级作用域。JavaScript 使用了函数作用域：变量在声明它们的函数体以及这个函数嵌套的任意函数体内都是有意义的。**

```
function test(o) {
  	var i = 0;
  	if (typeof 0 == "object") {
      	var j = 0;
      	for (var k = 0; k < 10; k++) {
          	console.log(k);
      	}
  	}
  	console.log(j);
}
```

**JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，意味着在变量声明前都已经可以使用，JavaScript 函数里声明的所有变量都被提前至函数体的顶部**，将变量声明放在函数体顶部，而不是将变量声明靠近放在使用变量之处，这种做法使得源代码可以清晰的反映真实的变量作用域。**当声明一个JavaScript 全局变量时，实际上是定义了全局对象的一个属性，当使用 var 声明一个变量时，创建的这个属性时不可配置的，无法通过 delete 删除。当没有使用养个模式并给一个未声明的变量赋值的话，JavaScript 会自动创建一个全局变量 。以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除**

```
var truevar = 1		// 声明一个不可删除的全局变量
fakevar = 2;		// 创建全局对象的一个可删除的属性
this.fakevar2 = 3;		// 创建全局对象的一个可删除的属性
delete truevar  		//	false: 	变量并没有被删除
delete fakevar			//  true:	变量被删除
delete this.fakevar2	// true:	变量被删除
```

__JavaScript 全局变量是全局对象的属性，可以使用 this 关键字来引用全局对象。局部变量当做根函数调用相关的某个对象的属性，该对象为”调用对象“或”声明上下文对象“__

#### 作用域链

**JavaScript 是基于词法作用域的语言：全局变量在程序中始终都是有定义的，局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的**

如果将一个局部变量看做是自定义实现的对象的属性的话，每一段 JavaScript 代码（全局代码或函数）都有一个与之关联的作用域链 （scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码”作用域中“的变量，当 JavaScript 需要查找变量 X 的值的时候，它会从链中的第一个对象开始查找，如果这个对象有一个名为 x 的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为 x 的属性，JavaScript 会继续查找链上的下一个对象。如果作用域链上没有任何一个对象含有属性 x，那么就会认为这段代码的作用域上不存在 x,并最终抛出一个引用错误 (ReferenceError)异常

在 JavaScript 的最顶层代码中(也就是不包含在任何函数定义内的代码),作用域链由一个全局对象组成，在不包含嵌套嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时候，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的便是函数调用作用域的“链”。对于嵌套函数来讲，每次调用外部函数时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。

