### 子查询

#### 子查询分类

子查询是一种嵌套查询，可以根据子查询是否执行多次，将子查询分为关联子查询和非关联子查询：子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，这样的子查询即**非关联子查询**；如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就是**关联子查询**。如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因为每执行一次外部查询，子查询都要重新计算一次，这样的子查询即是关联子查询，关联子查询，则需要将主查询的字段值传入子查询中进行关联查询

#### EXIST 子查询

关联子查询通常也会和 `EXISTS` 或 `NOT EXISTS` 一起来使用，EXISTS 子查询用来判断条件是否满足，满足的话为 TRUE，不满足为 FALSE。某些情况下，EXISTS 和 IN 可以得到相同的效果，具体使用那个执行效率更高，则需要看字段的索引情况以及表 A 和表 B 那个表更大。

```sql
SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)
```

在我们对 cc 列建立索引的情况下，我们还需要判断表 A 和表 B 的大小。表 A 比表 B 大，IN 子查询的效率要比 EXISTS 子查询效率高。如果表 A 比表 B 小，那么使用 EXISTS 效率更高

#### 集合比较子查询

集合比较子查询的作用是与另一个查询结果集进行比较，可以在子查询中使用 IN、ANY、ALL、SOME 操作符

* IN
  
  判断是否在集合中

  ```mysql
  select player_id, team_id, player_name from player where player_id in (select player_id from player_score where player.player_id = player_score.player_id)
  ```
  
* 在 `player_id` 列上存在索引得情况下，player 表比 player_score 大，in 查询效率更高，反之 exists 效率更高

* ANY

  需要与比较操作符一起使用，与子查询返回的任何值做比较

  ```mysql
  select player_id, player_name, height from player where height > any (select height from player where team_id = 1002)
  ```

* ALL

  需要与比较操作符(>, =, <, >=, <=, <>)一起使用，与子查询返回的所有值做比较

  ```mysql
  select player_id, player_name, height from player where height > all (select height from player where team_id = 1002)
  ```

* SOME

  ANY 的别名

ANY，ALL 关键字必须与一个比较操作符一起使用，如果不使用比较操作符，就起不到集合比较的作用。

#### 将子查询作为计算字段

子查询也可以作为主查询的计算字段

```mysql
select team_name, (select count(*) from player where player.team_id = team.team_id) as player_num from team
```

