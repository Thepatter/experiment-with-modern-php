### shell

#### 内置工具

##### 查看文件

###### cat

```shell
cat [option] parameter
```

连接文件并打印到标准输出设备

常用选项

| 选项 |             含义             |
| :--: | :--------------------------: |
|  -n  |  带行号输出，行号从 1 开始   |
|  -b  |  带行号输出，对空白行不编号  |
|  -s  |      合并多个空行为一行      |
|  -A  | 显示不可打印字符，行尾显示 $ |

###### zcat

显示压缩包中文件的内容，用于不真正解压文件，就能显示压缩包文件的内容的场合

常用选项

| 选项 |                          含义                          |
| :--: | :----------------------------------------------------: |
|  -c  | write on standard output，keep original compress links |
|  -d  |                       decompress                       |
|  -l  |             list compressed file contents              |
|  -t  |             test compressed file integrity             |

###### less

分屏浏览

常用选项

| 选项 |                含义                |
| :--: | :--------------------------------: |
|  -N  |              显示行号              |
|  nl  | 将文件每一行写入标准输出并添加行号 |

###### head

打印文件前 10 行到标准输出

常用选项

| 选项 |    含义    |
| :--: | :--------: |
|  -n  |  指定行数  |
|  -c  | 指定字符数 |

###### tail

显示文件尾部若干行

常用选项

| 选项 |                    含义                    |
| :--: | :----------------------------------------: |
|  -f  |                跟踪文件变化                |
|  -n  |                  指定行数                  |
|  -c  |                 指定字节数                 |
|  -s  | 秒数，与 -f 一起使用，指定监视文件间隔秒数 |

###### strings

在对象文件或二进制文件中查找可打印的字符串

常用选项

| 选项 |                      含义                      |
| :--: | :--------------------------------------------: |
|  -a  | 扫描整个文件而不是只扫描目标文件初始化和装载段 |
|  -f  |           在显示字符串前先显示文件名           |
|  -f  |         找到并输出所有 null 终止符序列         |
|  -t  |              输出字符，基于八进制              |

###### od

输出文件的八进制、十六进制或其他格式编码的字节

* -t：设置输出格式

###### hexdump

显示文件十六进制格式，一般用来查看二进制文件的十六进制编码

常用选项

| 选项 |                             含义                             |
| :--: | :----------------------------------------------------------: |
|  -n  |                         前 n 个字节                          |
|  -C  |                输出规范的十六进制和 ASCII 码                 |
|  -b  |                       单字节八进制显示                       |
|  -c  |                        单字节字符显示                        |
|  -d  |                       双字节十进制显示                       |
|  -o  |                       双字节八进制显示                       |
|  -x  |                      双字节十六进制显示                      |
|  -s  |                       从偏移量开始输出                       |
|  -e  | 指定格式字符串，格式字符串在一对单引号中: ‘a/b "format1" "format2" |

##### 文件属性

###### stat

显示文件和目录的属性

```shell
stat [options] files
```

常用选项

| 选项 |                    含义                    |
| :--: | :----------------------------------------: |
|  -t  |             简洁模式，单行输出             |
|  -L  |        跟踪符号链接，并报告指向文件        |
|  -f  | 现在文件所在文件系统信息而不是文件本身信息 |

###### wc

统计字节数、字数、行数

```shell
wc [options] [files]
```

| 选项 |                         含义                         |
| :--: | :--------------------------------------------------: |
|  -l  |                      仅输出行数                      |
|  -w  |                      仅输出字数                      |
|  -c  |                     仅输出字节数                     |
|  -L  | 找出每个文件中最长的行，并以字节为单位输出该行的长度 |

###### du

显示文件和目录的磁盘使用情况

```shell
du [options] [files | directories]
```

|  选项  |                  含义                  |
| :----: | :------------------------------------: |
| -b/k/m |         以字节/千字节/兆为单位         |
|   -L   |              跟踪符号链接              |
|   -s   |              仅输出总大小              |
|   -a   |        显示目录中个别文件的大小        |
|   -S   | 显示个别目录大小时，不显示其子目录大小 |
|   -h   |           适合人类的友好输出           |

###### file

识别文件类型

```shell
file [options] files
```

| 选项 |                            含义                            |
| :--: | :--------------------------------------------------------: |
|  -b  |                    忽略左边部分的文件名                    |
|  -i  |                      文件的 MIME 类型                      |
|  -f  | 从给定 file 文件中读取文件名，每行一个文件名，并报告其类型 |
|  -L  |                        跟踪符号链接                        |

###### touch

创建文件、更该文件和目录的时间戳

```shell
touch [options] files
```

| 选项 |            含义             |
| :--: | :-------------------------: |
|  -a  |          访问时间           |
|  -m  |          修改时间           |
|  -c  |        不存在不创建         |
|  -d  | 设置文件时间戳 -t 202008281 |

###### umask

设置限制新建文件权限掩码

```shell
# -P 输出的权限掩码之间作为指令来指向（8进制，默认 0022） -S 以字符方式输出权限掩码
umask [options] [mask]
# 设置新创建文件权限掩码
umask u=x, g=w, o=r
# 检查默认权限掩码
umask -S
```

###### chattr

改变文件属性，用来改变文件属性。可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有：

```shell
chatter [options][+ - =] attributes [files]
```

| 选项 |                             含义                             |
| :--: | :----------------------------------------------------------: |
|  a   | 只能进行追加，只能向文件中添加数据，而不能编辑数据，只有 root 才能设定这个属性 |
|  A   | 不访问时间戳，对这个文件进行访问不会更新其访问时间戳（atime) |
|  c   |       压缩，数据在写入的时自动压缩，在读取时自动解压缩       |
|  d   |               不转储，在进行备份时，忽略该文件               |
|  i   |  不可变，不允许对该文件进行更改或删除（仅 root 使用该属性）  |
|  j   |      文件在写入时会先被记录在 joural 中，仅限 ext3 系统      |
|  s   |          安全删除，删除时，用零覆盖文件中的所有数据          |
|  S   |                 同步更新，更改将立即写入磁盘                 |
|  u   |              不可删除，该文件不允许进行删除操作              |
|  R   |                             递归                             |
|  V   |                           显示过程                           |

###### lsattr

查看文件的第二扩展文件系统属性，`-D`，`-E`，`-R` 这三个选项互斥

```shell
lsattr option file
```

| 选项 |                             含义                             |
| :--: | :----------------------------------------------------------: |
|  E   |                     显示设备属性的当前值                     |
|  D   | 显示属性的名称、属性的默认值，描述用户是否可以修改属性值的标志 |
|  R   |                           递归操作                           |
|  a   |                  列出所有文件，包括隐藏文件                  |
|  d   |        如果显示目录的话，不显示其内容，仅显示目录本身        |

##### 文件查找

###### which

查找并显示文件绝对路径，会在环境变量 `PATH` 下查找文件

```shell
which option parameter
```

###### where

查找二进制程序、代码等相关文件路径，where 从数据库记录上查找，大写选项后跟目录在指定目录下查找

```shell
whereis option parameter
```

| 选项 |           含义           |
| :--: | :----------------------: |
|  -b  |     只查找二进制文件     |
|  -f  | 不显示文件名前的路径名称 |
|  -m  |     只查找 man 文件      |
|  -s  |    只查找原始代码文件    |
|  -u  | 查找不包含指定类型的文件 |

###### find

在一个或多个目录中进行搜索符合特定条件的文件。

```shell
find [directories] [expression]
```

|     选项      |                             含义                             |
| :-----------: | :----------------------------------------------------------: |
|     -name     |                      查找对象的文件名称                      |
|     -path     |                       查找对象的路径名                       |
|    -lname     |                       符号链接目标文件                       |
|    type/t     | 查找类型为  t 的文件，包含 f：普通文件 d 目录 l 符号链接 b 块设备 c 字符设备 p 命名管道 s 套接字 |
| -size N[bckw] | 查找大小为 N 的文件，单位可以是块（b)、单字节字符（c）、千字节（k）、双字节（w）+N 即 >N，-N 即 <N |
|    -empty     |                 查找大小为零的普通文件或目录                 |
|     -user     |                    查找属于给定用户的文件                    |
|    -group     |                   查找属于给定用户组的文件                   |

###### locate

##### 文件比较

###### diff

比较文件或目录差异，对两个文件或两个目录进行逐行比较，在比较文本时，`diff` 可以提供详细的差异报告。如果没有差异，不出生成任何输出

```shell
# 比较两个文件或文件夹不同
diff [options] file file
# 比较三个文件或文件夹
diff3 [options] file file1 file2
# diff 的饼状图输出
diffstat option file file
```

|   选项   |                             含义                             |
| :------: | :----------------------------------------------------------: |
|    -n    |             使用 rcsdiff 命令的 RCS 版本控制格式             |
|    -c    |            使用上下文输出格式，供 patch 命令使用             |
| -D macro |  c 预处理器格式，即 #ifdef macro ... #else ... #endif 格式   |
|    -u    | 一体化输出格式，它会对文件进行合并处理，- 表示删除，+ 表示添加 |
|    -y    |              并排格式，使用 -W 来调整输出的宽度              |
|    -e    |  创建一个 ed 脚本，如果运行该脚本，将会把 fileA 变为 fileB   |
|    -q    |             不报告发生的变化，仅指出是否存在差异             |
|    -b    |                          不考虑空格                          |
|    -B    |                         不考虑空白行                         |
|    -i    |                          忽略大小写                          |
|    -r    |                  比较目录时，递归检查子目录                  |

###### comm

排序文件比较，比较两个已排序的文件，并生成由三列组成的输出，各列之间以制表符分隔（第一行显示所有出现在 file1 中但不在 file2 中的行；第二行显示出现在 file2 中但不在 file1 中行；第三行显示所有同时出现在两个文件中的行）

```
comm [options] sort_file sort_file2
```

| 选项 |                  含义                  |
| :--: | :------------------------------------: |
|  -1  |             不显示第 1 列              |
|  -2  |             不显示第 2 列              |
|  -3  |             不显示第 3 列              |
| -23  |      显示仅在第一个文件中出现的行      |
| -13  |      显示仅在第二个文件中出现的行      |
| -12  | 显示同时出现在第一个和第二个文件中的行 |

###### cmp

比较两个文件是否有差异，比较两个文件。如果它们的内容是一样的，那么 cmp 不会输出任何内容；否则它会给出第一处差异所在的位置

```shell
cmp [options] parameter
```

| 选项 |                             含义                             |
| :--: | :----------------------------------------------------------: |
|  -l  |                  长输出，逐字节输出所有差异                  |
|  -s  | 静默输出，不打印任何东西，如果文件匹配返回 0，不匹配返回 1，失败返回其他代码 |

###### shasum

比较哈希值

```shell
md5sum file
shasum file
# SHA-256 算法
shasum -a 256 file
```

##### 文本处理

###### grep

正则匹配一个或多个文件，给定一个或多个文件，输出其中与特定正则表达式模式匹配的所有行

```shell
grep [options] pattern [files]
```

|       选项       |                          含义                          |
| :--------------: | :----------------------------------------------------: |
|        -v        |              只输出与正则表达式不匹配的行              |
|        -l        |    仅输出包含匹配行的文件的名称，而不是输出匹配的行    |
|        -L        |             仅输出不包含匹配行的文件的名称             |
|        -c        |                    仅输出匹配的行数                    |
|        -n        |     在输出匹配结果的时候，每行的前面给出其原始行号     |
|        -b        | 在输出匹配结果的时候，每行的前面给出其文件中的偏移字节 |
|        -i        |                   匹配时不区分大小写                   |
|        -w        |                    只匹配完整的单词                    |
|        -x        |           仅匹配完整的行，优先级高于 -w 选项           |
|       -A N       |         输出匹配行，以及位于匹配行之后的 N 行          |
|       -B N       |         输出匹配行，以及位于匹配行之前的 N 行          |
|       -C N       |         输出匹配行，以及位于匹配行前后的 N 行          |
| --color = always |          突出显示匹配文件的颜色，以提高可读性          |
|        -r        |           递归搜索目录及其子目录中的所有文件           |
|        -E        |                   使用扩展正则表达式                   |
|        -F        |         使用固定的字符串列表，而不是正则表达式         |

###### cut

提取文件，从文件中提取文本列。

```shell
cut -(b|c|f) range [options] [files]
# 提取第五个字符之后全部字符
cut -c5- file
# fields 指定了从 file 中要提取的字段，字段号从 1 开始
cut -ddelimiter -ffields file
cut -d: -f1 /etc/passwd
# 如果字段是由制表符分隔的，可以使用 -f 选项
```

|          选项          |                             含义                             |
| :--------------------: | :----------------------------------------------------------: |
|           -c           |                         列由字符偏移                         |
|           -b           |                         列由字节偏移                         |
|          -d C          | 使用字符 C 作为 -f 选项的字段之间的输入分隔符，默认使用制表符 |
| --output-delimiter = c | 使用字符 C 作为 -f 选择的字段字节的输出分隔符，默认为制表符  |
|           -s           |                     排除不包含分隔符的行                     |

###### paste

合并文件，将多个文件视为垂直列，并将它们合并到标准输出上

```shell
paste [options] [files]
paste files
# 可以是一个或多个字符，粘贴分隔在一起的行，chars中的第一个字符用来分隔来自第一个文件和第二个文件的行，第二个字符用来分隔来自第二个文件和第三个文件的行，以此类推。如果文件的数量比 chars 中列出的字符要多，paste 会绕回重新分隔
paste -d '+' file1 file2
# 只从同一个文件中粘贴行，不管其他文件。如果只指定了单个文件，其效果是将该文件中所有的行合并到一起，彼此之间用制表符分隔（或是由 -d 选项指定的分隔符）
paste -d'' -s names
```

|     选项      |                             含义                             |
| :-----------: | :----------------------------------------------------------: |
| -d delimiters | 使用分隔符来分隔各列；默认使用制表符，可以提供一个单个字符来分割，并使用使用该字符分割 |
|     -dxyz     |                 使用字符列表将其依次用于各行                 |
|      -s       |                    将输出的行和列进行转置                    |

###### tr

将一组字符转换为另一组字符

```shell
tr [options] charset [charset]
```

|        tr命令         |                             描述                             |
| :-------------------: | :----------------------------------------------------------: |
|      tr 'X' 'x'       |                        将所有X替换成x                        |
|     tr '()' '{}'      |                     将所有 () 替换成 {}                      |
|  tr '[a-z]' '[A-Z]'   |                将所有的小写字母转换成大写字母                |
| tr '[A-Z]' '[N-ZA-M]' |      将所有的大写字母A-M 替换成 N-Z，将 N~Z 转换成 A~M       |
|       tr ' '''        |        将所有的制表符（第一对引号中的字符）转换成空格        |
|      tr -s ''''       |                   将多个空格转换成单个空格                   |
|      tr -d '\14'      |                 删除所有换页符（八进制为14）                 |
|     tr -d '[0-9]'     |                         删除所有数字                         |
|          -d           |             从输入中删除包含在 charset1 中的字符             |
|          -s           |                 从输入中删除那些连续重置字符                 |
|          -c           |               只对 charset1 之外的字符进行操作               |
|          -t           | 如果 charset1 长于 charset2，截断 charset1 使其相等，如果没有提供 -t，则不断复制 charset2 最后一个字符，使其长度相等 |

###### tee

将数据重定向到标准输入和文件

```shell
tee option parameter
```

| 选项 |             含义             |
| :--: | :--------------------------: |
|  -a  | 向文件中重定向时使用追加模式 |
|  -i  |         忽略中断信号         |

###### sed

流编辑器，用来在管道或命令序列中编辑数据。它是 stream editor（流编辑器）的简称。并非交互式程序，默认情况下 `sed` 将输入的每一行都写入到标准输出中，不管其内容是否发生了变化。`-n` 指定不打印任何行，`p` 命令可以打印处符合指定范围或模式的所有行

|              命令               |                             描述                             |
| :-----------------------------: | :----------------------------------------------------------: |
|           `sed '5d'`            |                          删除第5行                           |
|       `sed '/[Tt]est/d'`        |                删除包含 Test 或 test 的所有行                |
|     `sed -n '20,25p' text`      |               只打印 text 文件中第 20 ~ 25 行                |
| `sed '1,10s/unix/UNIX/g' intro` |           将 intro 文件的前10行中的 unix 改成 UNIX           |
|      `sed '/jan/s/-1/-5/'`      |           将包含 jan 的所有行中的第一个 -1 改成 -5           |
|      `sed 's/...//' data`       |                  删除 data 中每行前3个字符                   |
|      `sed 's/...$//' data`      |                 删除 data 中每行后 3 个字符                  |
|       `sed -n '\|' text`        | 打印出 text 文件中所有的行，将不可打印字符显示为 `\nn`(八进制)，将制表符显示为 `\t` |

###### sort

排序，将文件进行排序，并将排序结果标准输出，既可以从特定文件，页可以从标准输入

| 选项 |                            含义                            |
| :--: | :--------------------------------------------------------: |
|  -b  |                  忽略每行开始处的空格字符                  |
|  -c  |                 检查文件是否已经按顺序排序                 |
|  -d  |        排序时，处理英文字母数字和空格，忽略其他字符        |
|  -f  |               排序时，将小写字母视为大写字母               |
|  -i  | 排序时，除了 040 ~ 176 之间的 ASCII 字符外，忽略其他的字符 |
|  -m  |                 将几个排序好的文件进行合并                 |
|  -M  |              将前面三个字母依照月份的缩写排序              |
|  -u  |                        消除重复的行                        |
|  -r  |                          逆序排序                          |
|  -o  |                        指定输出文件                        |
|  -n  |                  将行中第一个字段视为数字                  |
| -k2n |                    从第二个字段开始排序                    |
|  -t  |          后字符被视为分隔符，指定培训时所用的栏位          |

###### uniq

去重

```shell
uniq option paramter
```

| 选项 | 含义                             |
| ---- | -------------------------------- |
| -c   | 在每列旁边显示该行重复出现的次数 |
| -d   | 仅显示重复出现的行               |
| -u   | 仅显示出一列的行                 |
| -w   | 后跟字符位置，指定要比较的字符   |

##### 读取

###### read

```shell
read variables
```

shell 会从标准输入中读取一行，然后将第一个单词分配给 variables 中列出的第一个变量，第二个单词分配给第二个变量，以此类推，如果行中的单词多于列表中的变量，那么多出的单词全部分配给最后一个变量。

用户在 shell 输入命令后，shell 会在当前用户 PATH 下寻找对应命令，可以将编译后的二进制文件链接到 PATH 路径下来使用该文件

```shell
# 查看当前环境变量
echo $PATH
# 添加path
export PATH=$PATH:<PATH1>:<PATH2>
# 编辑 .bash_profile
export PATH=$PATH:/usr/bin:/usr/sbin
source .bash_profile
```

##### 任务执行

###### jobs

列出当前 shell 中运行的作业，左侧的整数是作业编号，带加号的作业被当做默认作业。在使用 fg 和 bg 命令时，如果未在命令行指定任何作业编号的话，带加号的作业被当成作业控制命令的操作对象

|      选项       |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
|        &        |          放在命令行末尾时，让该命令作为后台作业运行          |
|       ^Z        | 挂起当前作业，可以输入 bg 将命令放入后台运行或输入 fg 使其在前台运行 |
|     suspend     |                       将挂起当前 shell                       |
| bg [%jobnumber] | 让挂起的作业在后台运行。当不使用参数的时候，操作对象为最近挂起的作业。 |
| fg [%jobnumber] |              让挂起的作业或后台作业到前台运行。              |

###### screen

|      选项      |                含义                 |
| :------------: | :---------------------------------: |
|      ^A?       |         显示所有组合键命令          |
|      ^A^C      |            创建一个窗口             |
| ^A0, ^A1...^A9 |         分别切换到窗口 0-9          |
|      ^A'       | 提示窗口号（0-9），然后切换到该窗口 |
|      ^A^N      |     以数字方式切换到下一个创建      |
|      ^A^P      |     以数字方式切换到上一个窗口      |
|      ^A^A      |      切换到最近使用的其他窗口       |
|      ^A^W      |           列出所有的窗口            |
|      ^AN       |           显示当前窗口号            |
|       ^D       |           终止当前 shell            |

#### 脚本

##### 语法

###### 环境变量

用户在 shell 输入命令后，shell 会在当前用户 PATH 下寻找对应命令，可以将编译后的二进制文件链接到 PATH 路径下来使用该文件

```shell
# 查看当前环境变量
echo $PATH
# 添加path
export PATH=$PATH:<PATH1>:<PATH2>
# 编辑 .bash_profile
export PATH=$PATH:/usr/bin:/usr/sbin
source .bash_profile
```

###### 变量

<u>变量名以字母或下划线开头，后面可以跟上零个或多个字母及数字字符或下划线，变量在使用前不需要声明，在用时直接赋值就行，变量赋值等号两边不能有空格，shell 没有数据类型，只有字符串</u>

* {} 操作符

    避免歧义，只有在变量名的最后一个字符后面跟的是字母及数字字符或下划线的时候才有必要使用花括号

* 整数运算操作

    $((expression))

###### 引用

shell 能够识别 4 种不同的引用字符：

* 单引号

    忽略所有特殊字符，给变量赋值，其中包含空白字符或其他特殊字符

* 双引号

    作用类似单引号，忽略大部分特殊字符（$，反引号，反斜线）

* 反斜线

    转义字符，作为一行最后一个字符续行

* 反引号

    将其中的命令使用命令输出代替

###### 命令替换

shell 能够在命令行中的任何位置使用命令的输出来替换特定的命令：将命令放在反引号中或放在 $(...) 中，替换命令支持多个命令，用分号分隔，还可以使用管道

```shell
echo current path: `pwd`
# 等效
echo current path: $(pwd;date)
# 单引号中命令会原样输出
echo '$(who | wc -l) tells how many users ar logged in'
# 双引号中会替换执行
echo "$(ls | wc -l) files in your directory"
```

shell 是在替换过命令输出后才执行文件名替换。将命令放在双引号中能够阻止 shell 针对命令的输出再做文件名替换。

###### 内置算术操作符

expr 能够识别常用的算术操作符：+，-，/，*，%，操作数与操作符必须用空格分隔。

```shell
# 转义 * 不然会报错
echo $(expr 12 \* 2)
```

###### 传参

* 位置参数

    执行 Shell 程序，Shell 会自动将第一个参数保存在特殊的 Shell 变量 1 中，将第二个参数保存在 Shell 变量 2 中，即位置参数（基于参数在命令行中所处的位置）是在 Shell 完成正常的命令行处理之后（I/O 重定向，变量替换，文件名替换）被赋值的。当需要访问第 10 个参数时 ${10}

* 参数个数

    $# 变量包含了命令行中输入的参数个数

* 所有参数

    $* 引用的是传给程序的所有参数

* 移动参数

    shift 命令会向左移动位置参数，`$2` 中的内容会分配给 `$1`，`$1` 中的旧值会丢失，`$#` 值会减 1。如果在没有位置参数可移动的情况下（`$#` 已经为 0）的时候使用 shift，Shell 会发出错误信息。可以在 shift 后加数字，指定一次移动多个位置 shift 3

###### 条件语句

只要程序执行完成，就会向 shell 返回一个退出状态码。这个状态码是一个数值，指明了程序运行是否成功。0 表示程序运行成功；非 0 的退出状态码表示程序运行失败，不同的值对应着不同的失败原因；对于管道，退出状态对应的是管道中的最后一个命令

*   if

    ```shell
    if command1
    then
    	command
    	command
    fi
    ```

    command1 是要执行的命令，命令的退出状态会被测试。如果退出状态为 0，执行 then 和 fi 之间的命令，否则，跳过这些命令；

    if 命令中可以加入 else，commandt 会被执行并对其退出状态求值。如果为 0，执行 then 代码块，并忽略 else 代码块。如果为非 0，则忽略 then 代码块，执行 else 代码块

    ```shell
    if commandt
    then
    	command
    	command
    else
    	command
    	command
    fi
    # 简洁模式
    if condition then statements-if-true else statement-if-false fi
    ```

    shell 支持特殊的 elfi，其行为类似于 `else if <em> condition`，但它不会增加嵌套层级

    ```shell
    hour=$(date | cut -c12-13)
    if ["$hour" -ge 0 -a "$hour" -le 11 ]
    then
    	echo "Good morning"
    elif [ "$hour" -ge 12 -a "$hour" -le 17 ]
    then
    	echo "Good afternoon"
    else
    	echo "Good evening"
    ```

*   case

    可以将单个值与一组值或表达式进行比较，在有匹配的时候执行一个或多个命令，可以使用正则表达式

    ```shell
    case value in
    pattern1)
    	command;;
    pattern2)
    	command;;
    pattern3)
    	command;;
    esac
    ```

    shell 会将变量 $? 自动设置为最后一条命令的退出状态。

    test 命令测试单个或多个条件

    test expression，expression 描述了待测试的条件。test 会对 expression 求值，如果结果为真，返回为 0 的退出状态码；如果结果为假，返回非 0 的退出状态码。操作符 = 用来测试两个值是否一样。test 命令所有的操作数和操作符都必须是独立的参数，彼此之间必须使用一个或多个空白字符分隔。

    if 语句会测试 test 返回的退出状态。如果为 0，执行 then 和 fi 之间的命令，否则跳过

    *test字符串操作符*

    |       操作符       |        为真条件        |
    | :----------------: | :--------------------: |
    | string1 = string2  |  string1 等于 string2  |
    | string1 != string2 | string1 不等于 string2 |
    |       string       |     string 不为空      |
    |     -n string      |     string 不为空      |
    |     -z string      |      string 为空       |

    使用另外一种格式来表示：

    ```shell
    # [ expression ]
    if [ "$name" = julio ]
    then
    	echo "Would you like to play a game?"
    fi
    ```

    *test整数操作符*

    |    操作符     |       为真条件       |
    | :-----------: | :------------------: |
    | int1 -eq int2 |    int1 等于 int2    |
    | int1 -ge int2 | int1 大于或等于 int2 |
    | int1 -gt int2 |    int1 大于 int2    |
    | int1 -le int2 | int1 小于或等于 int2 |
    | int1 -lt int2 |    int1 小于 int2    |
    | int1 -ne int2 |   int1 不等于 int2   |

    在使用整数操作符时，将变量的值视为整数的是 test 命令，而非 shell，因为无论 shell 变量的类型是什么，都能够进行比较

    *常用的 test 文件操作符*

    | 操作符  |      为真条件       |
    | :-----: | :-----------------: |
    | -d file |   file 是一个目录   |
    | -e file |      file 存在      |
    | -f file | file 是一个普通文件 |
    | -r file |  file 可由进程读取  |
    | -s file |   file 不是空文件   |
    | -w file |  file 可有进程写入  |
    | -x file |   file 是可执行的   |
    | -L file | file 是一个符号链接 |

    *逻辑操作符*

    ! 取反，-a 与，-o 或

    在 test 表达式中利用括号来根据需要改变求值顺序，要对括号本身转义，括号两边必须有空格。test 要求条件语句中的每一个元素都是独立的

    ```shell
    [ \( "$count" -ge 0 \) -a \("$count" -lt 10 \) ]
    ```


    case 支持正则匹配。

###### exit

shell 内建的 exit 命令可以立即终止 shell 程序的执行

```shell
exit n
```

n 是状态码，如果未指定，则使用在 exit 之前最后执行那条命令的退出状态

###### 调试选项

要调试 shell 可以在程序正常的调用（名字及参数）之前输入 sh -x 以跟踪器执行过程。在该模式下，命令在执行的同时会被打印在终端中，并在其之前加上一个 + 号

###### 循环

一直使用 break 命令跳出循环，可以指定跳出层级，使用 continue 跳过当前循环余下命令，或跳出最内层 n 个命令，可以在 done 语句后加上 & 来让循环在后台执行

*   for

    for 命令可以执行指定次数的一个或多个命令

    ```shell
    for var in word word1 ... wordn
    do
    	command
    	command
    done
    ```

    do 与 done 之间为循环体，其执行次数由 in 后面的列表条目个数而定。在执行循环时，第一个单词 word 被赋给 var，然后执行循环体，接着 word1 直到 wordn 依次赋给 var，再执行循环体，for 命令执行结束

    ```shell
    for var # 等效 for var in "$@"
    do
     	command
    done
    ```

    忽略 in 以及后续的列表，shell 自动遍历命令行中输入的所有参数

*   while

    ```shell
    while commandt
    do
    	command
    	command
    done
    ```

    执行 commandt 并测试其退出状态。如果为 0，执行一次 do 与 done 之间的命令。然后再次执行 commandt 并测试其退出状态。如果为 0，继续执行 do 和 done 之间的命令。一直持续到 commandt 返回非 0 的状态码，此时循环结束。如果 commandt 在首次执行时返回非 0 的退出状态码，那么 do 和 done 之间的命令不会执行

###### until

只要测试表达式返回非 0，until 就会一直执行，直到返回 0 为止，如果 commandt 首次执行的时候就返回 0，do 和 done 之间的命名一次都不执行

```shell
until commandt
do
	command
done
```

