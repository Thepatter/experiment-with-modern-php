## CPU 使用率

### CPU 使用率

Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核表示为 HZ），触发时间中断，并使用全局变量 `Jiffies` 记录了开机以来的节拍数。每发生一次时间中断，`Jiffies` 的值就加 1

节拍率 HZ 是内核的可配选项，可以设置为 100，250，1000 等。不同的系统可能设置不同数值，可以通过查询 `/boot/config` 内核选项来查看它的配置值。

```shell
# 查看系统节拍率
grep 'CONFIG_HZ=' /boot/config-$(uname -r)
```

因为节拍率是内核选项，所以用户空间程序并不能直接访问。为了方便用户空间程序，内核还提供了一个用户空间节拍率 `USER_HZ`，它总是固定 100，即使 1/100 秒。这样，用户空间程序并不需要关心内核中 HZ 被设置成多了，因为它看到的总是固定值 USER_HZ

Linux 通过 `/proc` 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 `/proc/stat` 提供的就是系统的 CPU 和任务统计信息。

```shell
# 查看 CPU 时间
cat /proc/stat | grep cpu
```

这里的输出结果是一个表格。第一列表示的是 CPU 编号，如 `cpu0`，`cpu1`，而第一行没有编号的 cpu，表示的是所有 CPU 的累加。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 USER_HZ，也就是 10 ms (1/100 秒)，即不同场景下的 CPU 时间

### CPU 相关指标

* `user`（缩写为 `us`），代表用户态 CPU 时间，它不包括 `nice` 时间，但包括 `guest` 时间
* `nice`（缩写为 `ni`），代表低优先级用户态 CPU 时间，即进程的 `nice` 值被调整为 1-19 之间时的 CPU 时间。（`nice`的取值范围 -20 ~ 19，数值越大，优先级反而越低）
* `system`（缩写为 `sys`），代表内核态 CPU 时间
* `idle` (缩写为`id`)，代表空闲时间，不包括等待 I/O 的时间（`iowait`)
* `iowait`（缩写为 `wa`），代表等待 I/O 的 CPU 时间
* `irq`（缩写为 `hi`），代表处理硬中断 CPU 时间
* `softirq`（缩写为 `si`），代表处理软中断的 CPU  时间
* `steal`（缩写为 `st`），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间
* `guest`（缩写为 `guest`），代表通过虚拟化运行其他操心系统的时间，即运行虚拟机 CPU 时间
* `guest_nice` (缩写为 `gnice`)，代表以低优先级运行虚拟机的时间

**CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比**。根据 `/proc/stat` 中的数据，可以计算出 CPU 使用率，也可以用每一个场景的 CPU 时间，除以总的 CPU 时间，计算出每个场景 CPU 使用率。但直接用 `/proc/stat` 的数据，计算的是开机以来的平均 CPU 使用率，几乎无参考价值

事实上，为了计算 CPU 使用率，性能工具一般都会取间隔一段的两次值，作差后，再计算出这段时间内的平均 CPU 使用率。

