## 快速使用 docker

### 安装配置及卸载

#### 基于 ubuntu 安装

```shell
# 删除旧版本
sudo apt remove docker docker-engine docker.io
# 安装依赖
sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common
# 信任 GPG 公钥
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
# 使用 mirror
sudo add-apt-repository \
	"deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \
	stable"
# 安装 docker-ce
sudo apt update
sudo apt install docker-ce
# 添加用户到 docker 组
sudo usermod -aG docker your-user
# 配置 daemon
sudo systemctl enable docker
# 卸载
sudo apt purge docker-ce
```

#### 配置

##### 允许接受来自远程主机登录

默认情况下，Docker 守护程序监听 unix 套接字上的连接以接受来自本地客户端的请求。通过将 `docker` 配置为监听 IP 地址以及 Unix 套接字，可以允许 `Docker` 接受来自远程主机的请求。可以使用 `docker.service` 或 `daemon.json`，但是不能两个一起使用

* `docker.service`

  ```shell
  # 编辑
  sudo systemctl edit docker.service
  # 添加或修改
  [Service]
  ExecStart=
  ExecStart=/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375
  # 重载
  systemctl daemon-reload
  # 重启
  sudo systemctl restart docker.service
  ```

* `daemon.json`

  ```shell
  # /etc/docker/daemon.json
  {
      "hosts": ["unix:///var/run/docker.sock", "tcp://127.0.0.1:2375"]
  }
  # 重启
  sudo systemctl restart docker.service
  ```

### 镜像

#### 常用操作

```shell
# 拉取镜像
docker pull NAME[:TAG]
# 列出镜像
docker images
# 查看镜像详情
docker inspect ubuntu:18.04
docker inspcet -f {{'.Architecture'}} ubuntu:18.04
# 查看镜像历史
docker history ubuntu:18.04
# 使用此目录的 Dockerfile 创建镜像
docker build -t friendlyhello . 
# 使用 tag 命令添加镜像标签
docker image tag ubuntu:latest myubunut:latest
# 搜索镜像
docker search [option] keyword
-f, --filter 过滤输出内容
--format string: 格式化输出内容
--limit int 限制输出个数
--no-trunc 不解读按输出结果
docker search --filter=is-official=true nginx
# 删除镜像
docker rmi IMAGE[IMAGE...]/docker image rm
-f, -force 强制删除，即使有容器依赖
--no-prune 不要清理未带标签的父镜像
# 清理镜像
docker image prune [option]
-a, -all: 删除所有无用镜像，不光是临时镜像
-filter filter: 只清理符合给定过滤器的镜像
-f, -force: 强制删除镜像
# 登录
docker login
# 发布
docker push <username>/<repository>:<tag>
docker image push yewandeyu/test:0.0.1
```

#### 创建镜像

##### 基于已有容器创建

```shell
docker [container] commit
docker [container] commit [OPTIONS] CONTAINER[REPSOTPRY][:TAG]
```

-a, --author=“”：作者信息

-c, --change=[]: 提交时执行的 dockerfile 指令，包含：CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR

-m, --message="": 提交信息

-p, --pause=true: 提交时暂停容器运行

##### 基于本地模板导入

可以直接从一个操作系统模板文件导入一个镜像，使用

```shell
docker[container]import
docker[image]import[options]file|url|-[repository[:tag]
cat ubuntu-18.04-x86_64-minimal.tar.gz | docker import - ubuntu:18.04
```

##### 基于 Dockerfile

Dockerfile 使用 DSL 指令来构建一个 Docker 进行，在初始目录里创建 Dockerfile 文件，这个目录就是构建环境，docker 以此作为构建上下文，docker 会在构建镜像时将构建上下文和该上下文中的文件目录上传到 docker 守护进程，Dockerfile 由一系列指令和参数组成，指令必须大写，指令会从上到下顺序执行，每条指令都会创建一个新的镜像层并对镜像进行提交

一般，Dockerfile 主体内容分为：基础镜像信息，维护者信息，镜像操作和容器启动时执行指令。首行可以用注释来指导解析命令，后续通过注释说明镜像的相关信息。主题不符首先使用 FROM 指令指明所基于的镜像名称，后面则是镜像操作指令，最后时 CMD 指令，来指定运行容器时的操作指令

Dockerfile 中指令的一般格式为 `INSTRUCTION arguments`，包括“配置指令”（配置镜像信息）和“操作指令”（具体执行操作）

*配置指令*

|    指令     |                说明                |
| :---------: | :--------------------------------: |
|     ARG     |    定义创建镜像过程中使用的变量    |
|    FROM     |      指定所创建镜像的基础镜像      |
|    LABEL    |   为生产的镜像添加元数据标签信息   |
|   EXPOSE    |      声明镜像内服务监听的端口      |
|     ENV     |            指定环境变量            |
| ENTRYPOINT  |       指定镜像的默认入口命令       |
|   VOLUME    |        创建一个数据卷挂载点        |
|    USER     |    指定运行容器时的用户名或 UID    |
|   WORKDIR   |            配置工作目录            |
|   ONBUILD   | 创建子镜像时指定自动执行的操作指令 |
| STOPSIGNAL  |          指定退出的信号值          |
| HEALTHCHECK |   配置所启动容器如何进行健康检查   |
|    SHELL    |        指定默认 shell 类型         |

* ARG

  `ARG <name> [=<default value>]`

  在执行 docker build 时，可以通过 `-build-arg[=]` 来为变量赋值。当镜像编译成功后，ARG 指定的变量将不再存在（ENV 指定的变量将在镜像中保留）

  Docker 内置了一些镜像创建变量，用户可以直接使用而无须声明，包括（不区分大小写）HTTP_PROXY、HTTPS_PROXY、FTP_PROXY、NO_PROXY

* FROM

  `FROM<image>[AS<name>]` 或 `FROM<image>:<tag>[AS<name>]` 或 `FROM<image>@<digest>[AS<name>]`

  任何 Dockerfile 中第一条指令必须为 From 指令，并且，如果在同一个 Dockerfile 中创建多个镜像时，可以使用多个 FROM 指令（每个镜像一次）

* LABEL

  `LABLE<key>=<value><key>=<value>...`

  为生成的镜像添加元数据标签信息，这些信息用来辅助过滤出特定镜像

* EXPOSE

  `EXPOSE<port>[<port>/<protocol>...]`

  声明镜像内服务监听的端口，该指令只起到声明作用，并不会自动完成端口映射。如果要映射端口出来，在启动容器时可以使用 `-P` 参数

* ENV

  `ENV <key><value>` 或 `ENV<key>=<value>...`

  指定环境变量，在镜像生成过程中会被后续 RUN  指令使用，在镜像启动的容器中也会存在。指令指定的环境变量在运行时可以被覆盖掉，如 `docker run --env<key>=<value> built_image`

  当一条 ENV 指令中同时为多个环境变量赋值并且值也是从环境变量读取时，会为变量都赋值后再更新

  ```dockerfile
  # 结果为 key1=value1 key2=value2
  ENV key1=value2
  ENV key1=value1 key2=${key1}
  ```

* ENTRYPOINT

  `ENTRYPOINT["executable", "param1", "param2"]` ：exec 调用执行

  `ENTRYPOINT command param1 param2`: shell 中执行，此时 CMD 指令指定值将作为根命令的参数

  指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效，在运行时，可以被 `--entrypoint` 参数覆盖掉

* VOLUME

  `VOLUME["/data"]`

  创建一个数据卷挂载点，运行容器时可以从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保持的数据

* USER

  `USER daemon`

  指定运行容器时的用户名或 UID，后续的 RUN 等指令也会使用指定的用户身份，当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在 Dockerfile 中创建所需要的用户，默认为 root

  ```dockerfile
  RUN groupadd -r postgres && useradd --no-log-init -r -g postgres postgres
  ```

  要临时获取管理员权限可以使用 gosu 命令

* WORKDIR

  `WORKDIR /path/to/workdir`

  为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录，可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径：

  ```dockerfile
  WORKDIR /a
  WORKDIR b
  WORKDIR c
  # 最终路径为 /a/b/c
  RUN pwd
  ```

  推荐只使用绝对路径，`-w` 参数会覆盖该指令

* ONBUILD

  `ONBUILD [INSTRUCTION]`

  指定当基于所生成镜像创建子镜像时，自动执行的操作指令，`ONBUILD` 指令是隐式执行的，推荐在使用它的镜像标签中进行标注，`ONBUILD` 指令在创建专门用于自动编译、检查等操作的基础镜像时，十分有用。当一个镜像被用作其它镜像的基础镜像时，该镜像的 onbuild 指令会被执行

* STOPSIGNAL

  `STOPSIGNAL signal`

  指定所创建镜像启动的容器接收退出的信号值，这个喜好必须是内核系统调用表中合法的数

* HEALTHCHECK

  `HEALTHCHECK[OPTIONS]CMD command`：根据所执行命令返回值是否为 0 来判断

  `HEALTHCHECK NONE`：禁止基础镜像中的健康检查

  `OPTION` 支持如下参数：

  `-interval=DURATION(default: 30s)`：过多久检查一次；

  `-timeout=DURATION(default: 30s)`：每次检查等待结果的超时

  `-retries=N(default:3)`：如果失败了，重试几次才最终确定失败

  配置所启动容器如何进行健康检查（如何判断健康与否），1.12 开始支持

* SHELL

  `SHELL ["executable", "parameters"]`

  指定其他命令使用 shell 时的默认 shell 类型，默认为 `["/bin/sh", "-c"]`

  对于 Windows 系统，Shell 路径中使用了 `\` 作为分隔符，建议在 Dockerfile 开头添加 `#escape=` 来指定转义符

*操作指令*

| 指令 |             说明             |
| :--: | :--------------------------: |
| RUN  |         运行指定命令         |
| CMD  | 启动容器时指定默认执行的命令 |
| ADD  |        添加内容到镜像        |
| COPY |        复制内容到镜像        |

* RUN

  运行指定命令

  `RUN<command>` 或 `RUN ["executable", "param1", "param2"]`

  前者默认将在 shell 终端中运行命令 `/bin/sh -c`，后者指令会被解析为 JSON 数组，必须使用双引号，使用 exec 执行，不会启动 shell 环境。每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像层。当命令较长时可以使用 `\` 来换行

  ```dockerfile
  RUN apt-get update \
  　　&& apt-get install -y libsnappy-dev zlib1g-dev libbz2-dev \
  　　&& rm -rf /var/cache/apt \
  　　&& rm -rf /var/lib/apt/lists/
  ```

* CMD

  指令用来指定启动容器时默认执行的命令，支持三种格式：

  `CMD["executable", "param1", "param2"]`：相当于执行 `executable param1 param2`，推荐方式

  `CMD command param1 param2`：在默认的 shell 中执行，提供给需要交互的应用

  `CMD["param1", "param2"]`：提供给 ENTRYPOINT 的默认参数

  每个 Dockerfile 只能有一条 CMD 命令，如果指定了多条命令，只有最后一条会被执行，如果启动容器时指定了运行的命令（作为 run 命令的参数），则会覆盖掉 CMD  指定的命令

* ADD

  `ADD <src><dest>`

  添加内容到镜像

  将赋值指定的 `<src>` 路径下内容到容器中的 `<desc>` 路径下，`<src>` 可以是 Dockerfile 所在目录的一个相对路径（文件或目录）；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）`<dest> ` 可以是镜像内绝对路径，或者相对于工作目录（workdir）的相对路径。路径支持正则

  ```dockerfile
  ADD *.c /code/
  ```

* COPY

  `COPY<src><dest>`

  复制内容到镜像，复制本地主机的 `<src>` （为 Dockerfile 所在目录的相对路径，文件或目录）下内容到镜像中的 `<dest>`。目标路径不存在时，会自动创建，路径同样支持正则格式 。COPY 和 ADD 指令功能类似，当使用本地目录为源目录时，推荐 COPY

编写完 Dockerfile 之后，可以通过 `docker [image] build` 命令来创建镜像。基本的格式为 `docker build [OPTIONS] PATH|URL`

该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有数据作为上下文（Context）发送给 Docker 服务端，Docker 服务端在校验 Dockerfile 个时候，逐条执行其中定义的指令，ADD、COPY、RUN 指令会生成一层新的镜像。最终如果创建镜像成功，会返回最终镜像的 ID。如果使用非上下文路径下的 Dockerfile，可以通过 `-f` 选项指定其路径。要指定生成镜像的标签信息，通过 `-t` 选项。

```shell
docker build -t builder/first_image:1.0.1 /tmp/docker_builder/
```

*docker build 命令选项*

|           选项            |              说明              |
| :-----------------------: | :----------------------------: |
|     `-add-host list`      | 添加自定义的主机名到 IP 的映射 |
|     `-build-arg list`     |        添加创建时的变量        |
|   `-cache-from strings`   |     使用指定镜像作为缓存源     |
| `-cgroups-parent strings` |       继承的上层 cgroup        |
|        `-compress`        |  使用gzip来压缩创建上下文数据  |
|     `-cpu-period int`     |     分配的 CFS 调度器时长      |
|      `cpu-quota int`      |        CFS 调度器总份额        |
|   `-c, -cpu-shares int`   |            CPU 权重            |
|   `-cpuset-cpus string`   |     多 CPU 允许使用的 CPU      |
|   `-cpuset-mems string`   |     多 CPU 允许使用的内存      |
| `-disable-content-trust`  |    不进行镜像校验，默认为真    |
|     `-f,-file string`     |        Dockerfile 名称         |
|        `-force-rm`        |     总是删除中间过程的容器     |
|     `-iidfile string`     |      将镜像 ID 写入到文件      |
|    `-isolation string`    |         容器的隔离机制         |
|       `-label list`       |        配置镜像的元数据        |
|    `-m, -memory bytes`    |         限制内存使用量         |
|   `-memory-swap bytes`    |      限制内存和缓存的总量      |
|     `-network string`     |   指定 RUN 命令时的网络模式    |
|        `-no-cache`        |      创建镜像时不适用缓存      |

##### 多阶段构建

多阶段构建使用一个 Dockerfile，其中包含多个 FROM 指令，每个 FROM 指令都是一个新的构建阶段，并且可以复制之前阶段的构件

```dockerfile
DIR /usr/src/atsea/app/react-app
COPY react-app .
RUN npm install
RUN npm run build

FROM maven:latest AS appserver
WORKDIR /usr/src/atsea
COPY pom.xml .
RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency
\:resolve
COPY . .
RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests

FROM java:8-jdk-alpine AS production
RUN adduser -Dh /home/gordon gordon
WORKDIR /static
COPY --from=storefront /usr/src/atsea/app/react-app/build/ .
WORKDIR /app
COPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .
ENTRYPOINT ["java", "-jar", "/app/AtSea-0.0.1-SNAPSHOT.jar"]
CMD ["--spring.profiles.active=postgres"]
```

`COPY --from` 指令，它从之前的阶段构建的镜像中仅复制生产环境相关的应用代码，而不会复制生产环境不需要的构件。                  

### 容器

#### 运行容器

```shell
docker [container] run <options> <image>:<tag> <app>
# 重启停止容器
docker start <container.name/id>
# 附着在容器上
docker attach <container.name/id>
# 获取容器日志
docker logs <container.name/id>
# 获取日志的最后 10 行内容
docker logs -tail 10 <container.name/id>
# 跟踪某个容器的最新日志，而不必读取整个日志文件
docker logs -tail 0 -f <container.name/id>
# 为每条日志加上时间戳
docker logs -ft <container.name/id>
# 查看容器内进程
docker top <container.name/id>
# 查看容器统计信息
docker stats <container.name/id>
# 在容器内部运行进程
docker exec -d <container.name/id> touch /etc/new_config_file
# docker stop 命令会向 docker 容器进程发送 SIGTERM 信号
docker stop <container.name/id>
# 快速停止某个容器
docker kill <container.name/id>
# 容器详细信息
docker inspect <container.name/id>
# 格式化信息
docker inspect --format='{{ .State.Running}}' <container.name/id>
# 查看端口
docker port <container.name/id>
# 删除容器
docker rm <container.name/id>
# 删除运行中容器
docker rm -f <container.name/id>
```

* `-i` : 容器中 STDIN 是开启的

* `-t` : 分配一个伪 `tty` 终端

* `-d` : 容器放到后台运行(后台容器无需分配 `it` 选项)

* `-e`  环境变量

* `-u` 设置用户

* `-w` 指定工作目录

* `--name` 指定容器名称，`[a-zA-Z0-9_.-]`，容器的命名必须是唯一的。如果试图创建两个名称相同的容器，则命令将会失败

* `-p` 端口映射，对外公开在 `Dockerfile` 中通过 `EXPOSE` 指令公开的所有端口，随机绑定到宿主机的一个随机端口上

  ```shell
  # 随机选择32768~61000映射
  -p 80
  # 指定映射
  -p 80:80
  # 指定 ip 端口
  -p 127.0.0.1:80:80
  # 绑定到特定的网络接口的随机端口
  -p 127.0.0.1::80
  ```

* `--restart`：重启策略：`always`（会在 daemon 重启时重启），`unless-stopped`（不会在 daemon 重启时重启），`on-failed`（退出容器且返回值不为 0 时重启容器，就算容器处于 stopped 状态，在 daemon 重启时，容器也会重启,`on-failure` 还接受一个可选的重启次数 `--restart=on-failure:5`）

  ```shell
  docker run --restart=always --name daemon_dave -d ubuntu /bin/bash
  ```

* 日志驱动

  通过启动 `Docker` 守护进程或者执行 `docker run` 命令时使用  `—log-driver` 选项来控制 `docker` 守护进程和容器所用的日志驱动：默认的 `json-file`、`syslog`(该选项将禁用 `docker logs` 命令，并且将所有容器的日志输出都重定向到 `Syslog`)、`none`(这个选项将会禁用所有容器中的日志，导致 docker logs 命令也被禁用)

  ```shell
  docker run —log-driver="syslog" —name daemon_dwayne -d ubuntu /bin/sh
  ```













