### 表相关信息

#### 建表相关

##### 建表语句

##### 选项

##### 修改表

##### 列相关

#### 表状态

##### 当前状态信息

在文件系统中，MySQL 将每个数据库保存为数据目录的一个子目录。创建表时，MySQL 会在数据库子目录下创建一个和表同名的 .frm 文件保存表的定义（8.0 已弃用 .frm 文件，5.7 与 5.6 最新版本也已弃用）。

MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台相关。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是 Server 层统一处理的

可以查询 INFORMATION_SCHEMA 获取表或执行以下查询查看表详情

```mysql
# syntax
SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr];
# 在当前 schema 下查看表信息
SHOW TABLE STATUS LIKE 'user';
# 通过 INFORMATION_SCHEMA 库查询表信息
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '{name}' AND TABLE_SCHEMA = '{schema}';
```

包含以下信息：

|      名称       |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
|      Name       |                             表名                             |
|     Engine      |                 表存储引擎，5.0 之前为 Type                  |
|     Version     | 已弃用，未使用 .frm 文件时固定为 10，使用 .frm 文件时为 .frm 文件版本 |
|   Row_format    |   行格式（Fixed、Dynamic、Compressed、Redundant、Compact）   |
|      Rows       | 表中行数，依据存储引擎，该值可能是确值也可能是估值，INFORMATION_SCHEMA 表为 null |
| Avg_row_length  |                     平均每行包含的字节数                     |
|   Data_length   | 表大小（以字节为单位），MyISAM 为数据文件长度，InnoDB 为聚集索引大小（页乘页大小） |
| Max_data_length | 表数据的最大容量，MyISAM 为数据文件大小，InnoDB 未使用该字段 |
|  Index_length   | 索引大小（字节），MyISAM 为索引文件长度，InnoDB 近似二级索引大小 |
|    Data_free    |                     已分配但未使用字节数                     |
| Auto_increment  |                  下一个 AUTO_INCREMENT 的值                  |
|   Create_time   |                           建表时间                           |
|   Update_time   |                    表数据文件最后更新时间                    |
|   Check_time    | 使用 CHECK TABLE 命令或 myisamchk 工具最后一次检查表的时间，并非所有引擎都更新该时间，此时为 NULL，分区 InnoDB 表， |
|    Collation    |               表的默认字符集和字符序列排序规则               |
|    Checksum     |                       当前 cheksum 值                        |
| Create_options  |                    创建表时指定的其他选项                    |
|     Comment     | 其他额外信息，默认存储的是建表时带的注释，或者是为什么无法访问表的原因 |

*   Data_free

    *   对于 MyISAM，表示已分配未使用的空间，该空间包括了之前删除的行，以及后续可以被 INSERT 利用的空间；

    *   InnoDB 为所属表空间的可用空间。对于位于共享表空间中的表：为共享表空间的可用空间；如果为单表空间：为完全可用范围中的字节数减去安全容量。即使可用空间显示为 0，只要不需要分配新的盘区，也可以插入行

    *   对于 NDB 集群，显示为磁盘上为表分配但未使用的空间（内存中数据资源使用情况由 Data_length 列报告）

    *   对于分区表，此值为估计值，在这种情况下，获取此信息的更准确方法是查询 INFORMATION_SCHEMA.PARTITIONS 表

        ```mysql
        SELECT SUM(DATA_FREE) FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA = '{mydb}' AND TABLT_NAME = '{mytable}'
        ```

*   Update_time

    对于某些存储引擎，此值为 NULL。InnoDB 在系统表空间中存储多个表，数据文件时间戳则不适用；InnoDB 使用单独的 .idb 文件时，更改缓冲也会延迟对数据文件的写入（文件修改时间与上次插入、更新、删除时间不同）对于 MyISAM 使用数据文件时间戳（在 Windows 上，时间戳不会通过更新进行更新，该值不准确）

    Update_time 显示对未分区的 InnoDB 表执行的最后一次 UPDATE、INSERT、DELETE 时间戳。对于 MVCC 时间戳反映了 COMMIT 时间，该时间被视为最后更新时间。重启服务器或从 InnoDB 数据字典高速缓存中清除表时，时间戳不会保留

##### 表维护

#### 分区表

##### 手动分表

手动分表与分区表的区别在于手动分表由应用层进行分表，而分区表由 MySql 进行分表，对业务完全透明，业务代码更加简洁。

分区表和手动分表，一个是由 `server` 层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。

必要的分区的判断，就是根据 SQL 语句中的 where 条件，结合分区规则来实现的。如果查询语句的 where 条件中没有分区 key，那就只能访问所有分区了，即使使用业务分表的方式，where 条件中没有使用分表的 key，也必须访问所有的分表

##### MySQL 分区

###### Server 层分区（已弃用）

MyISAM 分区表使用的分区策略是通用分区策略（generic partitioning），每次访问分区都有 server 层控制。通过分区策略，是 MySQL 一开始支持分区表的时候就存在的代码，在文件管理，表管理的实现上很粗糙，因此有比较严重的性能问题

从 MySQL 5.7.9 开始，InnoDB 引擎引入了本地分区策略（native partitioning）。这个策略是在 `InnoDB` 内部自己管理打开分区的行为。

MySQL 5.7.17 开始，将 MyISAM 分区表标记为即将弃用。8.0 开始，不允许创建 `MyISAM` 分区表，只允许创建已经实现了本地分区策略的引擎（InnoDB 和 NDB ）

###### 分区支持

分区可以根据设置的规则在文件系统中分布各个表的各个部分。表的不同部分作为单独的表存储在不同的位置。用户选择的用来完成数据划分的规则为分区功能

支持的分区类型为水平分区，表的不同行可以分配给不同的物理分区。不支持垂直分区（表的不同列被分配给不同的物理分区）。

8.0 要创建分区表，必须使用支持它们的存储引擎。分区支持不是由 Server 层提供。由存储引擎或本机对分区处理程序提供。所有分区必须使用相同的存储引擎。8.0 支持分区的存储引擎是 InnoDB 和 NDB。分区不能与不支持分区的存储引擎一起使用。分区适用于表的所有数据和索引，不能仅对索引或数据进行分区，也不能仅对表的一部分进行分区。可以使用用于创建分区的语句子句 `DATA DIRECTORY` 和 `INDEX DIRECTORY` 选项，将每个分区的数据和索引分配给特定目录。

表的 `DATA DIRECTORY` 单个分区和子分区仅 InnoDB 支持。8.0.21 开始，InnoDB 必须在 `DATA DIRECTORY` 子句中指定目录

从 8.0.16 开始，对分区表进行插入、删除、更新时，二进制日志记录（仅使用基于行的日志记录时记录分区信息）有关分区及发生行事件的子分区（如果存在）的信息。即使涉及的表相同，也会为不同分区或子分区中进行的修改创建新的行事件，即如果事务涉及三个分区或子分区，则会生成三个行事件。

EXPLAIN 语句的 partitions 会显示使用了那些分区

###### 分区特点

*   每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。一个典型的报错情况是：如果一个分区表的分区很多，超过了 1000 个，而 MySQL 启动的时候，`open_files_limit` 参数使用的是默认值 1024，那么就会访问这个表的时候，由于需要打开所有文件，导致打开表文件的个数超过了上限而报错。

*   分区使在一个表中存储的数据比单个磁盘或文件系统分区中存储的数据更多，通过删除仅包含该数据的一个或多个分区，可以快速删除过期数据，也可以快速添加专门存储新数据的新分区

*   MySQL 支持显式分区选择查询，支持（SELECT、DELETE、INSERT、REPLACE、UPDATE、LOAD DATA、LOAD XML）与 JOIN 语句。NDB 提供自动分区选择，不支持显式分区选择

    ```mysql
    # 仅选择那些在分区行 p0 或 p1 其匹配的 WHERE 条件
    SELECT * FROM t PARTiTION (p0, p1) WHERE c > 5
    SELECT e.id AS 'Employee ID', CONCAT(e.fname, ' ', e.lname) AS Name,
           s.city AS City, d.name AS department
           FROM employees AS e
           JOIN stores PARTITION (p1) AS s ON e.store_id=s.id
           JOIN departments PARTITION (p0) AS d ON e.department_id=d.id
           ORDER BY e.lname
    DELETE FROM employees PARTITION (p0, p1)
    UPDATE employees PARTITION (p0) SET store_id = 2 WHERE fname = 'Jill'
    # REPLACE 和 INSERT 指定的分区如果不匹配会报错
    INSERT INTO employees PARTITION (p2) VALUES (20, 'Jan', 'Jones', 1, 3)
    REPLACE INTO employees PARTITION (p0) VALUES (20, 'Jan', 'Jones', 3, 2)
    ```

*   当 WHERE 条件减少到（*`partition_column`* = *`constant`*；*`partition_column`* IN (*`constant1`*, *`constant2`*, ..., *`constantN`*)）两种情况时，优化器会自动执行分区修剪（不扫描没有匹配值的分区）

    *   *`partition_column`* IN (*`constant1`*, *`constant2`*, ..., *`constantN`*)

        优化器为列表中的每个值评估分区表达式，创建匹配分区的列表，然后仅扫描此分区列表中的分区

    *   *`partition_column`* = *`constant`*

        优化器仅对给定值的分区表达式求值，确定那个分区包含该值，然后仅扫描该分区，`=` 可替换为 `<、>、<=、>=、<>`、某些 WHERE 子句的 BETWEEN 也可以进行分区修剪 

*   进行分区并不会禁止将 NULL 作为分区表达式的值，无论它是列值还是用户提供的表达式的值（即使允许 NULL也必须以其他方式产生整数表达式的值）。MySQL 的分区实现将 NULL 视为小于任何非 NULL 的值

    *   在 RANGE 分区下，NULL 值被放入最左边分区，如果删除这个分区，将删除包含 NULL 值的记录

    *   LIST 分区下要使用 NULL，必须显式定义那个分区存放 NULL 值

        ```mysql
        # 可以单独指导 NULL 或在 LIST 中添加 NULL 元素
        VALUES IN (NULL)
        # 或
        VALUES IN (1, 4, 8, NULL)
        ```

    *   HASH 和 KEY 对于 NULL 值的记录返回为 0

* 不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引可以是允许 NULL 值的，并且分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。
* 一个分区会生成一个 `.ibd` 文件，分区表包含一个 `.frm` 文件（8.0 废除）和分区数量的 `.idb` 文件（命名规则为：`{table}#p{partition_name}.ibd`）（分区对 Server 层透明，即对 Server 层来说是一个表，对引擎层来说是多个表）
* MySQL 第一次打开分区表时需要访问所有分区，所有分区共用一个元数据锁
* 对于 InnoDB 分区表，查询 INFORMATION_SCHEMA.PARTITION 中 TABLE_ROWS 的列统计数为估计值 
* 分区表达式中不允许，存储过程、存储函数、UDF、插件，声明的变量和用户变量
* 用户定义的分区表在创建时不会保留有效的 SQL 模式，创建分区表后更改 SQL 模式可能导致分区表行为改变，造成数据损坏或丢失（建议不要在创建分区表后更改服务器 SQL 模式）
* 不使用 NDB 引擎的表，最大分区数 8192，包含子分区；分区的 InnoDB 表不支持外键（不支持外键或其他表外键引用到分区表）；不支持 FULLTEXT 索引或搜索。具有空间数据类型（POINT、GEOMETRY）的列不能在分区表中使用；临时表无法分区；无法对日志表进行分区。

##### 分区类型

8.0 可用的分区类型

```mysql
# 分区操作，修改分区类型
ALTER TABLE members
    PARTITION BY HASH( YEAR(dob) )
    PARTITIONS 8;
```

###### RANGE

根据列值在给定范围内将行分配给分区。按范围分区的表分区方式是，每个分区都包含行，分区表达式的值在给定范围内。范围应该是连续的，但不能重叠，并且是使用 `VALUES LESS THAN` 运算符定义的。

```mysql
# MAXVALUE 表示一个始终大于最大可能的 RANGE 值，如果插入一个不存在分区的值会报错
# 可以使用函数根据列 RANGE 值对表进行分区
CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
# 修改分区（新增和删除分区不支持 IF [NOT] EXISTS）
CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999)
);
# 查询 INFORMATION_SCHEMA 下 PARTITIONS 表查看分区信息
SELECT * FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA='{name}' AND TABLE_NAME='{name}'
# 新增分区
ALTER TABLE t1 ADD PARTITION （PARTITION p3 VALUES LESS THAN (2002));
# 删除分区（DROP PARTITION 不适用于使用 NDB 的存储引擎表，可以删除一个或多个 RANGE 或 LIST 分区，但不能用于 HASH 和 KEY 分区）会删除分区对应的 ibd 文件
ALTER TABLE t1 DROP PARTITION p0, p1;
# 等价
DELETE FROM t1 WHERE (year_col >= 1991 AND year_col < 1995) OR (year_col >= 1995 AND year_col < 1999);
```

对于 RANGE 分区的查询，优化器只能对 `YEAR()`，`TO_DAYS()`，`TO_SECONDS()`，`UNIX_TIMESTAMP()` 这类函数进行优化选择。

对于按范围进行分区的表，ADD PRATITION 只能将新分区添加到分区列表的高端，无法在现有分区之间或之前添加新分区。可以使用 `REORGANIZE PARTITION`（不能更改表使用的分区类型和分区表达式或列）来拆分和合并（相邻的分区，不支持跨范围合并）分区

```mysql
# t_name 分区表名，partition_list 一个或多个要更改的分区名，以逗号分隔，partition_definitions 新分区定义
ALTER TABLE {t_name}
    REORGANIZE PARTITION {partition_list}
    INTO (partition_definitions);
# 将 p1 分区重组为 n0、n1 分区，且将 p1 分区数据按规则插入到新分区
ALTER TABLE members
    REORGANIZE PARTITION p1 INTO (
        PARTITION n0 VALUES LESS THAN (1992),
        PARTITION n1 VALUES LESS THAN (1995)
);
# 合并分区数据到新分区, so, s1 数据到 p0 分区
ALTER TABLE members REORGANIZE PARTITION s0, s1 INTO (PARTITION p0 VALUES LESS THAN (1970));	
```

###### LIST

类似 RANGE 分区，必须明确定义每个分区。区别在于，在列表分区中，每个分区都是基于一组值列表中的一个而不是一组连续范围中的列值的成员来定义和选择的。通过使用 `PARTITION BY LIST(expr)` （expr 是列值或基于列值的表达式）并返回整数值，然后通过使用 `VALUES in (value_list)` （value_list 是一个以逗号分隔的整数值）定义每个分区来来完成操作

LIST 分区不需要以任何特定的顺序声明

```mysql
# 不支持 MAXVALUE，必须显示定义所有集合值，如果插入值找不到匹配分区会报错
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
# 可以使用 IGNORE 关键字忽略不匹配分区错误，会忽略不匹配值，匹配的值会被插入
CREATE TABLE h2(c1 INT, c2 INT) PARTITION BY LIST(c1) (PARTITION p0 VALUES IN (1, 4, 7), PARTITION p1 VALUES IN (2, 5, 8));
INSERT IGNORE INTO h2 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9); # 插入 3 条数据
```

添加新分区时，不能添加包含现有分区的值列表中包含的任何值到新分区

###### COLUMNS

columns 分区可是 RANGE 和 LIST 的辩题。可以在分区中使用多个列。支持使用非整型列来定义值的范围或列表成员。允许的数据类型：所有的整数类型（TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT）与 RANGE 和 LIST 分区相同，其他数字类型不支持作为分区列；DATA 和 DATETIME（其他时间类型不支持）；字符串（CHAR、VARCHAR、BINARY、VARBINARY）其他字符串类型（TEXT、BLOB）不支持

*   RANGE COLUMNS

    能够基于多个列值使用范围来定义分区，不接受表达式，仅接受列名，接受一个或多个列的列表

    ```mysql
    CREATE TABLE table_name
    PARTITIONED BY RANGE COLUMNS(column_list) (
        PARTITION partition_name VALUES LESS THAN (value_list)[,
        PARTITION partition_name VALUES LESS THAN (value_list)][,
        ...]
    )
    # 一个或多个列的列表
    column_list:
        column_name[, column_name][, ...]
    # 值的列表，值与列数目类型及顺序必须相匹配
    value_list:
        value[, value][, ...]
    CREATE TABLE rcx (a INT, b INT, c CHAR(3), d INT)
    PARTITION BY RANGE COLUMNS(a, b, c) (
    		PARTITION p0 VALUES LESS THAN (5, 10, 'ggg'),
      	PARTITION p1 VALUES LESS THAN (10, 20, 'mmm'),
      	PARTITION p2 VALUES LESS THAN (15, 30, 'sss'),
      	PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE, MAXVALUE)
    )
    ```

    RANGE 分区比较列值，而 COLUMNS RANGE 比较一组值，有时可能会将分区列表的第一个元素的值等于 VALUES LESS THAN 值列表的第一个元素的值的行放置在相应的分区中，使用单个列的作为 COLUMNS RANGE 时与 RANGE  时一致（不会将值插入等于的分区）

    使用字符串列作为分区列时，使用的字符集和排序规则可能会影响给定行存储的分区，修改字符集或排序规则后，可能导致分区变化。

*   LIST COLUMNS

    8.0 提供了对 LIST COLUMNS 分区的支持，允许讲多个列作为分区键，可以讲整数类型外的数据类型的列作为分区列

    ```mysql
    CREATE TABLE customers_1 (
        first_name VARCHAR(25),
        last_name VARCHAR(25),
        street_1 VARCHAR(30),
        street_2 VARCHAR(30),
        city VARCHAR(15),
        renewal DATE
    )
    PARTITION BY LIST COLUMNS(city) (
        PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Högsby', 'Mönsterås'),
        PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Västervik'),
        PARTITION pRegion_3 VALUES IN('Nässjö', 'Eksjö', 'Vetlanda'),
        PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Växjo')
    );
    ```

###### HASH

HASH 分区目的是将数据均匀地分布到预先定义的各个分区中，保证分区的数据量大致相等。创建 HASH 分区，必须在 CREATE 语句后附加一个子句（返回整数的表达式）`PARTITION BY HASH(expr)` 需要添加一个 `PARTITIONS {num}` 子句确定分区数量，不添加则分区数量默认为 1.

```mysql
# 创建 hash 分区，分区按日期列 b，分区数为 4
CREATE TABLE th(a INT, b DATETIME) PARTITION BY HASH (YEAR(b)) PARTITIONS 4;
```

即使使用自增主键做 hash 分区也不能保证分区数据的均匀，插入的自增 ID 并非总是连续的

*   LINEAR HASH

    线性哈希分区，使用线性二乘幂算法来确定新行插入到已经分区的表中的位置。语法与 hash 类型，除了将 hash 改成 linear hash，优势在于，分区的添加、删除、合并、拆分更快，适合处理含有大量数据的表，缺点，分布不如 hash 分区均衡

    ```mysql
    CREATE TABLE employees (
        id INT NOT NULL,
        fname VARCHAR(30),
        lname VARCHAR(30),
        hired DATE NOT NULL DEFAULT '1970-01-01',
        separated DATE NOT NULL DEFAULT '9999-12-31',
        job_code INT,
        store_id INT
    )
    PARTITION BY LINEAR HASH( YEAR(hired) )
    PARTITIONS 4;
    ```

###### KEY

类似 HASH 分区，区别在于 HASH 分区使用用户自定义表达式，键分区的哈希函数由 MySQL 服务器提供。NDB 使用 md5，其他引擎使用其内部哈希功能，语法与 HASH 语法类似

KEY 只接受零个或多个列名的列表。如果表有一个主键，则用作分区键的任何列都必须包含表的主键的一部分或全部。如果没有讲列名指定为分区键，则使用表的主键（如果存在），如果没有主键，但存在唯一键，将使用唯一键作为分区键（唯一键列必须定义为 NOT NULL，否则会失败）。

对于键分区表，无法执行 `ALTER TABLE DROP PRIMARY KEY`，会产生错误（ERROR 1466）。

```mysql
CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;
# 支持线性 KEY 分区
CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;
```

###### 子分区

是在分区的基础上再进行分区，允许在 RANGE 和 LIST 分区上再进行 HASH 和 KEY 的子分区

```mysql
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );
# 等价
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );
```

*   每个分区必须具有相同数量的子分区，子分区的名称在整个表中必须唯一
*   如果在分区表的任何分区上使用 SBUPARTITION 显式定义子分区，则必须显式定义所有分区
*   每个 SUBPARTITION 子句必须包含子分区的名称
*   子分区必须使用 HASH 或 KEY 分区，只有 RANGE 和 LIST 分区可以再分区。HASH 和 KEY 分区不能再分区

#### 分区管理

###### 分区维护

分区表的维护可以实现 CHECK TABLE、OPTIMIZE TABLE、ANALYZE TABLE、REPAIR TABLE 效果，可以使用 ALL 指代所有分区

*   重建分区：删除存储在分区中的所有记录，然后重新插入它们，适用于碎片整理

    ```mysql
    ALTER TABLE {t_name} REBUILD PARTITION {partition_list}
    ```

*   优化分区：如果分区删除了大量的行或进行了很多修改，可以回收任何未使用的空间和整理分区文件

    ```mysql
    # 等价于在给定分区执行 CHECK、ANALYZE、REPAIR
    ALTER TABLE {t_name} OPTIMIZE PARTITION {partition_list}
    ```

    模型引擎（包括 InnoDB）不支持按分区优化，此时会分析并重建整个表，并发出警告

*   分析分区：读取并存储分区的 key 分布

    ```mysql
    ALTER TABLE {t_name} ANALYZE PARTITION {partition_list}
    ```

*   修复分区：修复损坏的分区

    ```mysql
    # 当分区包含重复键错误时失败，使用 ALTER IGNORE TABLE 选项，此时存在重复键而无法移动的所有行将从分区删除
    ALTER TABLE {t_name} REPAIR PARTITION {partition_list}
    ```

*   检查分区：检查分区表中错误（数据或索引是否损坏）

    ```mysql
    # 当分区包含重复的键错误时失败，使用 ALTER IGNORE TABLE 选项，此时，返回发现重复键冲突的分区中每一行内容
    ALTER TABLE {t_name} CHECK PARTITION {partition_list}
    ```

*   截断分区：删除分区所有数据，但不删除分区

    ```mysql
    ALTER TABLE {t_name} TRUNCATE PARTITION {partition_list}
    ```

###### 新增删除分区

*   移除全部分区

    ```mysql
    ALTER TABLE {table} REMOVE PARTITIONING;
    ```

*   RANGE 和 LIST 分区操作

    对于按范围进行分区的表，ADD PRATITION 只能将新分区添加到分区列表的高端，无法在现有分区之间或之前添加新分区。

    可以使用 `REORGANIZE PARTITION`（不能更改表使用的分区类型和分区表达式或列）来拆分和合并（相邻的分区，不支持跨范围合并）分区，会导致分区被重建

    ```mysql
    # t_name 分区表名，partition_list 一个或多个要更改的分区名，以逗号分隔，partition_definitions 新分区定义
    ALTER TABLE {t_name}
        REORGANIZE PARTITION {partition_list}
        INTO (partition_definitions);
    # 将 p1 分区重组为 n0、n1 分区，且将 p1 分区数据按规则插入到新分区
    ALTER TABLE members
        REORGANIZE PARTITION p1 INTO (
            PARTITION n0 VALUES LESS THAN (1992),
            PARTITION n1 VALUES LESS THAN (1995)
    );
    # 合并分区数据到新分区, so, s1 数据到 p0 分区
    ALTER TABLE members REORGANIZE PARTITION s0, s1 INTO (PARTITION p0 VALUES LESS THAN (1970));
    # 拆分及合并 LIST 分区
    ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
    ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
        PARTITION p1 VALUES IN (6, 18),
        PARTITION np VALUES in (4, 8, 12)
    );
    ```

*   HASH 和 KEY 分区操作（包含 LINEAR HASH、LINEAR KEY）

    ```mysql
    # 缩小分区，删除比表中更大的分区将导致错误
    ALTER TABLE {t_name} COALESCE PARTITION {num};
    # 增加分区
    ALTER TABLE {t_name} ADD PARTITION PARTITIONS {num};
    ```

###### 分区交换数据

将分区或子分区中的数据与另一个非分区的表中的数据进行交换。如果非分区表中的数据为空，那么相当于将分区中的数据移动到非分区中，若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。

```mysql
# pt 分区表名，p 分区或子分区名，nt 要交换数据的普通未分区表
ALTER TABLE {pt} EXCHANGE PARTITION {p} WITH TABLE {nt}
# 如果交换的普通表的数据与分区不匹配会报错，使用 WITHOUT VALIDATION 取消验证
ALTER TABLE {pt} EXCHANGE PARTITION {p} WITH TABLE {nt} WITHOUT VALIDATION；
```

分区数据语法前置条件：

*   nt 不是临时表和分区表
*   pt 和 nt 结构相同（以严格方式比较：数目、顺序、名称、列、索引、类型、引擎必须完全匹配，可以使用 like 创建）
*   nt 不能有外键，或其他表含有对该表的外键引用
*   对于 InnoDB 表，两个表使用相同的行格式。
*   nt 没有使用该 DATA DIRECTORY 选项的任何分区，8.0.14 开始取消该限制，需要 ALTER、INSERT、CREATE、DROP 权限

执行过程中：不会触发 pt 和 nt 的触发器、AUTO_INCREMENT 列都将被重置、与 IGNORE 关键字使用时，关键字无效、一次只能一个分区或子分区进行交换，需要交换多个分区需要执行多次该语句。

与分区交换（分区数据交换到表）的表不一定必须为空，此时会互相交换分区表与普通表的数据。如果表的分区是子分区，只能与未分区的表交换表的子分区，而不是整个分区

