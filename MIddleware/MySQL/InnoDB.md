### InnoDB 引擎特性

#### 表结构

##### 表空间

InnoDB 的数据存储在表空间中，表空间是由 InnoDB 管理的一个黑盒子，由一系列的数据文件组成。

#### 语句

##### 更新语句执行

###### 执行流程

执行器和引擎执行更新语句时操作流程：

1.  执行器根据更新条件获取数据页
2.  InnoDB 判断数据页是否在缓存池中，如果在内存中，直接返回给执行器，否则从磁盘读取数据页到缓冲池，如果缓冲池已满触发淘汰策略，刷新脏页。在页面执行二分查找获取匹配行数据返回给执行器
3.  执行器执行更新操作
4.  InnoDB 更新缓冲池内存页，写入 redo log（循环写，如果不够需要擦写），并在分布式事务中处于 prepare 阶段
5.  执行器写入 binlog，执行器在分布式事务中 prepare
6.  InnoDB 提交事务，处于 commit 阶段

###### 两阶段提交

而 InnoDB 内部的这个 `commit` 步骤，是指事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了

将 `redo log` 的写入拆成两个步骤：`prepare` 和 `commit` ，这就是两阶段提交

由于 `redo log` 和 `binlog` 是两个独立的逻辑，如果不用两阶段提交而使用如下方式提交：

假定当前 ID = 2 的行，字段 c 的值是 0，再假设执行 `update` 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 `crash`，会出现如下情况：

1. 先写 `redo log` 后写 `binlog`。假设在 `redo log` 写完，`binlog` 还没有写完的时候，MySQL 进程异常重启。`redo log` 写完之后，系统即使崩溃，仍能把数据恢复回来，所以恢复后这一行的 c 的值是 1。由于 `binlog` 还没写完就 `crash` 了，这时候 `binlog` 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 `binlog` 里面就没有这条语句。如果需要用这个 `binlog` 来恢复临时库的话，由于这个语句的 `binlog` 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库不同。
2. 先写 `binlog` 后写 `redo log`。如果在 `binlog` 写完之后 `crash`，由于 `redo log` 还没写，崩溃恢复以后这个事务无效，所以这一行的值是 0。但是 `binlog` 里面已经记录了 `把 c 从 0 改成 1` 这个日志。所以，在之后用 `binlog` 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

如果不使用`两阶段提交`，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。同类场景除恢复临时库之外，当需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 `binlog` 来实现的，这个不一致就会导致线上出现主从数据库不一致的情况。即 `redo log` 和 `binlog` 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致

* `redo log` 用于保证 `crash-safe` 能力。`innodb_flush_log_at_trx_commit` 这个参数设置成 1 的时候，表示每次事务的 `redo log` 都直接持久化到磁盘。这样可以保证 MySQL 异常重启之后数据不丢失；
* `sync_binlog` 这个参数设置成 1 的时候，表示每次事务的 `binlog` 都持久化到磁盘。这个参数设置成 1 的时候，可以保证 MySQL 异常重启之后的 `binlog` 不丢失。

### `InnoDB Flush`相关

#### `SQL` 语句为什么会间歇性变慢

一条 `SQL` 语句，正常执行的时候特别快，但是有时会变得特别慢，而且场景难复现，随机且持续时间短

`InnoDB` 在处理更新语句的时候，只做了写日志这一次磁盘操作。这个日志即 `redo log` ，在更新内存写完 `redo log` 后，就返回给客户度，本次更新成功

**当内存数据页跟磁盘数据页内容不一致的时候，这个内存也即为“脏页“。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”，不论不论脏页还是干净页，都在内存中。**

平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔抖一下的那个瞬间，可能是在刷脏页（`flush`）

* 当 `redo log` 写满了，要 `flush` 脏页，这种情况是 `InnoDB` 要尽量避免的，因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。这时候更新数会下跌为 0.

* 当内存不足时，要先将脏页写到磁盘。这种情况是比较常见的，**InnoDB 用缓冲池 `buffer pool` 管理内存，缓冲池中的内存页有三种状态：**

    第一种是，还没有使用的

    第二种是，使用了并且是干净页

    第三种是，使用了并且是脏页

    `InnoDB` 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页，就必须将脏页先刷到磁盘，变成干净页后才能复用。

    刷脏页虽然是常态，但出现以下这两种情况，会明显影响性能

    1.一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；

    2.日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的

#### InnoDB 刷脏页的控制策略

首先，要告知 `InnoDB` 所在主机的 IO 能力，这样 `InnoDB` 才能知道需要全力刷脏页的时候，可以刷多快，使用 `innodb_io_capacity` 这个参数，可以配置 `InnoDB` 的磁盘能力。建议设置成磁盘的 `IOPS`

使用 `fio` 工具测试磁盘随机读写的命令

```shell
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest
```

`InnoDb` 的刷盘速度的参考因素是：脏页比例与 `redo log` 写盘速度。`InnoDB` 会根据这两个因素先单独算出两个数字

参数 `innodb_max_dirty_pages_pct` 是脏页比例上限，默认值是 75%。`InnoDB` 会根据当前的脏页比例（假定为 M），算出一个范围在 0 到 100 之间的数字。`InnoDB` 每次写入的日志都有一个序号，当前写入的序号跟 `checkpoint` 对应的序号之间的差值，假设为 N。`InnoDB` 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。N 越大，算出来的值越大。**根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度**

脏页比例是通过 `Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total` 得到的，要多关注脏页比例，不要让它经常接近 75 %。

```mysql
select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';
select @a/@b;
```

一旦一个查询请求需要在执行过程中先 `flush` 掉一个脏页时，这个查询就可能要比平时慢了。而 `MySQL` 中的一个机制，可能会让查询更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个旁边的脏页一起刷掉，而且会一致继续，即相邻的脏页的旁边的脏页也会被刷掉

在 `InnoDB` 中，`innodb_flush_neighbors` 参数就是用来控制这个行为的，值为 1 的时候会有上述刷新相邻的脏页机制，为 0 时即关闭该机制，只刷当前脏页

如果使用的是 SSD 这类 IOPS 比较高的设备的话，将 `innodb_flush_neighbors` 的值设置成 0。因为此时 IOPS 往往不是瓶颈，而只刷自己，就能更快执行完必要的刷脏页操作，减少 SQL 语句响应时间，8.0 种，默认值为 0；

