### Schema 与数据类型优化

#### Schema 设计

##### 良好实践

1. 准确的数据类型
2. 简单数据类型优先复杂类型，原生类型优先

* 尽量避免 null

  InnoDB 使用单独的位存储 null 值，所以对于稀疏数据（很多值为 null，只有少数列有非 null 值）有很好的空间效率。但这一点不适用 MyISAM

* 尽量避免过度设计，结合使用范式及反范式

* 尽量使用相同的数类型存储相似或相关的值，尤其是要在关联中使用的列（对列的隐式转换（函数操作）会使该列用不上索引）

* 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存

* 尽量使用整形定义标识列

* 避免使用已遗弃的特性，如指定浮点数精度，或者整数的显示宽度

* 小心使用 ENUM 和 SET

* 最好避免使用 BIT

##### 基本数据类型

MySQL 为了兼容性支持很多别名（Integer、Bool、NUMERIC），不会影响性能，如果建表时采用数据类型的别名，查看建表语句时会显示基本类型

###### 整数类型

* TINYINT

    使用 8 位存储空间

* SMALLINT

    16 位存储空间

* MEDIUMINT

    24 位存储空间

* INT

    32 位存储空间

* BIGINT

    64 位存储空间

存储的值的范围从 −2^(N − 1) 到 2^(N − 1) − 1，N 是存储空间位数。可选的 **UNSIGNED** 属性，表示不允许负值，有符号和无符号类型使用相同的存储空间，并具有相同的性能，整数计算一般使用 64 位的 **BIGINT** 整数，即使在 32 位环境也是如此，一些聚合函数是例外，它们使用 **DECIMAL** 或 **DOUBLE** 进行计算

可以为整数类型指定宽度，int(11)，对大多数应用没有意义，它不会限制值的合法范围，只是规定了一些交互工具（如命令行客户端）用来显示字符的个数。对于存储和计算无区别

###### 实数类型

实数是带有小数部分的数字。也可以使用 **DECLMAL** 存储比 **BIGINT** 还大的整数。

* FLOAT

    使用 4 个字节存储

* DOUBLE 

    占用 8 个字节，都支持使用标准的浮点运算进行近似计算，MySQL 使用 **DOUBLE** 作为内部浮点计算的类型

* DECLMAL

    用于存储精确的小数，在 5.0 及以后，支持精确计算。因为 CPU 不支持对 **DECLMAL** 的直接计算，在 5.0 后，MySQL 自身实现了 **DECLMAL** 的高精度计算。相对而言，CPU 直接支持原生浮点运算会更快。

    应该尽量只在对小数进行精确计算时才使用 **DECIMAL**

    在数据量比较大的时候，可以考虑使用 **BIGINT** 代替 **DECLMAL** ，将需要存储的小数位数乘以相应的倍数即，这样可以避免浮点存储计算不精确和 **DECIMAL** 精确计算代价高的问题

浮点和 DECLMAL 类型都可以指定精度。对于 **DECLMAL** 列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。5.0 和更高版本将数字打包保存到一个二进制字符串中（每 4 个字节存 9 个数字）。**DECLMAL** (18, 9) 小数点两边各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占用 1 个字节。5.0 和更高版本的 **DECLMAL** 类型允许最多 65 个数字

浮点类型在存储同样范围的值时，通常比 **DECLMAL** 使用更少的空间

###### 字符串类型

4.1 开始，每个字符串可以定义自己的字符集和排序规则

**VARCHAR** 和 **CHAR** 是两种最主要的字符串类型。存储引擎存储 **CHAR** 或 **VARCHAR** 值的方式在内存中和在磁盘上可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式，MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表或磁盘临时表进行排序或操作时会更糟糕，最好的策略时只分配真正需要的空间

* varchar

    用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，它仅使用必要的空间。如果 MySQL 表使用 ROW_FORMAT=FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间

    **VARCHAR** 需要使用 1 或 2 个额外字节记录字符串的长度（如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节）由于行是变长的，在更新时可能使行变得比原来更长（MyISAM 会将行拆成不同的片段存储；InnoDB 需要分裂页来使行可以放进页内；其他一些存储引擎也许从不在原数据位置更新数据）适用场景：

    字符串列的最大长度比平均长度大很多；

    列的更新很少，所以碎片不是问题。

    使用像 UTF-8 这样的复杂的字符集，每个字符都使用不同的字节数进行存储。5.0 或更高版本，MySQL 在存储和检索时会保留末尾空格。在更老版本，MySQL会剔除末尾空格。8.0 测试会删除末尾空格

* char

    **CHAR** 类型是定长的，根据定义的字符串长度分配足够的空间。<u>当存储 **CHAR** 值时，MySQL 会删除所有的末尾空格，**CHAR** 值会根据需要采用空格进行填充以方便比较</u>

    **CHAR** 适合存储很短的字符串，或者所有值都接近同一个长度。对于经常变更的数据，**CHAR** 也比 **VARCHAR** 更好，因为定长的 **CHAR** 类型不会产生碎片。对于非常短的列，**CHAR** 比 **VARCHAR** 在存储空间上也更有效率

    数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串。Memory 引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。<u>填充和截取空格的行为在不同存储引擎都是一样的，服务器层进行处理的</u>

* BINARY

* VARBINARY

    存储的是二进制字符串。二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符，填充也不一样：MySQL 填充 **BINARY** 采用的是 \0 （零字节）而不是空格，在检索时也不会去掉填充值

    当需要存储二进制数据，并且希望 MySQL 使用字节码而不是字符进行比较时，这些类型是非常有用的。二进制比较的优势并不仅仅是大小写敏感，MySQL 比较 **BINARY** 字符串时，每次比较一个字节，并且根据该字节的数值进行比较，二进制比较比字符比较简单的多，速度也更快

* BLOB

    存储大数据，使用二进制存储，对应族：**TINYBLOB**，**SMALLBLOB**， **BLOB**，**MEDIUMBLOB**，**LONGBLOB**。**BLOB** 是 **SMALLBLOB** 的同义词。存储的是二进制数据，没有排序规则或字符串

* TEXT

    存储很大的数据，采用字符方式存储，对应族：**TINYTEXT**，**SMALLTEXT**，**TEXT**，**MEDIUMTEXT**，**LONGTEXT**。**TEXT** 是 **SMALLTEXT** 的同义词

    MySQL 把每个 **BLOB** 和 **TEXT** 值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当值太大时，InnoDB 会使用专门的外部存储区域进行存储，此时每个值在行内需要1-4 个字节存储一个指针，然后在外部存储区域存储实际的值

    有字符集和排序规则。MySQL 对 **BLOB** 和 **TEXT** 只对每个列的最前『max_sort_length』字节而不是整个字符串做排序，如果只需要排序前面一小部分字符，则可以减少该值的配置，或者使用 
    
    ```mysql
    # 字段部分排序 ORDER BY SUBSTRING(column, length)
    select name, age from user order by substring(name, 3); 
    ```
    
    MySQL不能将 **BLOB** 和 **TEXT** 列全部长度的字符串进行索引，也不能使用这些索引消除排序

Memory 引擎不支持 **BLOB** 和 **TEXT** 类型，如果查询使用了 **BLOB** 或 **TEXT** 列并且需要使用隐式临时表，将不得不使用磁盘临时表，即使只有几行数据也是如此。这会导致严重的性能开销。即使配置 MySQL 将临时表存储在内存块设备上，依然需要许多昂贵的系统调用。最好的解决方案是尽量避免使用 **BLOB** 和 **TEXT** 类型。如果实在无法避免，可以在所有用到 **BLOB** 字段的地方都使用 *SUBSTRING(column, length)* 将列值转换为字符串在 **ORDERY BY** 子句中也适用，这样就可以使用内存临时表了。但是要确保截取的子字符串足够短，不会使临时表的大小超过 『max_heap_table_size』或『tmp_table_size』，超过以后 MySQL 会将内存临时表转换为磁盘临时表

###### 枚举

枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL 在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表 .frm 文件中保存 数字-字符串映射关系的查找表。

如果使用数字作为 ENUM 枚举常量，这种双重性很容易导致混乱，应尽量避免。枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。可以使用 *FIELD()* 函数显式地指定排序顺序，但这会导致 MySQL 无法利用索引消除排序，建议定义时按字母的顺序，就可以消除排序

枚举的缺点在于，字符串列表是固定的，添加或删除字符串必须使用 **ALTER TABLE** 因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素，这样在 5.1 及以后就可以不用重建整个表来完成修改。由于 MySQL 把每个枚举值保存为整数，并且必须进行查找才能转换为字符串，所以枚举列有一些开销。通常枚举的列表都比较小，所以开销还可以控制，在特定情况下，把 **CHAR/VARCHAR** 列与枚举列进行关联可能会比直接关联 **CHAR/VARCHAR** 列更慢

###### 时间

* DATETIME

    <u>这个类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。它把日期和时间封装到格式为 YYYYMMDDHHMMSS 的整数中，与时区无关</u>。使用 8 个字节的存储空间。

    默认情况下，MySQL 以一种可排序、无歧义的格式显示：2009-01-16 22:37:08。这是 ANSI 标准定义的日期和时间表示方法

* TIMESTAMP

    保存了从格林尼治标准时间以来的秒数，它和 UNIX 时间戳相同。**TIMESTAMP** 只使用 4 个字节的存储空间，因此它的范围比 **DATETIME** 小得多：只能表示从 1970 年到 2038 年。

    MySQL 提供了 *FROM_UNIXTIME()* 函数把 UNIX 时间戳转为日期，并提供了 *UNIX_TIMESTAMP()* 函数把日期转换为 UNIX 时间戳

    4.1 及更新的版本按照 **DATETIME** 方式格式化 **TIMESTAMP** 的值，之前版本不会在各个部分之间显示任何标点符号。仅仅时显示格式上的区别，存储格式在各个版本都一样

    **TIMESTAMP** 显示的值依赖于时区。MySQL 服务器，操作系统，客户端连接都有时区设置，如果在多个时区存储或访问数据，**TIMESTAMP** 和 **DATETIME** 的行为将很不一样。前者提供的值与时区有关系，后者则保留文本表示的日期和时间

    默认情况下，如果插入时没有指定第一个 **TIMESTAMP** 列的值，MySQL 则设置这个列的值为当前时间。在插入一行记录时，默认会更新第一个 **TIMESTAMP** 列的值（除非在更新语句中明确指定了值）。可以配置任何 **TIMESTAMP** 列的的插入和更新行为。**TIMESTAMP** 列默认为 **NOT NULL**

    推荐使用 **TIMESTAMP**，它比 **DATETIME** 空间效率更高。如果需要存储更小粒度的日期和时间，可以使用 **BIGINT** 类型存储微妙级别的时间戳，或者使用 **DOUBLE** 存储秒之后的小数部分，也可以使用 MariaDB 替代 MySQL

###### 位数据类型

所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型

* BIT

    5.0 之前，**BIT** 是 **TININT** 的同义词。

    5.0 之后是一个特性完全不同的数据类型。可以使用 **BIT** 列在一列中存储一个或多个 true/false 值。BIT(1) 定义一个包含单个位的字段，BIT(2) 存储2个位，依次类推。BIT 列的最大长度是 64个位

    BIT 数据类型被用于存储比特值，范围 1 - 64，存储的是二进制字符串。如果为小于位长的列分配值，则会在左侧用零填充该值。

    BIT 的行为因存储引擎而不同：

    * MYISAM 会打包存储所有的 BIT 列，即 17 个单独的 BIT 列只需要 17 个位存储（假设没有可为 NULL 的列），这样 MYISAM 只使用 3 个字节就能存储这 17 个 BIT 列。
    * 其他存储引擎如 Memory 和 InnoDB，为每个 **BIT** 列使用一个足够存储的最小整数类型来存放，所以不能节省空间

* SET

    如果需要保存很多 true/false 值，可以考虑合并这些列到一个 **SET** 数据类型，它在内部是以一系列打包的位的集合来表示的。这样可以有些的利用存储空间。它的主要缺点是改变列的定义的代价比较高：需要 **ALTER TABLE**，一般来说，也无法在 **SET** 列上通过索引查找

### Schema 设计中的陷阱

#### 太多的列

MySQL 的存储引擎 API 工作时需要在服务层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM 的定长行结构实际上与服务器层的行结构正好匹配，所以不需要转换。但是，MyISAM 的变长结构和 InnoDB 的行结构总是需要转换。转换的代价依赖于列的数量。

#### 太多的关联

MySQL 限制了每个关联操作最多只能有 61 张表，一个粗略的经验法则，如果希望查询执行的快速且并发性好，单个查询不超过 3 个表以内做关联

#### 过度的枚举

当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，（5.1 及以后，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE）

### 范式和反范式

对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方

#### 范式的优点和缺点

当为性能问题而寻求帮助时，经常会被建议对 `schema` 进行范式化设计，尤其是写密集的场景。下面这些原因，范式化通常能够带来好处：

* 范式化的更新操作通常比反范式化更快
* 当数据较好地范式化时，就只有很少或没有重复数据，所以只需要修改更少的数据
* 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
* 很少有多余的数据意味着检索列表数据时更少需要 `DISTINCT` 或者 `GROUP BY` 语句。

范式化设计的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的 `schema` 上都可能需要至少一次关联，这不但代价昂贵，也可能使一些索引策略无效

#### 反范式优点和缺点

反范式化的 schema 因为所有数据都在一张表中，可以很好地避免关联。

如果不需要关联表，则对大部分查询最差的情况（即使表没有索引，走全部扫描）当数据比内存大时可能比关联要快的多，因为这样避免了随机 I/O（全表扫描基本上是顺序 I/O，但也不是 100%，跟引擎的实现有关）

单独的表也能使用更有效的索引策略。

#### 更快的读，更慢的写

为了提升查询的性能，经常会需要建一些额外的索引，增加冗余列，甚至创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧；虽然写操作变得慢了，但可以显著提高读操作的性能。然而，写操作变慢并不是读操作变得更快所付出的唯一代价，还可能同时增加了读操作和写操作的开发难度

### ALTER TABLE 操作

MySQL 的 ALTER TABLE 操作的性能对大表来说是个大问题。MySQL 执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样的操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。5.1 及更新版本包含一些类型的在线操作的支持，这些功能不需要在整个操作过程中锁表。InnoDB 也支持通过排序来建索引，这使得建索引更快并且有一个紧凑的索引布局。

### 快速创建 MyISAM 索引

为了高效地载入数据到 MyISAM 表中，有一个常用的技巧是先禁用索引、载入数据，然后重新启用索引：                       

```mysql
// 禁用索引
ALTER TABLE test.load_data DISABLE KEYS;
// 插入数据
// 启用索引
ALTER TABLE test.load_data ENABLE KEYS;
```

这样构建索引的工作被延迟到数据完全载入以后，这个时候已经可以通过排序来构建索引了。这样做会快很多，并且使得索引树碎片更少，更紧凑。如果使用的是 `LOAD DATA FILE`，并且要载入的表是空的，MyISAM 也可以通过排序来构建索引，但是对唯一索引无效，因为 `DISABLE KEYS` 只对非唯一性索引有效。MyISAM 会在内存中构造唯一索引，并且为载入的每一行检查唯一性。一旦索引的大小超过了有效内存大小，载入操作就会变得越来越慢。                                                                                                                                                                               