### 概念及术语

#### 日志相关

###### redo log

InnoDB 引擎更新语句时候在内存里写的更新日志，是循环写的。使用 redo log，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

事务日志采用的是追加的方式，写日志的操作是磁盘上一小块区域内的顺序 I/O

###### Write-Ahead Loggin

预写式日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在磁盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用追加写方式，两阶段提交

修改数据需要写两次磁盘，一次在事务提交时顺序写 redo log，持久化到磁盘，一次后台刷新内存中脏页数据时根据 redo log 中的记录将内存脏页数据应用到磁盘中的数据页

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据，具体的恢复方式视存储引擎而定

#### 事务相关

###### AUTOCOMMIT

Server 默认采用自动提交模式。即：如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置『AUTOCOMMIT』变量来启用或禁用自动提交模式

修改 『AUTOCOMMIT』 对非事务型的表（MyISAM 或内存表，不会有任何影响），对这类表来说，没有 **COMMIT** 或者 **ROLLBACK** 概念。

一些语句，在执行之前回强制提交当前的活动事务（DDL 语句，会导致大量数据改变的操作如 **ALTER TABLE**，**LOCK TABLES** 等语句）

```mysql
show variables like 'autocommit';
# 1 或者 ON 表示启用，0 或者 OFF 表示禁用
set autocommit = 1;
```

* 为 0 时

  所有的查询都是在一个事务中，直到显式地执行 **COMMIT** 提交或者 **ROLLBACK** 回滚，该事务结束，同时又开始另一个新事务

* 为 1 时

  每条语句都会自动进行提交。此时需要使用 **START TRANSACTION**、**BEGIN** 的方式来显式地开启事务，该事务只会在 **COMMIT** 时才会生效，在 **ROLLBACK** 时才会回滚

###### 隔离级别

* 读未提交（read uncommited）：一个事务还没提交时，它做的变更就能被别的事务看到

*   读提交（read commited）：一个事务提交之后，它做的变更才会被其他事务看到（在每条语句执行时，生成一个一致性视图）

*   可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（在事务启动时，生成一个一致性视图，整个事务期间都使用该视图）

*   串行化（serializable）：对于同一行记录，"写" 会加 "写锁"，"读" 会加 "读锁"。读写锁互斥，后访问的事务必须等前一个事务执行完成，才能继续执行

可以通过执行 `SET TRANSACTION ISOLATION LEVEL` 命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别:

```mysql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

* **binlog：归档日志** 

   `MySQL Server` 层记录的逻辑日志，与具体引擎无关，是记录在某个数据页上做了什么修改的物理日志，是追加写入的。

* **两阶段提交**

   `redo log` 与 `binlog` 的两阶段提交：写入 `redo log` 处于 `prepare` 阶段，再写入 `binlog`，同时提交事务

* **undo log：回滚日志**

  语句更新时生成的，记录包含有关如何撤消事务到聚簇索引记录的最新更改的信息

* **事务**：

  ACID（`Atomicity`，`Consistency`，`Isolation`，`Durability`）原子，一致，隔离，持久。

* 主键索引

  也称为聚簇索引（`clustered index`），主键索引的叶子节点存的是整行数据

* **非主键索引**

  也称为二级索引（`secondary index`），二级索引的叶子节点内容是主键的值

* **回表:**

  普通索引查询时，需要先搜索普通的索引树，得到主键值，再到主键索引树上搜索一次，主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。回表是一行行搜索主键索引的。

* **页分裂**

  B+ 树为了维护索引有序性，在插入新值的时候做必要的维护。如果应插入值的位置满了，需要申请一个新的数据页，移动部分数据过去。

* **页合并**

  相邻的页由于删除了数据，利用率很低的时候，会将数据页做合并，合并的过程为分裂的逆过程，不过合并后并不会收缩该空间，只是把该页标记为可复用。

* **覆盖索引**

  在查询里面，索引已经覆盖了查询请求（如，查询主键，但条件字段已加了索引）

* **最左前缀原则**

  索引项是按照索引定义里面出现的字段顺序排序的，可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符

* **索引下推**

  5.6 开始，在引擎遍历索引过程中，存储引擎对索引中包含的字段先做条件判断，直接过滤掉不满足条件的记录

* **全局锁**

  即对整个数据库加锁。当加全局锁之后数据处于只读状态，数据更新语句、数据定义语句和更新事务的提交语句会全部阻塞

  ```mysql
  # 加全局锁
  flush tables with read locl
  ```

* **DML语句** 

  数据操作语句（增删改）

* **DDL**

  表结构操作语句（创建及修改表）

* **表级锁** 

* `lock tables t read`，可以用 ` unlock tables` 主动释放锁。除了会限制别的线程的读写外，也限定了本线程接下来的操作对象

* **MDL元数据锁** 

  `meta data lock，MDL`，不需要显示使用，在访问一个表的时候会被自动加上。`MDL` 的作用是，保证读写的正确性。5.5 版本引入，当对一个表做增删改查操作的时候，加 `MDL` 读锁；当要对表做结构变更操作的时候，加 `MDL` 写锁。读锁之间不互斥，写锁，读写锁之间是互斥。

* **行锁**

  针对数据表中行记录的锁，由引擎层实现，目前 `InnoDB` 支持行锁，MyISAM 不支持

* **两阶段锁协议**

  在 `InnoDB` 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。

###### 死锁

不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，会导致这些线程进入无限等待的状态

两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁，多个事务同时锁定同一个资源时，也会产生死锁

处理死锁的方式一般有：

* 检测死锁的循环依赖，并立即返回一个错误
* 当查询的时间达到锁等待超时的设定后放弃锁请求

InnoDB 处理死锁的方式时，将持有最少行级拍他锁的事务进行回滚

* **主动死锁检测**

  发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 `on`，表示开启这个逻辑

* **一致性视图** 

  InnoDB 实现 `MVCC` 时用到的视图，即 `consistent read view`，用于支持 `RC` 和 `RR` 隔离级别的实现

* **transaction id**

  事务开始的时候向 `InnoDB` 的事务系统申请的，是按照申请顺序严格递增的

* **row trx_id**  

  每个事务更新数据的时候，都会生成一个新的数据版本，并且把 `transaction id` 赋值给这个数据版本的事务 ID，记为 `row trx_id`。

* **当前读**

   `current read` ，更新数据都是先读后写的，而这个读，只能读当前的值，即为当前读

* **change buffer**

  当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中，在不影响数据一致性的前提下，`InnoDB` 会将这些更新操作缓存在 `change buffer` 中，这样就不需要从磁盘中读入这个数据页了。

* **merge**

  从磁盘读入数据页到内存（老版本的数据页），从 `change buffer` 里找出这个数据页的 `change buffer` 记录（可能有多个），依次应用，得到新版本数据页，写 `redo log` 这个 `redo log` 包含数据的变更和 `change buffer` 的变更

* **脏页**

  内存数据页跟磁盘数据页内容不一致的时候，内存页为脏页。刷脏页即将内存数据页数据同步到磁盘数据页

* **幻读**（Phantom Read）

  **幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行**。当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读区该范围的记录时，会产生幻行。

  在可重复读隔离级别下，普通的查询时快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。幻读仅专指“新插入的行”。
  
  产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，`InnoDB` 只好加入新的锁，即间隙锁。数据行是可以加锁的实体，数据行之间的间隙，也是可以加锁的实体。跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。间隙锁和行锁合称 `next-key lock`，每个 `next-key lock` 是前开后闭区间。
  
  间隙锁的引入，可能会导致同样的语句锁住更大的范围，其实是影响了并发度。间隙锁是在可重复读隔离级别下才会生效的。如果把隔离级别设置为读提交，则没有间隙锁。但同时，要解决可能出现的数据和日志不一致问题，需要把 `binlog` 格式设置为 `row`。
  
  当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事物再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB 和 XtraDB 存储引擎通过多版本并发控制（MVCC）解决了幻读问题

#### InnoDB 相关

##### 锁相关

InnoDB 采用两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行 commit/rollback 时释放，所有的锁会在同一时刻被释放。InnoDB 会在需要时自动加锁。InnoDB 支持通过（`SELECT... LOCK IN SHARE MODE/SELECT ... FOR UPDATE`）显式加锁。Server 层支持 `LOCK TABLES/UNLOCK TABLES` 语句加锁。

###### MVCC

大多数事务型引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。但各自的实现机制不同，MVCC 没有一个统一的实现标准

MVCC 可以认为是行级别锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行

MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。即：不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列（一个保存了行的创建时间，一个保存了行的删除时间，存储的不是实际的时间值，而是系统版本号）来实现的。每开始一个新的事务。系统版本号都会自动递增。事务开始时刻的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

在『REPEATABLE READ』隔离级别下，MVCC 具体行为是：

* **SELECT**

  InnoDB 会根据以下两个条件检查每行记录：

  a. InnoDB 只查找版本早于当前事务版本的数据行（行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么在事务开始前已经存在的，要么是事务自身插入或修改过的

  b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取的行，在事务开始之间未被删除

  只有符合上述两个条件的记录，才能返回作为查询结果

* **INSERT**

  InnoDB 为新插入的每一行保存当前系统版本号作为行版本号

* **DELETE**

  InnoDB 为删除的每一行保存当前系统版本号作为行删除标识

* **UPDATE**

  InnoDB 插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识

保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。

MVCC 只在『REPEATABLE READ』 和 『READ COMMITED』 两个隔离级别下工作。其他两个隔离级别都不兼容，『READ UNCOMMITTED』总是读取最新的数据行，『SERIALIZABLE』则会对所有读取的行都加锁。

