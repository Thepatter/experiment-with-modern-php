### 基础架构及模块

MySQL 是典型的 C/S 程序架构

#### Client

##### 连接选项

###### 快速连接

包含各语言支持的 Connectors 及 mysql 客户端等

mysql 命令客户端每次和服务端建立连接后，使用默认连接参数会建立一个本地 Hash 表提供库名和表名的补全功能连接时使用选项 `-A`/`--quick`/`-q` 可以跳过这个阶段

mysql 客户端发送请求后，接收服务端返回结果的方式：

*   本地缓存，对于 API 的 `mysql_store_result`
*   不缓存，对应 API 的 `mysql_use_result`

客户端连接使用 `--quick`/`-q` 参数时，会使用不缓存处理结果和不把执行命令记录到本地命令历史文件

#### Server

包含 MySQL 大多数核心功能，及所有内置函数。所有跨存储引擎的功能（存储过程、触发器、视图、用户函数）都在这一层实现

##### 连接器

管理连接，权限验证，负责跟客户端建立连接，获取权限，维持和管理连接

*   身份认证

    如果用户名密码错误，会报错 `Access denied for user` ，然后客户端程序结束执行。如果认证通过，连接器会到权限表里查出拥有的权限。此后连接里的权限判断逻辑，都将依赖于此时读到到权限。（一个用户成功建立连接后，即使对该用户权限做了修改，也不会影响到已存在的连接的权限。修改完成后，再新建的连接才会使用新的权限设置）

*   自动断开连接

    连接器自动断开 `show processlist` 中 Command 列显示为 `Sleep` 的空间连接，时间由 `wait_timeout` 控制，默认 8 小时

*   长连接

    全部使用长连接会使 `MySQL` 占用内存涨的特别快，因为（`Mysql` 在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放。如果长连接累积起来，可能导致内存占用太大，被系统强行杀掉（`OOM`），导致 `Mysql` 异常重启。（定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后。如果使用`MySQL5.7`及以后版本，可以在每次执行一个比较大的操作后，执行 `mysql_reset_connection` 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态）

##### 查询缓存

命中则直接返回结果，更新表数据则整个表的缓存都失效，8.0废除

`MySQL` 提供了按需缓存，将参数 `query_cache_type` 设置成 `DEMAND` ，这样对默认的 `SQL` 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 `SQL_CACHE` 显式指定

```sql
select SQL_CACHE * from T where ID = 10
```

##### SQL 接口

SQL 接口提供一套机制来接收命令以及传输结果给用户。MySQL的SQL接口遵从 ANSI SQL 标准，它和绝大多数遵从ANSI 标准的数据库服务器一样接受同样基础的 SQL 语句

##### 分析器

*   词法分析

*   语法分析，根据词法分析的结果，语法分析器会根据语法规则判断输入的 `SQL` 语句是否满足 `Mysql` 语法，如果语法不对会提示 `You have an error in your SQL syntax` ，语法错误会提示第一个出现错误的位置，即紧接 `use near` 的内容

##### 优化器

查询优化器的目标是找到执行 SQL 查询的最佳执行计划（查询树）它由一系列物理操作符组成，这些操作符按照一定的运算关系组成查询的执行计划。可以分为逻辑查询优化阶段和物理查询优化阶段

* 逻辑查询优化：通过改变 SQL 语句的内容来使得 SQL 查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对 SQL 语句进行等价交换，对查询进行重写（查询重写的数据基础是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。）
* 物理查询优化：关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率

###### 优化策略

查询优化器的生成最佳执行计划的策略通常有两种方式：

* 基于规则的优化器（RBO，Rule-Based Optimizer）。

    规则是人们以为的经历，或者是采用已被证明是有效的方式。通过在优化器里面嵌入规则。来判断 SQL 查询符合那种规则，就按照相应的规则来制定执行计划，同时采用启发式规则去掉明显不好的存储路径

* 基于代价的优化器（CBO，Cost-Based Optimizer）。

    这会根据代价评估模型，计算每条可能的执行计划的代价，COST，从中选择代价最小的作为执行计划。相比于 RBO，CBO 对数据更敏感，因为它会利用数据表中的统计信息来做判断，针对不同的数据表，查询得到的执行计划可能是不同的，因此制定出来的执行计划也更符号数据表的实际情况

大部分 RDBMS 都支持基于代价的优化器，在 MySQL 中的 COST Model（优化器用来统计各种步骤的代价模型）在 5.7.10 版本之后，mysql 库引入两张数据表，里面规定了各种步骤预估的代价

*   server_cost

    |            统计项            |                           备注                           |
    | :--------------------------: | :------------------------------------------------------: |
    | `disk_temptable_create_cost` |        MyISAM/InnoDB 创建磁盘临时表代价，默认 20         |
    |  `disk_temptable_row_cost`   |       MyISAM/InnoDB 创建磁盘临时表行代价，默认 0.5       |
    |      `key_compare_cost`      |     键比较的代价，比较次数越多，代价越大，默认 0.05      |
    | `memory_temptable_row_cost`  |              内存临时表的创建代价，默认 0.1              |
    | `memory_temptable_row_cost`  |               内存临时表的行代价，默认 0.1               |
    |     `row_evaluate_cost`      | 统计符合条件的行代价，符合条件行越多，代价越大，默认 0.1 |

*   engine_cost

    |          统计项          |                备注                 |
    | :----------------------: | :---------------------------------: |
    |   `io_block_read_cost`   |  从磁盘读取一页数据的代价，默认 1   |
    | `memory_block_read_cost` | 从内存读取一页数据的代价，默认 0.25 |

可以更新这些参数，来优化 MySQL 的 CBO 计算

```mysql
# 增加磁盘扫描成本
UPDATE mysql.engine_cost SET cost_value = 2.0 WHERE cost_name = 'io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
# 针对 Innodb 存储引擎设置 io_block_read_cost
INSERT INTO mysql.engine_cost(engine_name, device_type, cost_name, cost_value, last_update, comment)
  VALUES ('InnoDB', 0, 'io_block_read_cost', 2,
  CURRENT_TIMESTAMP, 'Using a slower disk for InnoDB');
FLUSH OPTIMIZER_COSTS;
```

###### 执行代价

CBD 执行代价等于 I/O 执行代价（数据页和索引页加载）加 CPU 执行代价（权重因子（CPU 到 I/O 之间转化的相关系数）乘键比较和行估算的代价）。

5.7 版本之后，代价模型进行了优化，加入了内存计算和远程操作的代价统计：总代价 = I/O 代价 + CPU 代价 + 内存代价 + 远程代价

##### 执行器

开始执行的时候，会先判断对这个表是否有相应的`SQL` 语句权限。如果没有就会返回没有权限的错误

```mysql
mysql> select * from T where ID=10;

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口（数据库的慢查询日志中的 `rows_examined` 字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的，有些时候，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 `rows_examined` 并不是完全相同的）

执行器执行查询流程：无索引则逐行扫描第一行直到最后一行，有索引则取满足条件的第一行，将所有满足条件的行组成记录集返回给客户端

#### 引擎层

负责数据的存储和提取，引擎以插件模式

#### 日志模块



