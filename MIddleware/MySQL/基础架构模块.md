### 基础架构及模块

MySQL 是典型的 C/S 程序架构

#### Client

##### 连接选项

###### 快速连接

包含各语言支持的 Connectors 及 mysql 客户端等

mysql 命令客户端每次和服务端建立连接后，使用默认连接参数会建立一个本地 Hash 表提供库名和表名的补全功能连接时使用选项 `-A`/`--quick`/`-q` 可以跳过这个阶段

mysql 客户端发送请求后，接收服务端返回结果的方式：

*   本地缓存，对于 API 的 `mysql_store_result`
*   不缓存，对应 API 的 `mysql_use_result`

客户端连接使用 `--quick`/`-q` 参数时，会使用不缓存处理结果和不把执行命令记录到本地命令历史文件

登录成功后，使用 `status` 命令查看状态

#### Server

包含 MySQL 大多数核心功能，及所有内置函数。所有跨存储引擎的功能（存储过程、触发器、视图、用户函数）都在这一层实现

##### 连接器

管理连接，权限验证，负责跟客户端建立连接，获取权限，维持和管理连接

*   身份认证

    如果用户名密码错误，会报错 `Access denied for user` ，然后客户端程序结束执行。如果认证通过，连接器会到权限表里查出拥有的权限。此后连接里的权限判断逻辑，都将依赖于此时读到到权限。（一个用户成功建立连接后，即使对该用户权限做了修改，也不会影响到已存在的连接的权限。修改完成后，再新建的连接才会使用新的权限设置）

*   自动断开连接

    连接器自动断开 `show processlist` 中 Command 列显示为 `Sleep` 的空间连接，时间由 `wait_timeout` 控制，默认 8 小时

*   长连接

    全部使用长连接会使 `MySQL` 占用内存涨的特别快，因为（`Mysql` 在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放。如果长连接累积起来，可能导致内存占用太大，被系统强行杀掉（`OOM`），导致 `Mysql` 异常重启。（定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后。如果使用`MySQL5.7`及以后版本，可以在每次执行一个比较大的操作后，执行 `mysql_reset_connection` 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态）

###### 连接管理线程

连接管理线程将每个客户端连接与处理该客户端连接的线程相关联，管理线程在必要时会创建一个新线程，线程数量于当前连接的客户端数量一样多。企业版包含一个线程池插件。

`thread_cache_size` （确定线程缓存大小）系统变量确定线程缓存大小，`Threads_cached`（缓存线程数） 和 `Threads_created`（无法缓存而创建的线程数） 状态变量。默认流程为连接管理线程接收新连接先查看是否存在缓存线程，存在这将其与连接关联，不存在这创建新线程与其关联。

`max_connections` 变量指定最大同时连接数，如果因为该限制导致拒绝连接，会增加 `Connection_errors_max_connections` 状态值。实际支持 `max_connections`  + 1 个客户端连接。保留额外连接供具有 `CONNECTION_ADMIN/SUPER` 权限账户连接。

8.0.19 前，组复制内部会话计入 `max_connections`，如果在启动组复制或尝试执行操作时服务器已达到限制，则操作失败，组复制或服务器可能会停止。8.0.19 开始，组复制内部会话与客户端连接分开处理，不计入 `max_connections` 限制。

MySQL 支持的最大客户端连接数取决于：给定平台线程库的质量、RAM、连接工作负载、所需响应时间、可用文件描述符数量。

###### 连接管理接口

在 `max_connections` 已满时进行管理需要配置管理接口，然后使用配置的管理接口登入

```ini
[mysqld]
admin_address=127.0.0.1
admin_port=33064
```

启用管理接口前置条件（配置 `admin_address` 和 `admin_port` 系统变量，管理连接的数量没有限制，具有 `SERVICE_CONNECTION_ADMIN`/`SUPER` 特权）

```shell
# 连接
mysql -h{admin_address} --protocol=TCP --port={admin_port}
```

8.0.21 开始，管理接口支持加密配置 `admin-ssl` 指定

```ini
[mysqld]
admin_address=127.0.0.1
admin_port=33064
admin_ssl_ca=admin-ca.pem
admin_ssl_cert=admin-server-cert.pem
admin_ssl_key=admin-server-key.pem
```

```ini
[mysqld]
# 此时 admin_ssl 相关配置无效
admin-ssl=OFF
admin_address=127.0.0.1
```

使用

```shell
mysql --protocol=TCP --port=33062
      --ssl-ca=admin-ca.pem
      --ssl-cert=admin-client-cert.pem
      --ssl-key=admin-client-key.pem
```

###### 连接线程

该线程处理身份认证并请求对该连接的处理。

##### 查询缓存

命中则直接返回结果，更新表数据则整个表的缓存都失效，8.0废除

`MySQL` 提供了按需缓存，将参数 `query_cache_type` 设置成 `DEMAND` ，这样对默认的 `SQL` 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 `SQL_CACHE` 显式指定

```sql
select SQL_CACHE * from T where ID = 10
```

##### SQL 接口

SQL 接口提供一套机制来接收命令以及传输结果给用户。MySQL的SQL接口遵从 ANSI SQL 标准，它和绝大多数遵从ANSI 标准的数据库服务器一样接受同样基础的 SQL 语句

##### 分析器

*   词法分析

*   语法分析，根据词法分析的结果，语法分析器会根据语法规则判断输入的 `SQL` 语句是否满足 `Mysql` 语法，如果语法不对会提示 `You have an error in your SQL syntax` ，语法错误会提示第一个出现错误的位置，即紧接 `use near` 的内容

##### 优化器

查询优化器的目标是找到执行 SQL 查询的最佳执行计划（查询树）它由一系列物理操作符组成，这些操作符按照一定的运算关系组成查询的执行计划。可以分为逻辑查询优化阶段和物理查询优化阶段

* 逻辑查询优化：通过改变 SQL 语句的内容来使得 SQL 查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对 SQL 语句进行等价交换，对查询进行重写（查询重写的数据基础是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。）
* 物理查询优化：关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率

###### 优化策略

查询优化器的生成最佳执行计划的策略通常有两种方式：

* 基于规则的优化器（RBO，Rule-Based Optimizer）。

    规则是人们以为的经历，或者是采用已被证明是有效的方式。通过在优化器里面嵌入规则。来判断 SQL 查询符合那种规则，就按照相应的规则来制定执行计划，同时采用启发式规则去掉明显不好的存储路径

* 基于代价的优化器（CBO，Cost-Based Optimizer）。

    这会根据代价评估模型，计算每条可能的执行计划的代价，COST，从中选择代价最小的作为执行计划。相比于 RBO，CBO 对数据更敏感，因为它会利用数据表中的统计信息来做判断，针对不同的数据表，查询得到的执行计划可能是不同的，因此制定出来的执行计划也更符号数据表的实际情况

大部分 RDBMS 都支持基于代价的优化器，在 MySQL 中的 COST Model（优化器用来统计各种步骤的代价模型）在 5.7.10 版本之后，mysql 库引入两张数据表，里面规定了各种步骤预估的代价

*   server_cost

    |            统计项            |                           备注                           |
    | :--------------------------: | :------------------------------------------------------: |
    | `disk_temptable_create_cost` |        MyISAM/InnoDB 创建磁盘临时表代价，默认 20         |
    |  `disk_temptable_row_cost`   |       MyISAM/InnoDB 创建磁盘临时表行代价，默认 0.5       |
    |      `key_compare_cost`      |     键比较的代价，比较次数越多，代价越大，默认 0.05      |
    | `memory_temptable_row_cost`  |              内存临时表的创建代价，默认 0.1              |
    | `memory_temptable_row_cost`  |               内存临时表的行代价，默认 0.1               |
    |     `row_evaluate_cost`      | 统计符合条件的行代价，符合条件行越多，代价越大，默认 0.1 |

*   engine_cost

    |          统计项          |                备注                 |
    | :----------------------: | :---------------------------------: |
    |   `io_block_read_cost`   |  从磁盘读取一页数据的代价，默认 1   |
    | `memory_block_read_cost` | 从内存读取一页数据的代价，默认 0.25 |

可以更新这些参数，来优化 MySQL 的 CBO 计算

```mysql
# 增加磁盘扫描成本
UPDATE mysql.engine_cost SET cost_value = 2.0 WHERE cost_name = 'io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
# 针对 Innodb 存储引擎设置 io_block_read_cost
INSERT INTO mysql.engine_cost(engine_name, device_type, cost_name, cost_value, last_update, comment)
  VALUES ('InnoDB', 0, 'io_block_read_cost', 2,
  CURRENT_TIMESTAMP, 'Using a slower disk for InnoDB');
FLUSH OPTIMIZER_COSTS;
```

###### 执行代价

CBD 执行代价等于 I/O 执行代价（数据页和索引页加载）加 CPU 执行代价（权重因子（CPU 到 I/O 之间转化的相关系数）乘键比较和行估算的代价）。

5.7 版本之后，代价模型进行了优化，加入了内存计算和远程操作的代价统计：总代价 = I/O 代价 + CPU 代价 + 内存代价 + 远程代价

##### 执行器

开始执行的时候，会先判断对这个表是否有相应的`SQL` 语句权限。如果没有就会返回没有权限的错误

```mysql
mysql> select * from T where ID=10;

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口（数据库的慢查询日志中的 `rows_examined` 字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的，有些时候，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 `rows_examined` 并不是完全相同的）

执行器执行查询流程：无索引则逐行扫描第一行直到最后一行，有索引则取满足条件的第一行，将所有满足条件的行组成记录集返回给客户端

##### Server 管理

###### 资源组

支持创建和管理资源组，并允许将服务器中运行的线程分配给特定的组，以便线程根据该组可用的资源执行。使用组属性可以控制其资源，以启用或限制组中线程的资源消耗。

使用 SQL 接口管理资源组（相关 SQL 语句不会写入 binlog）：

*   通过 SQL 语句创建、更改、删除资源组，并将线程分配给资源组。

    ```mysql
    # 创建资源组
    CREATE RESOURCE GROUP {group_name} TYPE = USER VCPU = {2-3}
      THREAD_PRIORITY = {10};
    # 将线程分配给组
    SET RESOURCE GROUP {group_name} FOR {thread_id};
    # 将会话线程分配给组，会话中语句将使用组资源执行
    SET RESOURCE GROUP {group_name};
    ```

*   资源组操作需要 `RESOURCE_GROUP_ADMIN` 特权
*   资源组信息在 `INFORMATION_SCHEMA.RESOURCE_GROUPS` 表，线程信息在 `PERFORMANCE_SCHEMA.THREADS` 表

资源组属性（对于用户定义的资源组，所有属性都在组创建时分配，创建组后，非名称和类型外其他属性都可以修改）

*   每个组都有一个名称。资源组名称是表和列名称之间之类的标识符，区分大小写，最长 64 位字符
*   每个组类型 `SYSTEM`/`USER`，资源组类型会影响可分配给该组的优先级范围（系统线程对应 `threads` 表的 `background` 线程，用户线程对应 `threads` 表的 `user` 线程 ）
*   CPU 属性
*   线程优先级（系统资源组，优先级范围 -20 ~ 0，用户资源组，优先级范围 0 ~ 19）
*   启用或禁用每个组

默认资源组（`SYS_default`/`USR_default`，每个默认组均不具有 CPU 关联且优先级为 0），默认组不能删除，属性不能修改。新创建的系统线程分配给 `SYS_default`，新创建的用户线程分配给 `USR_default`。

资源组在以下情况不可用或存在限制：

*   安装了线程池插件，则资源组不可用

*   macOS 上不可用，macOS 不提供将 CPU 绑定到线程的 API

*   FreeBSD/Solaris 上，资源组优先级被忽略

*   Linux 上，除非设置了 `CAP_SYS_NICE` 功能，否则将忽略资源组线程优先级

    1.  使用 systemd 管理和 4.3 以上内核（支持环境功能）

        ```shell
        # red/oracle
        sudo systemctl edit mysqld
        # debian
        sudo systemctl edit mysql
        ```

    2.  修改内容

        ```ini
        [Service]
        AmbientCapabilities=CAP_SYS_NICE
        ```

    3.  重启 MySQL 服务器

    使用 `setcap` 手动设置

    ```shell
    sudo setcap cap_sys_nice+ep /path/to/mysqld
    getcap /path/to/mysqld
    ```

###### 关闭

关闭流程：

1.  关闭过程启动

    具有 `SHUTDOWN` 特权的用户执行 `mysqladmin shutdown`，或使用信号通知关闭

2.  服务器创建关闭线程

    无法创建关闭线程记录错误日志

3.  服务器停止接受新连接

    关闭监听 socket

4.  服务器终止当前活动

    *   与客户端连接线程，将该线程标记为已终止（下次检查状态时退出）

    *   对于开启事务的线程，该事务将回滚
    *   对于正在更新非事务表的线程，操作多行时可能部分更新，操作可能完成前终止
    *   如果服务器是源服务器，它的副本连接线程与客户端连接线程同样处理
    *   如果服务器是副本服务器，将活动状态的 I/O 线程和 SQL线程（允许　SQL　线程完成当前语句，避免复制问题，如果）终止，然后终止客户端线程

5.  服务器关闭或关闭存储引擎

    

6.  服务器退出

#### 引擎层

负责数据的存储和提取，引擎以插件模式

#### 日志模块



