### 表相关信息

#### 表操作

##### 建表

###### 语法

```mysql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_options]
    [partition_options]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    [(create_definition,...)]
    [table_options]
    [partition_options]
    [IGNORE | REPLACE]
    [AS] query_expression

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    { LIKE old_tbl_name | (LIKE old_tbl_name) }

create_definition: {
    col_name column_definition
  | {INDEX | KEY} [index_name] [index_type] (key_part,...)
      [index_option] ...
  | {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name] (key_part,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] PRIMARY KEY
      [index_type] (key_part,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]
      [index_name] [index_type] (key_part,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] FOREIGN KEY
      [index_name] (col_name,...)
      reference_definition
  | check_constraint_definition
}

column_definition: {
    data_type [NOT NULL | NULL] [DEFAULT {literal | (expr)} ]
      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT 'string']
      [COLLATE collation_name]
      [COLUMN_FORMAT {FIXED | DYNAMIC | DEFAULT}]
      [ENGINE_ATTRIBUTE [=] 'string']
      [SECONDARY_ENGINE_ATTRIBUTE [=] 'string']
      [STORAGE {DISK | MEMORY}]
      [reference_definition]
      [check_constraint_definition]
  | data_type
      [COLLATE collation_name]
      [GENERATED ALWAYS] AS (expr)
      [VIRTUAL | STORED] [NOT NULL | NULL]
      [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT 'string']
      [reference_definition]
      [check_constraint_definition]
}

key_part: {col_name [(length)] | (expr)} [ASC | DESC]

index_type:
    USING {BTREE | HASH}

index_option: {
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'
  | {VISIBLE | INVISIBLE}
  |ENGINE_ATTRIBUTE [=] 'string'
  |SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
}

check_constraint_definition:
    [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]

reference_definition:
    REFERENCES tbl_name (key_part,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE reference_option]
      [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
    table_option [[,] table_option] ...

table_option: {
    AUTO_INCREMENT [=] value
  | AVG_ROW_LENGTH [=] value
  | [DEFAULT] CHARACTER SET [=] charset_name
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] collation_name
  | COMMENT [=] 'string'
  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}
  | CONNECTION [=] 'connect_string'
  | {DATA | INDEX} DIRECTORY [=] 'absolute path to directory'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] engine_name
  | ENGINE_ATTRIBUTE [=] 'string'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] value
  | MAX_ROWS [=] value
  | MIN_ROWS [=] value
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] 'string'
  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}
  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}
  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}
  | STATS_SAMPLE_PAGES [=] value
  | TABLESPACE tablespace_name [STORAGE {DISK | MEMORY}]
  | UNION [=] (tbl_name[,tbl_name]...)
}

partition_options:
    PARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)
        | RANGE{(expr) | COLUMNS(column_list)}
        | LIST{(expr) | COLUMNS(column_list)} }
    [PARTITIONS num]
    [SUBPARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list) }
      [SUBPARTITIONS num]
    ]
    [(partition_definition [, partition_definition] ...)]

partition_definition:
    PARTITION partition_name
        [VALUES
            {LESS THAN {(expr | value_list) | MAXVALUE}
            |
            IN (value_list)}]
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'string' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [(subpartition_definition [, subpartition_definition] ...)]

subpartition_definition:
    SUBPARTITION logical_name
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'string' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]

query_expression:
    SELECT ...   (Some valid select or union statement)
```

必须具有 CREATE 权限，默认使用默认存储引擎，如果表存在、没有默认数据库、使用的数据库不存在会报错，对表数量没有限制（基础文件系统会对表的文件数量进行限制），InnoDB 允许创建 40 亿张表，关键字作用：

###### 建表关键字

*   `LIKE` / `CREATE TABLE ... LIKE`

    基于原始表创建一个空表，包含其全部索引及列属性（不保留：外键定义、DATA DIRECTORY、INDEX DIRECTORY 表选项），需要对原始表有 SELECT 权限。仅适用于普通表，不适用视图、临时表。

    ```mysql
    CREATE TABLE new_tbl LIKE orig_tbl;
    ```

*   `AS query_expression` / `CREATE TABLE ... SELECT`

    从一个查询创建创建一个表

    ```mysql
    CREATE TABLE new_tbl AS SELECT * FROM orig_tbl;
    # select 中的列会追加到表定义中，且原有列数据以默认值填充
    CREATE TABLE bar (m INT) SELECT n FROM foo;
    ```

    8.0.19 开始支持 VALUES 语法

    ```mysql
    # 默认列名为 column_0, column_1 依次递增
    CREATE TABLE tv SELECT * FROM (VALUES ROW(1, 3, 5), ROW(2, 5, 6)) AS V;
    # 指定列名为 x，y，z
    CREATE TABLE tv1 SELECT * FROM (VALUES ROW(1, 3, 5), ROW(2, 4, 6)) AS v(x, y, z)
    # 选择所有列并使用默认列名时，可以省略 SELECT *
    CREATE TABLE tv2 VALUES ROW(1,3,5), ROW(2,4,6);
    ```

*   `IF NOT EXISTS`

    如果表存在，可以防止发生错误

###### 外键（FOREIGN KEY）

对于支持外键的存储引擎，如果父表没有匹配的值，而插入或更新子表外键的的值时会失败。

操作表时会打开父表的元数据锁。如果显式锁定了表，则父表会隐式锁定。对于外键检查，LOCK TABLES READ 将在相关表使用共享只读锁。对于级联更新，将对操作中涉及的表使用独占写锁。

```mysql
[CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (col_name, ...)
    REFERENCES tbl_name (col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
    
ALTER TABLE tbl_name
    ADD [CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (col_name, ...)
    REFERENCES tbl_name (col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]
    
ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol
```

*   外键命名约束（`CONSTRAINT [symbol]`）

    如果已定义（必须唯一）CONSTRAINT symbol ，则使用该值，否则自动生成外键约束名称

*   外键检查会检查外键引用的完整性

    由 `foreign_key_checks` 变量控制，该变量默认启用。禁用该选项后添加的行在重新启用改选项后不会检查

*   创建外键先决条件

    1.  父表和子表必须使用相同的存储引擎，且不能定位为临时表，需要 REFERENCES 父表权限。具有外键约束的父表和子表不能更改引擎，要更改引擎，必须先删除外键约束
    2.  外键和引用键中的对应列必须具有相同的数据类型（整数类型和符合必须相同）。字符串长度不必相同（字符集和排序规则必须相同）
    3.  支持列对表中另一列的外键引用（但不能是自身），外键约束不能引用生成的虚拟列
    4.  在外键和引用键上建立索引（引用表中，必须有一个索引），其中外键列以相同的顺序为第一列，如果不存在索引，会自动在引用表上创建。外键列不支持前缀索引（即无法以 BLOB 和 TEXT 列创建外键）
    5.  不支持具有用户定义分区的表的外键（父表和子表都不能是分区表）

*   外键动作（`reference_option`）

    *   RESTRICT

        拒绝父表的删除或更新操作，与省略 `ON DELETE` 或 `ON UPDATE` 一致

    *   CASCADE

        从父表删除或更新该行，自动删除或更新子表中的匹配行（级联操作不会激活触发器）

    *   SET NULL

        从父表删除或更新行，将子表的一个或多个外键列设置为 NULL

    *   NO ACTION

        等价 RESTRICT

    *   SET DEFAULT

        由解析器决定

*   外键信息

    ```mysql
    # 查询外键信息
    SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME
           FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
           WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL
    # 获取外键信息
    SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN
    SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN_COLS \G
    ```

    InnoDB 中外键错误，常返回 150，可以检查 `SHOW ENGINE INNODB STATUS` 检查

###### 约束（CHECK）

约束会检查 INSERT、UPDATE、REPLACE、LOAD DATA、LOAD XML 动作，如果约束检查失败会失败。如果在以上操作后跟 IGNORE 关键字，则跳过有问题的行继续操作。

```mysql
# 8.0.16 之前
CHECK (expr)
# 8.0.16 开始，表和列的约束功能语法
[CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]
CREATE TABLE tc
(
  CHECK (c1 <> c2),
  c1 INT CHECK (c1 > 10),
  c2 INT CONSTRAINT c2_positive CHECK (c2 > 0),
  c3 INT CHECK (c3 < 100),
  CONSTRAINT c1_nonzero CHECK (c1 <> 0),
  CHECK (c1 > c3)
);
```

*   symbol 

    约束名，最长 64 个字符，省略自动生成。每个约束类型在每个数据库中都有自己的名称空间，约束名称对于每个数据库必须是唯一的（同数据库中两个表的约束名称不能相同）

*   expr 

    约束条件指定为布尔表达式，对于表的每一行，布尔表达式必须等于 TRUE 或 UNKNOW（对于 NULL 值）。如果条件的计算结果为 FALSE 则失败，发生约束冲突。如果约束表达式计算出的数据类型于声明的列类型不同，通常会隐式转换。允许使用字符、确定性内置函数、运算符。不允许使用存储过程、用户函数、变量（系统、用户、局部）、子查询。

*   可选的执行子句 `[[NOT] ENFORCED]` 指示是否强制执行约束：如果省略或指定 ENFORCED，则约束将被创建和执行，如果指定为 NOT ENFORCED，则创建约束但不强制约束

*   将 CHECK 约束指定为表约束或列约束时：表约束不会出现在列定义中，并且可以引用表的任何列，列约束出现在列（除 AUTO_INCREMENT 列和外键列）中，只能引用该列

###### 列属性及约束

*   单表只有有一列 AUTO_INCREMENT，且 AUTO_INCREMENT 只支持整型和浮点型

*   8.0.13 之前，BLOB、TEXT、GEOMETRY、JSON 不支持 DEFAULT 属性

*   如果未启用严格模式，大于 65535 的 `VARCHAR` 和 `VARBINARY` 列转为 `TEXT` 和 `BLOB`，否则会报错

*   支持单独为字符类型指定字符串和排序规则

    ```mysql
    CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);
    ```

*   JSON 列无法建立索引，可以创建间接引用的索引（定义一个生成的列，该列值为待建立 JSON 列索引的属性，在生成列上创建索引）

    ```mysql
    # 为 JSON id 的属性建立间接索引
    CREATE TABLE jemp(c json, g int GENERATED ALWAYS AS (c->"$.id"), index i (g));
    ```

*   对字符或二进制字符创建前缀索引（字符以字符计数，二进制以字节计数）时，如果索引前缀超过了最大列数据类型大小：对于非唯一索引，在启用严格 SQL 模式时会报错，未启用会缩减索引长度到最大列数据类型大小之内并产生警告；对于唯一索引，无论那种 SQL 模式都会报错。

    ```mysql
    # 仅 InnoDB 和 MyISAM 存储引擎支持在 BLOB 和 TEXT 列上建立索引
    CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
    ```

*   如果未指定 NULL 和 NOT NULL，则默认 NULL，MySQL 8 中，只有 InnoDB、MyISAM、MEMORY 引擎支持索引列上存在 NULL 值，其他情况必须将索引列声明未 NOT NULL，否则会报错

*   列注释最长 1024 字符

*   对于 NDB 引擎可以使用 STORAGE 指定列存储位置

    ```mysql
    # DEFAULT 和 MEMORY 存储在内存中，DISK 存储在磁盘上
    CREATE TABLE t1 (c1 INT STORAGE DISK, c2 INT STORAGE MEMORY) TABLESPACE ts_1 ENGINE NDB
    ```

*   可以使用 `GENERATED ALWAYS` 指定生成列

    根据列定义中包含的表达式计算生成的列的值

    ```mysql
    col_name data_type [GENERATED ALWAYS] AS (expr)
      [VIRTUAL | STORED] [NOT NULL | NULL]
      [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT 'string']
    ```

    *   expr 表示已生成列的表达式或值（允许使用文字，内置确定性函数、运算符，不允许使用存储过程和自定义函数，不允许使用变量包括系统、用户、局部，不允许使用子查询）
*   VIRTUAL（未指定时默认）表示列值不存储，不占用存储空间，InnoDB 支持虚拟列上的二级索引，不支持外键；STORED 插入或更新行时，将存储列值，会占用存储空间。
    
    *   生成列可以引用它之前定义的生成列和任何的基础列。AUTO_INCREMENT 不能在生成的列定义中使用。触发器不能使用或用于引用生成的列。
*   如果要显式操作（ INSERT，REPLACE、UPDATE）生成的列，唯一允许的值为 DEFAULT。
    
    *   允许按生成的列进行分区

###### 建表选项

表选项用于优化表行为，默认不需要指定

|              选项              |                             含义                             |
| :----------------------------: | :----------------------------------------------------------: |
|             ENGINE             |          指定存储引擎（引擎名可以加引号或不加引号）          |
|         AUTO_INCREMENT         |                         自增初始化值                         |
|         AVG_ROW_LENGTH         | 表的平均行长的近似值，仅需要为具有可变大小行的大型表设置此选项 |
|     CHARACTER SET/CHARSET      |                          指定字符集                          |
|            CHECKSUM            |               仅 MyISAM，为 1 时自动更新校验和               |
|            COLLATE             |                     指定表的默认排序规则                     |
|            COMMENT             |                   表注释，最多 2048 个字符                   |
|          COMPRESSION           | 用于 InnoDB 表的页面级压缩缩放，支持 Zlib、LZ4、None，仅单独表空间和支持稀疏文件的平台可用 |
|           CONNECTION           |                   FEDERATED 表的连接字符串                   |
| DATA DIRECTORY/INDEX DIRECTORY | 对于 InnoDB，允许在数据目录外创建表。必须启用 `innodb_file_per_table` 和制度完整路径 |
|        DELAY_KEY_WRITE         |            仅适用 MyISAM 表，为 1 时将延迟表更新             |
|           ENCRYPTION           |      InnoDB 页面级数据加密，必须先安全和配置密钥插件。       |
|         INSERT_METHOD          |                       仅对 MEGRE 表。                        |
|         KEY_BLOCK_SIZE         | MyISAM 表，指定用于索引键块的字节大小。InnoDB 表，指定提示用于压缩表的页面大小（kb） |
|            MAX_ROWS            |             计划存储的最大行数，非硬性限制，提示             |
|            MIN_ROWS            |             提示最小行数，MEMORY 会提示内存使用              |
|           PACK_KEYS            | 仅 MyISAM，使用较小索引将此设为 1 可避免速度变慢，为 0 将禁用所有 key 打包 |
|            PASSWORD            |                            未使用                            |
|           ROW_FORMAT           |                     定义行存储的物理格式                     |
|       STATS_AUTO_RECALC        | InnoDB 是否自动重新计算持久统计数据，值 0 不会自动计算，1 当表中 10% 数据更改时会重新计算。DEFAULT 由 `innodb_stats_auto_recalc` 配置指定 |
|        STATS_PERSISTENT        | InnoDB 是否启用持久统计信息，DEFAULT 由 `innodb_stats_persistent` 配置指定，1 启用，0 关闭。 |
|       STATS_SAMPLE_PAGES       |       估计索引列的基数和其他统计信息时要采样的索引页数       |
|           TABLESPACE           | 指定表空间，innodb_system 系统表空间，innodb_file_per_table 单独表空间，启用 `innodb_file_per_table` 则无需指定单独表空间 |
|             UNION              |                         仅适用 MERGE                         |

##### 数据类型

###### 整数类型

M 指示最大显示宽度，最大显示宽度为 255，显示宽度与类型可存储的值的范围无关

|    Type     | Storage (Bytes) | Minimum Value Signed | Minimum Value Unsigned | Maximum Value Signed | Maximum Value Unsigned |
| :---------: | :-------------: | :------------------: | :--------------------: | :------------------: | :--------------------: |
|  `TINYINT`  |        1        |        `-128`        |          `0`           |        `127`         |         `255`          |
| `SMALLINT`  |        2        |       `-32768`       |          `0`           |       `32767`        |        `65535`         |
| `MEDIUMINT` |        3        |      `-8388608`      |          `0`           |      `8388607`       |       `16777215`       |
|    `INT`    |        4        |    `-2147483648`     |          `0`           |     `2147483647`     |      `4294967295`      |
|  `BIGINT`   |        8        |       `-2^63`        |          `0`           |       `2^63-1`       |        `2^64-1`        |

###### 浮点数

存储近似数，8.0.17 不建议使用 `FLOAT(M,D)`/`DOUBLE(M,D)` 定义语法，后续可能会移除，建议直接使用 `FLOAT` /`DOUBLE` 不指定精度或位数，存储时执行四舍五入。

*   `FLOAT`

    单精度（0～23），使用 4 个字节存储。

*   `DOUBLE`

    双精度（24～43），占用 8 个字节，都支持使用标准的浮点运算进行近似计算，MySQL 使用 `DOUBLE` 作为内部浮点计算的类型

###### 位数据

存储 bit 值，`BIT(M)` 可以存储 M 个 bit 值，M 范围 1 ～ 64，存储的是 0 和 1 的字符串，存储宽度小于 M 时，会在左边填充 0

* MYISAM 会打包存储所有的 BIT 列，即 17 个单独的 BIT 列只需要 17 个位存储（假设没有可为 NULL 的列），这样 MYISAM 只使用 3 个字节就能存储这 17 个 BIT 列。
* 其他存储引擎如 Memory 和 InnoDB，为每个 **BIT** 列使用一个足够存储的最小整数类型来存放，所以不能节省空间

###### 精确值

存储精确数值数据。MySQL 中 `NUMERIC` 实现为 `DECIMAL`，以二进制存储值，超过精度位数时，四舍五入。声明时指定精度和小数点位数 `DECIMAL(5,2)`，前面是精度，后面是小数位数。未指定时默认为 `DECIMAL(10,0)`，当小数位数为 0 时，值不包含小数点和小数部分。

###### 数值型属性

*   浮点数和精确值可以指定 `UNSIGNED` 属性，但不推荐，使用 `CHECK` 提供约束替代
*   8.0.17 不推荐使用 `ZEROFILL` 作为数字属性，不推荐使用整数的显示宽度属性，将来会删除。可以使用 `LPAD()` 对数字进行零填充以达到所需的宽度。

*   所有整数类型都可以具有 `UNSIGNED` 属性，当指定 `ZEROFILL` 时，自动为指定 `UNSIGNED` 属性。
*   整数或浮点数（8.0.17 开始废弃）可以具有 `AUTO_INCREMENT` 属性，对于 `AUTO_INCREMENT` 列，插入NULL 或 0 时，会设置为当前 VALUE + 1，当启用（`NO_AUTO_VALUE_ON_ZERO`）时例外，当列声明为 NULL 时，为插入 NULL，当插入其他值时，设置为该值，且重置序列，下一个自动生成的值从插入的值开始。`AUTO_INCREMENT` 不支持负值，不能使用 `CHECK` 约束。
*   如果未指定 `NO_UNSIGNED_SUBTRACTION` 模式，`UNSIGNED` 减法会产生无符号结果，如果结果为负，导致错误
*   如果启用了严格 SQL 模式 `TRADITIONAL` 执行超过范围的值更新将产生错误并失败，如果未启用严格模式，会进行值裁剪。
*   数值表达式求值期间的溢出会导致错误

###### 日期和时间数据

*零值*

|     数据类型     |         零值          |                           范围                            | 格式                             |
| :--------------: | :-------------------: | :-------------------------------------------------------: | -------------------------------- |
|      `DATE`      |     `0000-00-00`      |                 `1000-01-01 ~ 9999-12-31`                 | `YYYY-MM-DD`                     |
|   `TIME(fsp)`    |      `00:00:00`       |           `-838:59:59.000000~838:59:59.000000`            | `hh:mm:ss`/`hhh:mm:ss`           |
| `DATETIME(fsp)`  | `0000-00-00 00:00:00` | `1000-01-01 00:00:00.000000 ~ 9999-12-31 23:59:59:999999` | `YYYY-MM-DD hh:mm:ss[.fraction]` |
| `TIMESTAMP(fsp)` | `0000-00-00 00:00:00` |   `1970-01-01 00:00:01.000000~2038-01-19 03:14;07.9999`   | `YYYY-MM-DD hh:mm:ss[.fraction]` |
|    `YEAR(4)`     |        `0000`         |                                                           |                                  |

fsp 范围 0 ～ 6，0 表示没有小数。默认 0。

*   对于 `TIMESTAMP` 的默认值，由 `explicit_defaults_for_timestamp` 属性控制。存储时 `TIMESTAMP` 值将从当前时区转为 UTC 进行存储，检索时转换为当前时区。

*   8.0.19 开始，支持指定 `TIMESTAMP` 和 `DATETIME` 时区偏移量，偏移量被附加到日期部分，中间没有空格。8.0.22 开始日期和月份不能为零（无论 SQL 模式），查询时不会显示偏移量

    ```mysql
    # 对于小于 10 的小时值，需要前导 0
    INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'), ('2020-01-01 10:10:10+05:30'),('2020-01-01 10:10:10-08:00');
    ```

*   `DATETIME` 可以使用 `DEFAULT` 和 `ON UPDATE` 定义初始化值和更新列值

*   8.0.19 开始 `YEAR(4)` 不推荐显式宽度，8.0 开始不支持 `YEAR(2)`，00～69 为 2000～2069，70～99 为 1970～1999

*   `TIME` 可以用来表示经过的时间或两个事件之间的时间间隔。超出范围后默认会裁剪，将冒号的缩写解释为一天中的时间 `11:12` 为 `11:12:00`，`1112` 为 `00:11:12`

###### 字符串类型

包含 `CHAR`、`VARCHAR`、`BINARY`、`VARBINARY`、`BLOB`、`TEXT`、`ENUM`、`SET`，对于字符类型（`CHAR`、`VARCHAR`、`TEXT`）以字符单位解释长度，对于二进制字符串（`BINARY`、`VARBINARY`、`BLOB`）以字节解释长度。

*   支持对字符类型和 ENUM、SET 指定字符集和排序规则

    ```mysql
    CREATE TABLE t
    (
        c1 VARCHAR(20) CHARACTER SET utf8,
        c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs
    );
    ```

*   为字符串数据类型指定 `CHARACTER SET binary` 属性会导致将列创建为对应的二进制字符串数据类型，`ENUM` 和 `SET` 除外

*   `BINARY` 属性用于指定对应字符集的 `_bin` 字符集集（此时，比较和排序基于数字字符代码值），列本身存储字符值。8.0 不建议使用，8.0.17 开始废弃

    ```mysql
    CREATE TABLE t
    (
      c1 VARCHAR(10) CHARACTER SET latin1 BINARY,
      c2 TEXT BINARY
    ) CHARACTER SET utf8mb4;
    # 等价
    CREATE TABLE t (
      c1 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_bin,
      c2 TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin
    ) CHARACTER SET utf8mb4;
    ```

    `ASCII` 属性是 `CHARACTER SET latin1` 简写、`UNICODE` 属性是 `CHARACTER SET ucs2` 简写。

*   `CHAR`

    长度范围 0～255，存储时，会用空格右填充到指定长度，检索时，尾部空格会删除。未启用严格模式将截断存储，启用则报错。对于 `CHAR` 列，无论使用哪种 SQL 模式，插入都会截断尾部空格。

*   `VARCHAR` 长度范围 0～65535，最大有效长度取决于最大行大小（65535 字节，所有列共享）和字符集，使用 1 字节（255），2 字节（大于 255）来存储长度，未启用严格模式将截断存储，启用则报错，对于 `VARCHAR` 列，无论使用哪种 SQL 模式，插入前都会截断超出列长度的尾部空格。存储时不会进行填充，标准 SQL 模式下，存储和检索保留尾部空格

*   `BINARY`

    未启用严格模式，超过列长度值会被截断，否则报错。存储时右侧填充 `0x00`，检索时不会删除填充值。所有字节在比较中都有效

*   `VARBINARY`

    未启用严格模式，超过列长度值会被截断，否则报错。插入时不会填充，检索时也不会删除。所有字节比较中都有效

*   `TINYBLOB`、`BLOB`、`MEDIUMBLOB`、`LONGBLOB`，二进制大对象，值被视为二进制字符串。具有 binary 字符集和排序规则，比较和排序基于列值中字节的数字值。如果未启用严格模式，超过长度将被截断，否则报错。插入和检索时值不变，不能有 `DEFAULT` 值

*   `TINYTEXT`、`TEXT`、`MEDIUMTEXT`、`LONGTEXT` 插入和检索时值不变。不论 SQL 模式，超过列长度尾部空格会截断，并产生警告。不能有 `DEFAULT` 值

*   每个 `TEXT` 和 `BLOB` 值在内部由单独分配的对象表示，其他所有数据类型在打开表时为每列分配一次存储

###### 枚举

```mysql
CREATE TABLE shirts (
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
);
```

值是一个字符串是从允许值列表（创建时在列规范中显式枚举，自动删除成员尾部空格）中选择的值。压缩存储。枚举值根据索引排序（空串排在非空串之前，NULL 排在所有其他值之前），索引从 1 开始，空串和错误值索引为 0，NULL 值索引为 NULL。最多支持 65535 个元素，数字上下文检索返回列索引。

枚举值可以是空串，如果插入了列表中不存在的字符串，则会插入空串，严格模式会报错。如果被声明为允许 NULL，则 NULL 为有效值。声明为 NOT NULL，默认为第一个元素

枚举值不能是表达式和用户变量，不要使用数字作为枚举值。严格模式下，定义中包含重复值会报错

###### 集合

零个或多个值的字符串对象。每个值（以数字方式存储，按数字排序，NULL 值在非 NULL 之前）都必须从创建表时指定的允许值列表（自动删除成员尾部空格）中选择。最多支持 64 个元素。严格模式下定义重复的值、插入不支持值会报错

```mysql
# 查找 set_col 包含 value 的行
SELECT * FROM tbl_name WHERE FIND_IN_SET('value', set_col)>0;
# 查找 set_col 包含 value 任何位置的行
SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
# 查找包含第 num 个 set 成员的值
SELECT * FROM tbl_name WHERE set_col & {num};
```

###### 空间数据类型

MySQL 将空间扩展实现为带有几何类型的 SQL 环境的子集。MySQL 空间扩展可实现地理特征的生成、存储和分析：

*   表示空间值的数据类型
*   操作空间值的功能
*   空间索引可缩短对空间列的访问时间

空间数据类型和函数可用于 MyISAM、InnoDB、NDB、ARCHIVE。MyISAM 和 InnoDB 支持 SPATIAL 索引和非 SPATIAL 索引。其他存储引擎支持非 SPATIAL 索引。具有空间数据类型的列可以具有 SRID 属性，以明确指示存储在列中的值的空间参考系统（SRS）

值应该以内部几何格式存储，可以从已知文本（WKT）/已知二进制（WKB）格式转换

```mysql
INSERT INTO gemo VALUES (ST_GeomFromText('POINT(1 1)'));
INSERT INTO geom VALUES (ST_GeomFromWKB(X'0101000000000000000000F03F000000000000F03F'));
```

###### JSON

自动验证存储在 JSON 列中的 JSON 文档。无效的文档会产生错误。JSON 列中存储的文档将转换为内部格式，可以快速读取。8.0 支持 JSON Merge Patch 格式。存储 JSON 文档所需的空间与 `LONG BLOB` 或 `LONG TEXT` 大致相同。存储在 JSON 列中的任何 JSON 文档大小都限于 `max_allowed_packet` 系统变量的值，可以使用 `JSON_STORAGE_SIZE()` 函数获取存储 JSON 文档所需的空间。

8.0.13 之前，JSON 列不能具有非 NULL 默认值。8.0 中，优化器可以执行 JSON 的部分更新（非删除旧文档并存储新文档），可以对（更新的列声明为 JSON、对 `UPDATE` 列使用 `JSON_SET()`、`JSON_REPLACE()`、`JSON_REMOVE()` 函数更新列，列值的直接分配不能作为部分更新之下、输入列和目标列必须是同一列、所有更改都会用新值替换现有数组或对象，并且不会将任何新元素添加父对象或数组、新值不能大于旧值，可以使用 `JSON_STORAGE_FREE()` 查看任何 JSON 部分列更新已释放了多少空间）执行此优化

可以使用节省空间的紧凑格式将此类部分更新写入二进制日志（将 `binlog_row_value_options=PARTIAL_JSON`）

```mysql
# json 数组
["abc", 10, null, true, false]
# json 对象
{"k1": "value", "k2": 10}
# 对象数组嵌套，JSON 数组/对象可以包含字符串、数字、空串、true/false、时间
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
```

在 MySQL 中，JSON 值被编写为字符串，使用 utfmb4 字符集和 utf8mb4_bin 排序规则处理 JSON 上下文中使用的字符串。其他字符集中字符串将转化为 utfmb4

##### 维护表

###### ANALYZE TABLE

```mysql
# 默认将写入 binlog，NO_WRITE_TO_BINLOG 或 LOCAL 将不会记录到 binlog
ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE tbl_name [, tbl_name] ...
# 为对的列生成直方图统计信息，并将其存储在数据字段中
ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE tbl_name
    UPDATE HISTOGRAM ON col_name [, col_name] ...
        [WITH N BUCKETS]
# 从数据字典中删除列的直方图统计信息
ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE tbl_name
    DROP HISTOGRAM ON col_name [, col_name] ...
# 采样计数器使用
# 生成直方图统计信息之前启用计数器
SET GLOBAL innodb_monitor_enable = 'sampled%';
# 生成直方图
ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\G
# 查询，计数器采样率估算（sampling rate = sampled_page_read/(sampled_pages_read + sampled_pages_skipped)）
SELECT NAME, COUNT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE 'sampled%'\G
```

适用于 InnoDB（如果弃用了 `innodb_read_only` 可能失败）、NDB、MyISAM 表，不适用于视图。需要表的 SELECT 和 INSERT 权限，分析中将使用读锁锁定 InnoDB 和 MyISAM。

从表定义缓存中删除该表，会刷新锁。从 INFORMATION_SCHEMA.INNODB_TABLESTATS 表中清除表统计信息，并将 STATS_INITIALIZED 列设置为 Uninitialized，下次访问该表时，将再次收集统计信息

对于 InnoDB 表，通过对每个索引树执行随机采样并更新索引基数的估计值，8.0.19 开始，InnoDB 引擎为表存储的数据提供了自己的采样实现（当存储引擎不提供时，默认采样实现需要全表扫描），避免了全表扫描采样的性能影响

###### CHECK TABLE

```mysql
CHECK TABLE tbl_name [, tbl_name] ... [option] ...

option: {
    FOR UPGRADE
  | QUICK
  | FAST
  | MEDIUM
  | EXTENDED
  | CHANGED
}
```

检查一个或多个表是否有错误，支持对视图进行检查（适用于 InnoDB、MyISAM、ARCHIVE、CSV），会进行以下检查

*   版本兼容性检查

    FOR UPGRADE 选项检查表是否于当前版本的 MySQL 兼容。将检查自建表以来，表的任何数据类型或索引中是否存在任何不兼容的更改。如果兼容则检查成功，否则，将对表进行全面检查（由于数据类型的存储格式或排序规则变更，可能出现不兼容）。已知不兼容：

    *   4.1 和 5.0 直接 TEXT 列结尾空间的索引顺序
    *   5.0.3 和 5.0.5 之间更改了 DECIMAL 存储方法
    *   8.0 不支持 YEAR(2)
    *   使用费本地分区的表发出警告，8.0 已删除非本地分区

*   数据一致性

    以下选项实现数据一致性检查，这些选项可以组合使用，将传递到存储引擎，该引擎可以使用或忽略

    |   类型   |                             含义                             |
    | :------: | :----------------------------------------------------------: |
    |  QUICK   |  不扫描行以检查不正确的链接，适用于 InnoDB、MyISAM 表及视图  |
    |   FAST   | 仅检查尚未正确关闭的表，适用于 MyISAM 表和视图（InnoDB 忽略该选项） |
    | CHANGED  | 仅检查上次检查以来更改或未正确关闭的表，InnoDB 忽略，适用 MyISAM 视图及表 |
    |  MEDIUM  | 扫描行以确定删除的连接有效，将计算行的密钥校验和进行校验，InnoDB 忽略，适用 MyISAM 视图和表 |
    | EXTENDED | 对每一行的所有键进行全键查找，可以确保表是 100% 一致的，InnoDB 忽略，适用 MyISAM 表和视图 |

    ```mysql
    CHECK TABLE test_table FAST QUICK;
    ```

    *   InnoDB 表检查

        遇到损坏的页面或辅助索引，会导致服务器退出；对于单独的 .idb 文件，仅检查标头数据，要验证 .ibd 文件的全部内容，适用 innochecksum 命令

    *   MyISAM 表检查

        会更新 MyISAM 表的关键统计信息。未返回 OK 或 table is already up to date，通常应修复表。默认检查类型 MEDIUM。

###### CHECKSUM TABLE

获取表内容的校验和，适用于验证备份数据，需要 SELECT 权限，不支持视图。执行期间会占用读锁，默认情况下，逐行读取并计算校验和。校验和取决于行格式，如果行根式更改，校验和也将更改。如果两个表的校验和不同，则几乎肯定表某种不同（不排除哈希冲突导致产生相同的校验和）

```mysql
CHECKSUM TABLE tbl_name [, tbl_name] ... [QUICK | EXTENDED]
```

###### OPTIMIZE TABLE

```mysql
OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE tbl_name [, tbl_name] ...
```

重新组织表数据及关联索引数据的物理引擎，以回收存储空间（对于 InnoDB 需要单独的表空间才可以回收）并提高访问表时的 I/O 效率，优化内容取决于表的存储引擎，需要对表的 SELECT 和 INSERT 权限，不适用于视图。

*   InnoDB 表优化

    对 InnoDB 常规表和分区表适用在线 DDL 方式（包含 FULLTEXT 索引的表不支持在线 DDL，适用表复制）

    在以下情况下，适用表复制方法重建表：`old_alter_table` 系统变量启用，适用 `--skip-new` 选项启动服务器时

*   MyISAM 表优化

    如果表已删除或拆分行，会修复该表；如果索引页未排序，对其排序，更新表统计信息

###### REPAIR TABLE

```mysql
REPAIR [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE tbl_name [, tbl_name] ...
    [QUICK] [EXTENDED] [USE_FRM]
```

仅适用于 MyISAM、ARCHIVE、CSV，对于 MyISAM，默认情况下等于 `myisamchk --recover {t_name}`，不支持视图，需要对表的 SELECT 和 INSERT 权限。支持以下选项：

*   QUICK

    仅修复索引文件，不修复数据文件，类似 `myisamchk --recover --quick`

*   EXTENDED

    逐行修复，类似 `myisamchk --safe-recover`

*   USE_FRM

    如果 `.MYI` 索引文件丢失或标头损坏，可以使用该选项。会使用数据字典信息重建创建 `.MYI` 头信息

    仅无法常规修复时才使用该选项，会导致当前 AUTO_INCREMENT 值丢失，已删除记录的链接丢失，不应该与压缩表一起使用（无法确定表是否已压缩，修复会导致表内容更改或丢失）

#### 表状态

##### 当前状态信息

在文件系统中，MySQL 将每个数据库保存为数据目录的一个子目录。创建表时，MySQL 会在数据库子目录下创建一个和表同名的 .frm 文件保存表的定义（8.0 已弃用 .frm 文件，5.7 与 5.6 最新版本也已弃用）。

MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台相关。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是 Server 层统一处理的

```mysql
# 可以查询 INFORMATION_SCHEMA 获取表查询表详情
SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr];
# 在当前 schema 下查看表信息
SHOW TABLE STATUS LIKE 'user';
# 通过 INFORMATION_SCHEMA 库查询表信息
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '{name}' AND TABLE_SCHEMA = '{schema}';
```

包含以下信息：

|      名称       |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
|      Name       |                             表名                             |
|     Engine      |                 表存储引擎，5.0 之前为 Type                  |
|     Version     | 已弃用，未使用 .frm 文件时固定为 10，使用 .frm 文件时为 .frm 文件版本 |
|   Row_format    |   行格式（Fixed、Dynamic、Compressed、Redundant、Compact）   |
|      Rows       | 表中行数，依据存储引擎，该值可能是确值也可能是估值，INFORMATION_SCHEMA 表为 null |
| Avg_row_length  |                     平均每行包含的字节数                     |
|   Data_length   | 表大小（以字节为单位），MyISAM 为数据文件长度，InnoDB 为聚集索引大小（页乘页大小） |
| Max_data_length | 表数据的最大容量，MyISAM 为数据文件大小，InnoDB 未使用该字段 |
|  Index_length   | 索引大小（字节），MyISAM 为索引文件长度，InnoDB 近似二级索引大小 |
|    Data_free    |                            多含义                            |
| Auto_increment  |                  下一个 AUTO_INCREMENT 的值                  |
|   Create_time   |                           建表时间                           |
|   Update_time   |                    表数据文件最后更新时间                    |
|   Check_time    | 使用 CHECK TABLE 命令或 myisamchk 工具最后一次检查表的时间，并非所有引擎都更新该时间，此时为 NULL，分区 InnoDB 表， |
|    Collation    |               表的默认字符集和字符序列排序规则               |
|    Checksum     |                       当前 cheksum 值                        |
| Create_options  |                    创建表时指定的其他选项                    |
|     Comment     | 其他额外信息，默认存储的是建表时带的注释，或者是为什么无法访问表的原因 |

*   Data_free

    *   MyISAM，表示已分配未使用的空间，该空间包括了之前删除的行，以及后续可以被 INSERT 利用的空间；

    *   InnoDB 为所属表空间的可用空间。对于位于共享表空间中的表：为共享表空间的可用空间；如果为单表空间：为完全可用范围中的字节数减去安全容量。即使可用空间显示为 0，只要不需要分配新的盘区，也可以插入行

    *   对于 NDB 集群，显示为磁盘上为表分配但未使用的空间（内存中数据资源使用情况由 Data_length 列报告）

    *   对于分区表，为估计值，获取此信息的更准确方法是查询 INFORMATION_SCHEMA.PARTITIONS 表

        ```mysql
        SELECT SUM(DATA_FREE) FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA = '{mydb}' AND TABLT_NAME = '{mytable}'
        ```

*   Update_time

    对于某些存储引擎，此值为 NULL。InnoDB 在系统表空间中存储多个表，数据文件时间戳则不适用；InnoDB 使用单独的 .idb 文件时，更改缓冲也会延迟对数据文件的写入（文件修改时间与上次插入、更新、删除时间不同）对于 MyISAM 使用数据文件时间戳（在 Windows 上，时间戳不会通过更新进行更新，该值不准确）

    Update_time 显示对未分区的 InnoDB 表执行的最后一次 UPDATE、INSERT、DELETE 时间戳。对于 MVCC 时间戳反映了 COMMIT 时间，该时间被视为最后更新时间。重启服务器或从 InnoDB 数据字典高速缓存中清除表时，时间戳不会保留

##### 表维护

#### 分区表

##### 手动分表

手动分表与分区表的区别在于手动分表由应用层进行分表，而分区表由 MySql 进行分表，对业务完全透明，业务代码更加简洁。

分区表和手动分表，一个是由 `server` 层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。

必要的分区的判断，就是根据 SQL 语句中的 where 条件，结合分区规则来实现的。如果查询语句的 where 条件中没有分区 key，那就只能访问所有分区了，即使使用业务分表的方式，where 条件中没有使用分表的 key，也必须访问所有的分表

##### MySQL 分区

###### Server 层分区（已弃用）

MyISAM 分区表使用的分区策略是通用分区策略（generic partitioning），每次访问分区都有 server 层控制。通过分区策略，是 MySQL 一开始支持分区表的时候就存在的代码，在文件管理，表管理的实现上很粗糙，因此有比较严重的性能问题

从 MySQL 5.7.9 开始，InnoDB 引擎引入了本地分区策略（native partitioning）。这个策略是在 `InnoDB` 内部自己管理打开分区的行为。

MySQL 5.7.17 开始，将 MyISAM 分区表标记为即将弃用。8.0 开始，不允许创建 `MyISAM` 分区表，只允许创建已经实现了本地分区策略的引擎（InnoDB 和 NDB ）

###### 分区支持

分区可以根据设置的规则在文件系统中分布各个表的各个部分。表的不同部分作为单独的表存储在不同的位置。用户选择的用来完成数据划分的规则为分区功能

支持的分区类型为水平分区，表的不同行可以分配给不同的物理分区。不支持垂直分区（表的不同列被分配给不同的物理分区）。

8.0 要创建分区表，必须使用支持它们的存储引擎。分区支持不是由 Server 层提供。由存储引擎或本机对分区处理程序提供。所有分区必须使用相同的存储引擎。8.0 支持分区的存储引擎是 InnoDB 和 NDB。分区不能与不支持分区的存储引擎一起使用。分区适用于表的所有数据和索引，不能仅对索引或数据进行分区，也不能仅对表的一部分进行分区。可以使用用于创建分区的语句子句 `DATA DIRECTORY` 和 `INDEX DIRECTORY` 选项，将每个分区的数据和索引分配给特定目录。

表的 `DATA DIRECTORY` 单个分区和子分区仅 InnoDB 支持。8.0.21 开始，InnoDB 必须在 `DATA DIRECTORY` 子句中指定目录

从 8.0.16 开始，对分区表进行插入、删除、更新时，二进制日志记录（仅使用基于行的日志记录时记录分区信息）有关分区及发生行事件的子分区（如果存在）的信息。即使涉及的表相同，也会为不同分区或子分区中进行的修改创建新的行事件，即如果事务涉及三个分区或子分区，则会生成三个行事件。

EXPLAIN 语句的 partitions 会显示使用了那些分区

###### 分区特点

*   每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。一个典型的报错情况是：如果一个分区表的分区很多，超过了 1000 个，而 MySQL 启动的时候，`open_files_limit` 参数使用的是默认值 1024，那么就会访问这个表的时候，由于需要打开所有文件，导致打开表文件的个数超过了上限而报错。

*   分区使在一个表中存储的数据比单个磁盘或文件系统分区中存储的数据更多，通过删除仅包含该数据的一个或多个分区，可以快速删除过期数据，也可以快速添加专门存储新数据的新分区

*   MySQL 支持显式分区选择查询，支持（SELECT、DELETE、INSERT、REPLACE、UPDATE、LOAD DATA、LOAD XML）与 JOIN 语句。NDB 提供自动分区选择，不支持显式分区选择

    ```mysql
    # 仅选择那些在分区行 p0 或 p1 其匹配的 WHERE 条件
    SELECT * FROM t PARTiTION (p0, p1) WHERE c > 5
    SELECT e.id AS 'Employee ID', CONCAT(e.fname, ' ', e.lname) AS Name,
           s.city AS City, d.name AS department
           FROM employees AS e
           JOIN stores PARTITION (p1) AS s ON e.store_id=s.id
           JOIN departments PARTITION (p0) AS d ON e.department_id=d.id
           ORDER BY e.lname
    DELETE FROM employees PARTITION (p0, p1)
    UPDATE employees PARTITION (p0) SET store_id = 2 WHERE fname = 'Jill'
    # REPLACE 和 INSERT 指定的分区如果不匹配会报错
    INSERT INTO employees PARTITION (p2) VALUES (20, 'Jan', 'Jones', 1, 3)
    REPLACE INTO employees PARTITION (p0) VALUES (20, 'Jan', 'Jones', 3, 2)
    ```

*   当 WHERE 条件减少到（*`partition_column`* = *`constant`*；*`partition_column`* IN (*`constant1`*, *`constant2`*, ..., *`constantN`*)）两种情况时，优化器会自动执行分区修剪（不扫描没有匹配值的分区）

    *   *`partition_column`* IN (*`constant1`*, *`constant2`*, ..., *`constantN`*)

        优化器为列表中的每个值评估分区表达式，创建匹配分区的列表，然后仅扫描此分区列表中的分区

    *   *`partition_column`* = *`constant`*

        优化器仅对给定值的分区表达式求值，确定那个分区包含该值，然后仅扫描该分区，`=` 可替换为 `<、>、<=、>=、<>`、某些 WHERE 子句的 BETWEEN 也可以进行分区修剪 

*   进行分区并不会禁止将 NULL 作为分区表达式的值，无论它是列值还是用户提供的表达式的值（即使允许 NULL也必须以其他方式产生整数表达式的值）。MySQL 的分区实现将 NULL 视为小于任何非 NULL 的值

    *   在 RANGE 分区下，NULL 值被放入最左边分区，如果删除这个分区，将删除包含 NULL 值的记录

    *   LIST 分区下要使用 NULL，必须显式定义那个分区存放 NULL 值

        ```mysql
        # 可以单独指导 NULL 或在 LIST 中添加 NULL 元素
        VALUES IN (NULL)
        # 或
        VALUES IN (1, 4, 8, NULL)
        ```

    *   HASH 和 KEY 对于 NULL 值的记录返回为 0

* 不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引可以是允许 NULL 值的，并且分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。
* 一个分区会生成一个 `.ibd` 文件，分区表包含一个 `.frm` 文件（8.0 废除）和分区数量的 `.idb` 文件（命名规则为：`{table}#p{partition_name}.ibd`）（分区对 Server 层透明，即对 Server 层来说是一个表，对引擎层来说是多个表）
* MySQL 第一次打开分区表时需要访问所有分区，所有分区共用一个元数据锁
* 对于 InnoDB 分区表，查询 INFORMATION_SCHEMA.PARTITION 中 TABLE_ROWS 的列统计数为估计值 
* 分区表达式中不允许，存储过程、存储函数、UDF、插件，声明的变量和用户变量
* 用户定义的分区表在创建时不会保留有效的 SQL 模式，创建分区表后更改 SQL 模式可能导致分区表行为改变，造成数据损坏或丢失（建议不要在创建分区表后更改服务器 SQL 模式）
* 不使用 NDB 引擎的表，最大分区数 8192，包含子分区；分区的 InnoDB 表不支持外键（不支持外键或其他表外键引用到分区表）；不支持 FULLTEXT 索引或搜索。具有空间数据类型（POINT、GEOMETRY）的列不能在分区表中使用；临时表无法分区；无法对日志表进行分区。

##### 分区类型

8.0 可用的分区类型

```mysql
# 分区操作，修改分区类型
ALTER TABLE members
    PARTITION BY HASH( YEAR(dob) )
    PARTITIONS 8;
```

###### RANGE

根据列值在给定范围内将行分配给分区。按范围分区的表分区方式是，每个分区都包含行，分区表达式的值在给定范围内。范围应该是连续的，但不能重叠，并且是使用 `VALUES LESS THAN` 运算符定义的。

```mysql
# MAXVALUE 表示一个始终大于最大可能的 RANGE 值，如果插入一个不存在分区的值会报错
# 可以使用函数根据列 RANGE 值对表进行分区
CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
# 修改分区（新增和删除分区不支持 IF [NOT] EXISTS）
CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999)
);
# 查询 INFORMATION_SCHEMA 下 PARTITIONS 表查看分区信息
SELECT * FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA='{name}' AND TABLE_NAME='{name}'
# 新增分区
ALTER TABLE t1 ADD PARTITION （PARTITION p3 VALUES LESS THAN (2002));
# 删除分区（DROP PARTITION 不适用于使用 NDB 的存储引擎表，可以删除一个或多个 RANGE 或 LIST 分区，但不能用于 HASH 和 KEY 分区）会删除分区对应的 ibd 文件
ALTER TABLE t1 DROP PARTITION p0, p1;
# 等价
DELETE FROM t1 WHERE (year_col >= 1991 AND year_col < 1995) OR (year_col >= 1995 AND year_col < 1999);
```

对于 RANGE 分区的查询，优化器只能对 `YEAR()`，`TO_DAYS()`，`TO_SECONDS()`，`UNIX_TIMESTAMP()` 这类函数进行优化选择。

对于按范围进行分区的表，ADD PRATITION 只能将新分区添加到分区列表的高端，无法在现有分区之间或之前添加新分区。可以使用 `REORGANIZE PARTITION`（不能更改表使用的分区类型和分区表达式或列）来拆分和合并（相邻的分区，不支持跨范围合并）分区

```mysql
# t_name 分区表名，partition_list 一个或多个要更改的分区名，以逗号分隔，partition_definitions 新分区定义
ALTER TABLE {t_name}
    REORGANIZE PARTITION {partition_list}
    INTO (partition_definitions);
# 将 p1 分区重组为 n0、n1 分区，且将 p1 分区数据按规则插入到新分区
ALTER TABLE members
    REORGANIZE PARTITION p1 INTO (
        PARTITION n0 VALUES LESS THAN (1992),
        PARTITION n1 VALUES LESS THAN (1995)
);
# 合并分区数据到新分区, so, s1 数据到 p0 分区
ALTER TABLE members REORGANIZE PARTITION s0, s1 INTO (PARTITION p0 VALUES LESS THAN (1970));	
```

###### LIST

类似 RANGE 分区，必须明确定义每个分区。区别在于，在列表分区中，每个分区都是基于一组值列表中的一个而不是一组连续范围中的列值的成员来定义和选择的。通过使用 `PARTITION BY LIST(expr)` （expr 是列值或基于列值的表达式）并返回整数值，然后通过使用 `VALUES in (value_list)` （value_list 是一个以逗号分隔的整数值）定义每个分区来来完成操作

LIST 分区不需要以任何特定的顺序声明

```mysql
# 不支持 MAXVALUE，必须显示定义所有集合值，如果插入值找不到匹配分区会报错
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
# 可以使用 IGNORE 关键字忽略不匹配分区错误，会忽略不匹配值，匹配的值会被插入
CREATE TABLE h2(c1 INT, c2 INT) PARTITION BY LIST(c1) (PARTITION p0 VALUES IN (1, 4, 7), PARTITION p1 VALUES IN (2, 5, 8));
INSERT IGNORE INTO h2 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9); # 插入 3 条数据
```

添加新分区时，不能添加包含现有分区的值列表中包含的任何值到新分区

###### COLUMNS

columns 分区可是 RANGE 和 LIST 的辩题。可以在分区中使用多个列。支持使用非整型列来定义值的范围或列表成员。允许的数据类型：所有的整数类型（TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT）与 RANGE 和 LIST 分区相同，其他数字类型不支持作为分区列；DATA 和 DATETIME（其他时间类型不支持）；字符串（CHAR、VARCHAR、BINARY、VARBINARY）其他字符串类型（TEXT、BLOB）不支持

*   RANGE COLUMNS

    能够基于多个列值使用范围来定义分区，不接受表达式，仅接受列名，接受一个或多个列的列表

    ```mysql
    CREATE TABLE table_name
    PARTITIONED BY RANGE COLUMNS(column_list) (
        PARTITION partition_name VALUES LESS THAN (value_list)[,
        PARTITION partition_name VALUES LESS THAN (value_list)][,
        ...]
    )
    # 一个或多个列的列表
    column_list:
        column_name[, column_name][, ...]
    # 值的列表，值与列数目类型及顺序必须相匹配
    value_list:
        value[, value][, ...]
    CREATE TABLE rcx (a INT, b INT, c CHAR(3), d INT)
    PARTITION BY RANGE COLUMNS(a, b, c) (
    		PARTITION p0 VALUES LESS THAN (5, 10, 'ggg'),
      	PARTITION p1 VALUES LESS THAN (10, 20, 'mmm'),
      	PARTITION p2 VALUES LESS THAN (15, 30, 'sss'),
      	PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE, MAXVALUE)
    )
    ```

    RANGE 分区比较列值，而 COLUMNS RANGE 比较一组值，有时可能会将分区列表的第一个元素的值等于 VALUES LESS THAN 值列表的第一个元素的值的行放置在相应的分区中，使用单个列的作为 COLUMNS RANGE 时与 RANGE  时一致（不会将值插入等于的分区）

    使用字符串列作为分区列时，使用的字符集和排序规则可能会影响给定行存储的分区，修改字符集或排序规则后，可能导致分区变化。

*   LIST COLUMNS

    8.0 提供了对 LIST COLUMNS 分区的支持，允许讲多个列作为分区键，可以讲整数类型外的数据类型的列作为分区列

    ```mysql
    CREATE TABLE customers_1 (
        first_name VARCHAR(25),
        last_name VARCHAR(25),
        street_1 VARCHAR(30),
        street_2 VARCHAR(30),
        city VARCHAR(15),
        renewal DATE
    )
    PARTITION BY LIST COLUMNS(city) (
        PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Högsby', 'Mönsterås'),
        PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Västervik'),
        PARTITION pRegion_3 VALUES IN('Nässjö', 'Eksjö', 'Vetlanda'),
        PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Växjo')
    );
    ```

###### HASH

HASH 分区目的是将数据均匀地分布到预先定义的各个分区中，保证分区的数据量大致相等。创建 HASH 分区，必须在 CREATE 语句后附加一个子句（返回整数的表达式）`PARTITION BY HASH(expr)` 需要添加一个 `PARTITIONS {num}` 子句确定分区数量，不添加则分区数量默认为 1.

```mysql
# 创建 hash 分区，分区按日期列 b，分区数为 4
CREATE TABLE th(a INT, b DATETIME) PARTITION BY HASH (YEAR(b)) PARTITIONS 4;
```

即使使用自增主键做 hash 分区也不能保证分区数据的均匀，插入的自增 ID 并非总是连续的

*   LINEAR HASH

    线性哈希分区，使用线性二乘幂算法来确定新行插入到已经分区的表中的位置。语法与 hash 类型，除了将 hash 改成 linear hash，优势在于，分区的添加、删除、合并、拆分更快，适合处理含有大量数据的表，缺点，分布不如 hash 分区均衡

    ```mysql
    CREATE TABLE employees (
        id INT NOT NULL,
        fname VARCHAR(30),
        lname VARCHAR(30),
        hired DATE NOT NULL DEFAULT '1970-01-01',
        separated DATE NOT NULL DEFAULT '9999-12-31',
        job_code INT,
        store_id INT
    )
    PARTITION BY LINEAR HASH( YEAR(hired) )
    PARTITIONS 4;
    ```

###### KEY

类似 HASH 分区，区别在于 HASH 分区使用用户自定义表达式，键分区的哈希函数由 MySQL 服务器提供。NDB 使用 md5，其他引擎使用其内部哈希功能，语法与 HASH 语法类似

KEY 只接受零个或多个列名的列表。如果表有一个主键，则用作分区键的任何列都必须包含表的主键的一部分或全部。如果没有讲列名指定为分区键，则使用表的主键（如果存在），如果没有主键，但存在唯一键，将使用唯一键作为分区键（唯一键列必须定义为 NOT NULL，否则会失败）。

对于键分区表，无法执行 `ALTER TABLE DROP PRIMARY KEY`，会产生错误（ERROR 1466）。

```mysql
CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;
# 支持线性 KEY 分区
CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;
```

###### 子分区

是在分区的基础上再进行分区，允许在 RANGE 和 LIST 分区上再进行 HASH 和 KEY 的子分区

```mysql
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );
# 等价
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );
```

*   每个分区必须具有相同数量的子分区，子分区的名称在整个表中必须唯一
*   如果在分区表的任何分区上使用 SBUPARTITION 显式定义子分区，则必须显式定义所有分区
*   每个 SUBPARTITION 子句必须包含子分区的名称
*   子分区必须使用 HASH 或 KEY 分区，只有 RANGE 和 LIST 分区可以再分区。HASH 和 KEY 分区不能再分区

##### 分区管理

###### 分区维护

分区表的维护可以实现 CHECK TABLE、OPTIMIZE TABLE、ANALYZE TABLE、REPAIR TABLE 效果，可以使用 ALL 指代所有分区

*   重建分区：删除存储在分区中的所有记录，然后重新插入它们，适用于碎片整理

    ```mysql
    ALTER TABLE {t_name} REBUILD PARTITION {partition_list}
    ```

*   优化分区：如果分区删除了大量的行或进行了很多修改，可以回收任何未使用的空间和整理分区文件

    ```mysql
    # 等价于在给定分区执行 CHECK、ANALYZE、REPAIR
    ALTER TABLE {t_name} OPTIMIZE PARTITION {partition_list}
    ```

    模型引擎（包括 InnoDB）不支持按分区优化，此时会分析并重建整个表，并发出警告

*   分析分区：读取并存储分区的 key 分布

    ```mysql
    ALTER TABLE {t_name} ANALYZE PARTITION {partition_list}
    ```

*   修复分区：修复损坏的分区

    ```mysql
    # 当分区包含重复键错误时失败，使用 ALTER IGNORE TABLE 选项，此时存在重复键而无法移动的所有行将从分区删除
    ALTER TABLE {t_name} REPAIR PARTITION {partition_list}
    ```

*   检查分区：检查分区表中错误（数据或索引是否损坏）

    ```mysql
    # 当分区包含重复的键错误时失败，使用 ALTER IGNORE TABLE 选项，此时，返回发现重复键冲突的分区中每一行内容
    ALTER TABLE {t_name} CHECK PARTITION {partition_list}
    ```

*   截断分区：删除分区所有数据，但不删除分区

    ```mysql
    ALTER TABLE {t_name} TRUNCATE PARTITION {partition_list}
    ```

###### 新增删除分区

*   移除全部分区

    ```mysql
    ALTER TABLE {table} REMOVE PARTITIONING;
    ```

*   RANGE 和 LIST 分区操作

    对于按范围进行分区的表，ADD PRATITION 只能将新分区添加到分区列表的高端，无法在现有分区之间或之前添加新分区。

    可以使用 `REORGANIZE PARTITION`（不能更改表使用的分区类型和分区表达式或列）来拆分和合并（相邻的分区，不支持跨范围合并）分区，会导致分区被重建

    ```mysql
    # t_name 分区表名，partition_list 一个或多个要更改的分区名，以逗号分隔，partition_definitions 新分区定义
    ALTER TABLE {t_name}
        REORGANIZE PARTITION {partition_list}
        INTO (partition_definitions);
    # 将 p1 分区重组为 n0、n1 分区，且将 p1 分区数据按规则插入到新分区
    ALTER TABLE members
        REORGANIZE PARTITION p1 INTO (
            PARTITION n0 VALUES LESS THAN (1992),
            PARTITION n1 VALUES LESS THAN (1995)
    );
    # 合并分区数据到新分区, so, s1 数据到 p0 分区
    ALTER TABLE members REORGANIZE PARTITION s0, s1 INTO (PARTITION p0 VALUES LESS THAN (1970));
    # 拆分及合并 LIST 分区
    ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
    ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
        PARTITION p1 VALUES IN (6, 18),
        PARTITION np VALUES in (4, 8, 12)
    );
    ```

*   HASH 和 KEY 分区操作（包含 LINEAR HASH、LINEAR KEY）

    ```mysql
    # 缩小分区，删除比表中更大的分区将导致错误
    ALTER TABLE {t_name} COALESCE PARTITION {num};
    # 增加分区
    ALTER TABLE {t_name} ADD PARTITION PARTITIONS {num};
    ```

###### 分区交换数据

将分区或子分区中的数据与另一个非分区的表中的数据进行交换。如果非分区表中的数据为空，那么相当于将分区中的数据移动到非分区中，若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。

```mysql
# pt 分区表名，p 分区或子分区名，nt 要交换数据的普通未分区表
ALTER TABLE {pt} EXCHANGE PARTITION {p} WITH TABLE {nt}
# 如果交换的普通表的数据与分区不匹配会报错，使用 WITHOUT VALIDATION 取消验证
ALTER TABLE {pt} EXCHANGE PARTITION {p} WITH TABLE {nt} WITHOUT VALIDATION；
```

分区数据语法前置条件：

*   nt 不是临时表和分区表
*   pt 和 nt 结构相同（以严格方式比较：数目、顺序、名称、列、索引、类型、引擎必须完全匹配，可以使用 like 创建）
*   nt 不能有外键，或其他表含有对该表的外键引用
*   对于 InnoDB 表，两个表使用相同的行格式。
*   nt 没有使用该 DATA DIRECTORY 选项的任何分区，8.0.14 开始取消该限制，需要 ALTER、INSERT、CREATE、DROP 权限

执行过程中：不会触发 pt 和 nt 的触发器、AUTO_INCREMENT 列都将被重置、与 IGNORE 关键字使用时，关键字无效、一次只能一个分区或子分区进行交换，需要交换多个分区需要执行多次该语句。

与分区交换（分区数据交换到表）的表不一定必须为空，此时会互相交换分区表与普通表的数据。如果表的分区是子分区，只能与未分区的表交换表的子分区，而不是整个分区

#### 临时表

某些情况下，服务器在处理语句时会创建内部临时表。临时表仅在当前会话中可见，并且在关闭会话时会自动删除。两个不同的会话可以使用相同的临时表名，或单个会话中可以创建与普通表名称相同的临时表（临时表删除前，普通表会一直处于隐藏状态）

临时表与数据关联不紧密，删除数据库并不会删除在数据库上创建的临时表，依然可以对其进行更新（使用 `{deleted_db_name}.{temporary_table_name}` 引用）

##### 创建

需要 `CREATE TEMPORARY TABLES` 权限。创建临时表后，对临时表的操作不会检查权限。

适用 TEMPORARY 关键字创建临时表（但不能使用 like 基于普通表创建临时表，但支持基于普通表的查询结果创建临时表）。InnoDB 不支持压缩临时表，在 `innodb_strict_mode` 启用（默认）情况下，指定临时表的 `ROW_FORMAT=COMPRESSED` 或 `KEY_BLOCK_SIZE={num}` 会报错。如果禁用该选项，会发出警告，并使用非压缩格式创建临时表。

###### 临时表限制

*   使用临时表处理结果中包含 BLOB 和 TEXT 列时，会导致服务器使用磁盘临时表