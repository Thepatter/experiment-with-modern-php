##浏览器发起请求到服务器响应的流程与生命周期（或者说这个流程中，服务端与客户端各做了哪些工作）
####技术约定：
* 现代客户端与服务端架构一般分为 B/S（浏览器对服务器），和 C/S（IOS 或 Android 编写的 APP 与服务器）。今天讨论 B/S 架构
* 现代大型网络与服务的服务端一般是分布式架构，由多语言，多服务，多网关，多代理，多数据源等协同工作。今天讨论单体架构（即请求直接由服务器调用 php 处理，无代理，无网关，无多语言协作等情况）
* 以 tcp/ip 常用的四层通讯分层（应用层，传输层，网络层，数据链路层）协议代替 RFC 标准的七层（应用层，表示层，会话层，传输层，网络层，数据链路层，物理层）协议来描述通讯过程
* 不讨论底层的二进制编码，及系统级内核调用，及系统级进程/线程的切换。
####环境约定：
* 假定客户端使用 802.3 的以太网连接网络
* 假定客户端使用谷歌的 chrome 浏览器
* 以 IPV4 网络标准为工作标准
* 服务端以 CGI 架构下的两种常用 PHP 架构：LNMP 和 LAMP，来讨论，不讨论 java 的 servlet 架构
* 不发生不响应，无法连接的事件，服务端 Apache 或 Nginx 和 PHP-FPM 已启动服务，
####客户端发起请求：
* 客户在地址栏输入地址:以客户要请求 `www.yuzhua.com` 为例。当客户在浏览器地址栏输入框中输入第一个字符 `w` 开始，浏览器后台就会自动开始匹配客户端本机的浏览记录和书签中相匹配的地址记录并做出内容提示（如果本机曾有过存书签和访问历史记录那么不用输入完成就会正确匹配，访问次数越多，匹配更准确）
* 浏览器发起 DNS 请求，获取地址对应的 IP 地址。根据地址获取对应的 IP 地址，会依次在本地路由缓存表->本地 host 文件->域 DNS 服务器->根 DNS 服务器查找。获取 IP 地址后，将 IP 地址缓存到本地路由表
* 发送 ARP 广播获取 IP 地址对应的 MAC 地址。这里分为同一网段和不同一网段的解析：
    
    **同一网段:**
        
    1:会先查看自己的 ARP 缓存表里是否有 `www.yuzhua.com` 对应 IP 地址的 MAC 地址。
    
    2:如果客户端在本地 ARP 表中找不到服务端对应的 MAC 地址，则以广播方式（目的 MAC 地址为广播地址，任意网段的节点都可以接受到）发送一个 ARP 请求报文。ARP 请求报文中的发送端（源）IP 地址和发送端 MAC 地址分别为客户端的 IP 地址和 MAC 地址，目的 IP 地址和目的 MAC 地址为服务端的 IP 地址和全 0 的MAC地址。因为 ARP 请求报文是以广播方式发送，所以该网段上的所有主机都可以接收到该请求包，但只有其 IP 地址与目的 IP 地址一致的服务端才会对该请求进行处理
    
    3:服务端将 ARP 请求报文中的发送端的 IP 地址和 MAC 地址存入自己的 ARP 表中。然后以单播方式向客户端发送一个 ARP 响应，包含了自己的 MAC 地址。
    
    4:客户端收到来自服务端 ARP 响应之后，将服务端的 MAC 地址加入到自己的 ARP 缓存表中
    
    **不同网段:**
    
    1:如果客户端不知道网关的 MAC 地址（也就是客户端的 ARP 表中没有网关对应的 MAC 地址表项），则客户端先在本网段中发出一个 ARP 请求广播，ARP 请求报文中的目的 IP 地址为网关的 IP 地址，代表其目的就是想获得网关的 MAC 地址。如果客户端已经知道网关的 MAC 地址，则略过此步。
    
    2:网关收到 ARP 广播包后同样会向客户端发回一个 ARP 应答包。当客户端收到的应答包后获得网关的 MAC 地址后。在向服务端发送的原报文的目的 MAC 地址字段填上网关的 MAC 地址后发给网关。
    
    3:如果网关的 ARP 表中已有服务端对应的 MAC 地址，则网关直接将在来自客户端的报文中的目的 MAC 地址字段填上服务端的 MAC 地址后响应给客户端
    
    4:如果网关 ARP 表中没有服务端的 MAC 地址，网关会再次向服务端所在的网段发送 ARP 广播请求，此时目的 IP 地址为服务器的 IP 地址，当网关从收到来自服务器的应答报文后获得服务器的 MAC 地址后，就可以将客户端发来的报文重新再目的 MAC 地址字段填上服务端的 MAC 地址后响应给客户端
    
    5:客户端收到来自服务端 ARP 响应之后，将服务端的 MAC 地址加入到自己的 ARP 缓存表中
* 客户端封装请求：
    
    1: 应用层封装: 头为 http,内容为请求报文，然后将封包传递给传输层
    
    2: 传输层封装: 头部为 tcp 协议代码等描述信息和目标端口号 80，本地端口号（随机获取空闲端口号），内容为上层包
    
    3: 网络层封装: 头部为目标 IP 地址和源 IP 地址等描述信息，内容为上层包
    
    4: 链路层封包打包成网络帧，根据服务端 MAC 地址，发送网络帧
####网络通信过程：（三次握手阶段）
SYN: synchronization(同步)，ACK: acknowledgement(确认:告知已收到)，FIN: finish(结束)
* 客户端端发送连接请求报文 SYN
* 服务端段接受连接后回复SYN + ACK报文，并为这次连接分配资源。
* 客户端端接收到 ACK 报文后也向服务端发送 ACK 报文，并分配资源，这次 TCP 连接就建立了.(现代 http1.1 协议支持 keep-alive 持久连接，允许一次 tcp 连接建立后发送多个 http 请求)
####服务端响应：
* 服务端接收网络帧后，排序并解包交给 IP 层处理
* IP 层确认头信息后，交给 tcp 层处理
* tcp 层确认头信息后，获取端口号为 80，将数据包交给监听 80 端口的 httpd 服务器进程处理。

**LAMP架构情况**

1:Apache 新开一个进程并调用 php-mod 模块将 PHP 解释器嵌入该进程来处理该次请求，生成响应给客户端

**LNMP架构情况**

1:Nginx 生成 CGI 参数，并调用一个 work 进程，nginx 的 work 进程调用 php-fpm 的 work 进程来处理该次请求

####请求响应事务完成断开连接
至此，一起典型的请求与响应事务已处理完毕，接下来是断开连接了。
* 客户端发送 FIN
* 服务端响应 ASK
* 服务端发送 FIN
* 客户端发送 ACK