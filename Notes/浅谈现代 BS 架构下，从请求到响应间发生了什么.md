###浅谈现代 `B/S` 架构下，从请求到响应间发生了什么

#### 技术前提：

* 客户端（`chrome`，及以太网（802.3) 连接)
* 服务端（类 `unix` 系统)，架构为 `linux nginx/apache mysql php` 
* 网络稳定，客户端与服务端不处于同一网络
* 不讨论硬件范畴

#### 客户端请求开始

以访问 `www.yuzhua.com` 为例：

当在客户端输入第一个字符开始：

浏览器会做如下工作：(并行)

* 检测当前浏览器工作模式（隐身模式（不会记录客户端行为)，正常模式）
* 根据输入的字符在书签，历史记录及本地搜索词库里进行匹配（这个算法很复杂，也很准确），然后给出填充建议，如果我们书签里有存该网址，及访问过，那么一般不需要输入完成就可以得到完整的填充建议。同时会进行是否是 `uri` 的匹配。匹配是 `uri` 则访问该网站，否的话则进行将输入字符作为关键字进行搜索

当地址输入完成，按下回车键后：

浏览器会做如下工作：(假定最近 10 分钟未访问过该域名)

* 将 `uri` 解析成 IP 地址：

  浏览器会查找本机 `hosts` 文件，进行匹配，看是否定义对应 `uri` 的 IP 地址，有则直接读取

  1.在已经假定最近 10 分钟未访问该域名，那么本地路由缓存表中不会有该 `uri` 对应 IP 地址的缓存。那么浏览器会请求本地域的域名服务器，（如果本地域服务器有该域名对应的 IP 地址记录，那么直接返回给客户端，如果没有， 本地域的域名服务器会访问根域名服务器，根域名服务器将对应 IP 地址记录返回给本地域的域名服务器，本地域的域名服务器将记录返回给客户端，客户端拿到该域名对应的 IP 地址记录后会缓存在本地路由缓存表中（时间为 10 min)

* 将 IP 地址解析为 `mac` 地址

  客户端会发一条 `arp` 广播到路由器上，前提已经讲了客户端与服务端不处于同一网络，那么该路由器上不会有该 IP 对应的 `mac` 地址的记录，该路由会转发该 `arp` 广播到下一个路由地址，下一个路由器查找本机是否有该 IP 对应的 `mac` 地址,有则响应该广播

* 封装请求数据（典型 4 层结构，应用，传输，网络及物理链路层)

  应用层封装，头部为 `http` 数据为 `uri` 指向的资源

  传输层封装, 头部为应用层头部加 `tcp` 协议头内容

  `tcp` 协议头包含：

  `源端口 目标端口 序号 确认号 首部长度 保留 标志位 窗口 校验和 紧急指针 选项 填充`

  序号：`seq` 序号，占 32 位，用来标识从 `tcp` 源端向目的端发送的字节流，发起方发送数据时对此进行标记

  确认序号：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，`Ack = Seq + 1`

  标志位：共六个，即 `URG, ACK, PSH, RST,SYN,FIN` 等

  `URG` 紧急指针有效

  `ACK` 确认序号有效

  `PSH` 接收方应该尽快将这个报文交给应用层

  `RST` 重置连接

  `SYN` 发起一个新连接

  `FIN` 释放一个连接

  网络层封装,头部为应用层头部加上 `ip` 协议头内容

  物理链路层，将上层数据封装打包成 `网络帧` 通过以太网发送

#### 网络请求及连接期间客户端服务端会进行三次握手

![](C:\Users\work\Documents\三次握手图.jpg)

简单来讲

* 第一次握手：`Client` 将标志位 `SYN` 置为 1， 随机产生一个值 `seq = x` , 并将该数据包发送给 `server`， `Client` 进入 `SYN_SENT`  状态，等待 `server` 确认
* 第二次握手：`server` 收到数据包后由标志位 `SYN = 1` 知道 `Client` 请求建立连接，`server` 将标志位 `SYN`和 `ACK` 都设置为 1， `ack numbern = x+1` ，随机产生一个 `seq=k` ，并将该数据包发送给 `client` 以确认连接请求，`server` 进入 `SYN_RCVD` 状态，（此时该 `fd` 进入 内核的 `blcklog` 队列，如果该队列已满，`server` 则会提示客户端稍后重试)
* 第三次握手：`client` 收到确认后，检查 `ack number` 是否为 `x+1` ，`ACK` 是否为 1，如果正确则将标志位 `ACK` 置为1，`ack=k+1` ，并将该数据包发送给 `server` , `server` 检查 `ack` 是否为 `k+1` ，`ACK` 是否为 1， 如果正确则连接建立成功，`client` 和 `server` 进入 `ESTANBISHED` 状态。（此时该 `fd` 进入内核的 `accept` 队列）

#### 服务端解析阶段

数据包全部发送到服务端后，服务端会进行数据包拼接服务端得到完整数据后会开始解析数据

* 服务端拼接（拼接的时候会进行排序）去掉链路层头之后向上传递到网络层

* 在网络层去掉网络层头部传递给传输层

* 在传输层去掉传输层头部传递到应用层

* 应用层得到端口后是 80 ，查找监听 80 端口的服务，`httpd 或 nginx` 

* 将数据 `uri` 资源的标识传递到 `http 或 nginx`

  `httpd` 解析流程如下：

   收到请求后，`fork` 一个新的进程处理该请求，（在该进程内嵌入 PHP 解释器),处理完成后将数据封装响应给客户端

  * PHP 随着 Apache 的启动而运行的；
  * 

  `nginx` 解析流程略复杂，但该机制是 `nginx` 高效的根本，`php-fpm` 与 `nginx` 工作流程比较相似

  * `nginx` 工作流程采用 `master` 进程管理子进程，子进程处理请求，`master` 进程通过检测共享内存，进程信号等来管理子进程。

  * `nginx` 在启动时候便会启动一定数量的子进程一般为 `CPU` 核心数量，当请求压力较大的时候，`master` 进程会 `frok` 新的子进程来处理请求，压力变小后会杀死新 `frok` 的进程

  * `nginx` 子进程收到请求后，会根据 `nginx.conf` 对应的配置来处理该请求:

    一般会有两个 `location` 块

    ```nginx
    location / {
        try_files $uri $uri/ /index.php?$query_string
    }
    ```

    该块意思是先将该 `uri` 当初一个文件来处理，如果没有则拼接成 `index.php?$query_string` 参数

    ```nginx
    location ~ \.php$ {
        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
        ...
    }
    ```

    该块定义了给 `fastcgi` 的相关参数，一般包含: 

    * 监听地址：`unix sock` 或 `tcp sock` 
    * `fastcgi` 参数
    * 缓冲区大小
    * 处理时间等

    `php-fpm` 处理流程基本与 `nginx` 一致

    `php-fpm` 子进程处理具体请求。

    `php` 处理流程大致如下：

     5.6 及以下

    * 模块初始化阶段
    * 请求初始化阶段
    * 执行 PHP 脚本阶段
    * 请求结束阶段
    * 模块关闭阶段

    7.0 及以上，加载 `php` 脚本后,会生成 `token` 树

  服务端封装并将数据发送到客户端

  #### 断开连接四次挥手

  ![https://i2.kknews.cc/SIG=312unbk/19qr000n1p4qp81nns4n.jpg](C:\Users\work\Documents\四次挥手.jpg)

  `tcp` 是全双工通信，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 `FIN` 来终止这一方向的连接，收到 一个 `FIN` 只是意味这一方向上没有数据流动了，即不会再收到数据，但是再这个 `TCP` 连接上，客户端仍然能发送数据，直到 client 也发送了 `FIN` 。

  第一次挥手：`client` 发送一个 `FIN` ，用来关闭 `client` 到 `server` 的数据传送，`client` 进入 `FIN_WAIT_1` 状态，将标志位 FIN 和 ACK 置为1，序号为 X，确认序号为 Z=1（主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文，但主动方仍可以接收数据报文）

  第二次挥手：`server` 收到 `FIN` 后，发回一个 `ACK` 给 `Client` ， `ACK` 标志位=1，确认序号为收到的序号加1，`ack=X+1`（被动方此时可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方我知道你想断开连接的请求了，这样主动方便不会因为没有收到应答而继续发送断开连接的请求，即FIN报文）

  第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态,将标志位FIN和ACK置为1，序号为Y，,确认序号为收到的序号加1，ack=X+1（被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待））；

  第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，发回ACK确认(标志位ACK=1),确认序号为收到的序号加1 ack=Y+1; （如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态）

  

  