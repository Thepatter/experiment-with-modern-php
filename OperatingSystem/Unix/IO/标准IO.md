### 标准 I/O

#### 标准IO库实现

不仅是 UNIX，很多其他操作系统都实现了标准 I/O 库，这个库由 ISO C 标准说明，SUS 对 ISO C 的标准进行了扩充，定义了另外一些接口

标准 I/O 库处理很多细节，如缓冲区分配、以优化的块长度进行 I/O 等。这些处理使用户不必担心如何选择使用正确的块长度，这使得它便与用户使用。

标准 I/O 库由 Dennis Ritchie 在 1975 年左右编写的，几乎没有对标准 I/O 库进行修改

标准 I/O 库最终都要调用文件 I/O 函数，每个标准 I/O 流都有一个与其相关联的文件描述符，可以对一个流调用 `fileno` 函数（POSIX.1）以获得其描述符

```c
// 返回与该流相关联的文件描述符
#include <stdio.h>
int fileno(FILE *fp)
```

如果要调用 `dup` 或 `fcntl` 等函数，则需要此函数

#### 流和 FILE 对象

对于文件 I/O 函数是围绕文件描述符的，当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的 I/O 操作。而对于标准 I/O 库，它们的操作是围绕流（stream) 进行的。当用标准 I/O 库打开或创建一个文件时，就已使一个流与一个文件相关联。

对于 ASCII 字符集，一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准 I/O 文件流可用于单字节或多字节字符集。流的定向（stream's orientation）决定了所读，写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。若在未定向的流上使用一个多字节 I/O 函数，则将该流定义设置为宽定向的。若在未定向的流上使用一个单字节 I/O 函数，则将该流的定向设为单字节定向的。

使用 `freopen` 函数清除一个流的定向；使用 `fwide` 函数设置流的定向

```c
#include <stdio.h>
#include <wchar.h>
// 返回值：若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流未定向，返回 0；
/**
 * params mode 为负，将试图使指定的流是字节定向的
 *             为正，将试图使指定的流是宽定向的
 *             为0，将不试图设置流的定向，但返回标识该流定向的值
 *
**/
int fwide(FILE *fd, int mode);
```

`fwide` 并不改变已定向流的定向。且无出错返回（在调用 `fwide` 前先清除 `errno` ，从 `fwide` 返回时检查 `errno` 的值）当打开一个流时，标准 I/O 函数 `fopen` 返回一个指向 FILE 对象的指针。该对象通常是一个结构，它包含了标准 I/O 库为管理该流需要的所有信息，包括用于实际 I/O 的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等。

应用程序没有必要检验 `FILE` 对象。为了引用一个流，需将 `FILE` 指针作为参数传递给每个标准 I/O 函数。 

#### 标准输入、输出和错误

对一个进程预定义了 3 个流，并且这 3 个流可以自动地被进程使用，它们是：标准输入、标准输出和标准错误。这些流引用的文件与文件描述符 `STDIN_FILENO`、`STDOUT_FILENO`、`STDERR_FILENO` 所引用的相同。

这 3 个标准 I/O 流通过预定义文件指针 `stdin`、`stdout` 和 `stderr` 加以引用。这 3 个文件指针定义在头文件`<stdio.h>` 中

#### 缓冲

标准 I/O 库提供缓冲的目的是尽可能减少使用 `read` 和 `write` 调用的次数。它也对每个 `I/O` 流自动地进行缓冲管理，标准 I/O 提供 3 种类型地缓冲

* **全缓冲：**在这种情况下，在填满标准 I/O 缓冲区后才进行实际 I/O 操作。对于驻留在磁盘上的文件通常是由标准 I/O 库实施全缓冲。在一个流上执行第一次 I/O 操作时，相关标准 I/O 函数通常调用 `malloc` 获得需使用的缓冲区

  **冲洗：**说明标准 I/O 缓冲区的写操作。缓冲区可由标准 I/O 例程自动地冲洗。或者可以调用函数 `fflush` 冲洗一个流。在标准 I/O 库方面，`flush`  意味着将缓冲区中的内容写到磁盘上（该缓冲区可能只是部分填满的），在终端驱动程序方面，`flush` 表示丢弃已存储在缓冲区中的数据

* **行缓冲:** 在这种情况下，当在输入和输出种遇到换行符时，标准 I/O 库执行 I/O 操作。这允许我们一次输出一个字符（用标准I/O 函数 `fputc`）但只有在写了一行之后才进行实际 I/O 操作。当流涉及一个终端时，通常使用行缓冲。

  行缓冲有两个限制。第一，因为标准 I/O 库用来收集每一行的缓冲区的长度是固定的，只要填满了缓冲区，即使还没有写一个换行符，也进行 I/O 操作。第二，任何时候只要通过标准 I/O 库要求从一个不带缓冲的流，或者一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流。

* **不带缓冲：**标准 I/O 库不对字符进行缓冲存储。

  标准错误流 `stderr` 通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个换行符。

ISOC 要求下列缓冲特征

* 当且仅当标准输入和标准输出并不指向交互式设备，它们才是全缓冲
* 标准错误决不会是全缓冲

很多系统默认使用下列类型的缓冲

* 标准错误是不带缓冲
* 若是指向终端设备的流，则是行缓冲的；否则是全缓冲的

使用以下函数来更改缓冲类型

```c
#include <stdio.h>
// 返回值：若成功，返回 0；若出错，返回非 0
void setbuf(FILE *restrict fp, char *restrict buf);
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
```

这些函数一定要在流已被打开后调用（因为每个函数都要求一个有效的文件指针作为它们的第一个参数），而且也应在对该流执行任何一个其他操作之前调用

可以使用 `setbuf` 函数打开或关闭缓冲机制。为了带缓冲进行 I/O，参数 `buf` 必须指向一个长度为 `BUFSIZ` 的缓冲区（该常量定义在 <stdio.h>中）。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲的。关闭缓冲，将 `buf` 设置为 NULL

使用 `setvbuf` ，可以精确地说明所需的缓冲类型。使用 `mode` 参数实现

`_IOFBF` 全缓冲，`_IOLBF` 行缓冲，`_IONBF` 不带缓冲。

如果指定一个不带缓冲的流，则忽略 `buf` 和 `size` 参数。如果指定全缓冲或行缓冲，则 `buf` 和 `size` 可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而 `buf` 是 NULL，则标准 I/O 库将自动地为该流分配适当长度的缓冲区（由常量 `BUFSIZ` 所指定的值）

*`setbuf`和`setvbuf`动作*

![](../Images/setbuf和setvbuf函数.png)

如果在一个函数内分配一个自动变量类的标准 I/O  缓冲区，则从该函数返回之前，必须关闭该流。另外，有些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于 `size` 。一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准 I/O 库将自动释放缓冲区。

任何时候，都可强制冲洗一个流

```c
#include <stdio.h>
// 返回值：若成功，返回 0；若出错，返回 EOF
int fflush(FIFL *fp);
```

此函数使该流所有未写的数据都被传送至内核。如果 `fp` 是 NULL，则此函数将导致所有输出流被冲洗

#### 打开流

使用下列 3 个函数打开一个标准 I/O 流

```c
#include <stdio.h>
// 3 个函数的返回值：若成功，返回文件指针；若出错，返回 null
FILE *fopen(const char *restict pathname, const char *restrict type);
FILE *freopen(const char *restict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
```

区别如下：

`fopen`  函数打开路径名为 `pathname` 的一个指定的文件

`freopen`  函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若该流已经定向，则使用 `freopen` 清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误

`fdopen` 函数取一个已有的文件描述符（从 `open`，`dup`，`dup2`，`fcntl`，`pipe`，`socket`，`socketpair` `accept` 函数得到此文件描述符），并使一个标准的 I/O 流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准 I/O 函数 `fopen` 打开，所以必须先调用设备专用函数以获得一个文件描述符，然后用 `fdopen` 使一个标准 I/O 流与该描述符相结合

*type 参数指定对该 I/O 流的读、写方式*

![](../Images/打开标准IO流的type参数.png)

使用字符 b 作为 `type` 的一部分，这使得标准 I/O 系统可以区分文本文件和二进制文件。因为 UNIX 内核并不对这两种文件进行区分，所以在 UNIX 系统环境下指定字符 b 作为 `type ` 的一部分上并无作用。

对于 `fdopen` ，`type` 参数的意义稍有区别。因为该描述符已经被打开，所以 `fdopen` 为写而打开并不截断该文件。（若该描述符原来是由 `open` 函数创建的，而且该文件已经存在，则其 `O_TRUNC` 标志将决定是否截断该文件。`fdopen` 函数不能截断它为写而打开的任一文件）标准 I/O 追加写方式也不能用于创建该文件（因为如果一个描述符引用一个文件，则该文件一定已经存在）

当用追加写类型打开一个文件后，每次写都将数据写的文件的当前尾端处。如果有多个进程用标准 I/O 追加写方式打开同一文件，那么来自每个进程的数据都将正确地写到文件中。

当以读和写类型打开一个文件时（`type` 中的 `+` 号），具有下列限制

* 如果中间没有 `fflush`，`fseek`，`fsetpos` 或 `rewind` ，则在输出的后面不能直接跟随输入
* 如果中间没有 `fseek`，`fsetops`，`rewind`，或一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出

*打开一个标准 I/O 流的 6 钟不同方式*

![](../Images/打开一个标准IO流的6种方式.png)

在指定 `w` 或 `a` 类型创建一个新文件时，无法设置该文件的权限位，POSIX.1 要求实现使用：`S_IRUSR |S_IWUSR ｜ S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH` 权限集创建文件。可调整 `umask`  值来限制这些权限

除非流引用终端设备，否则按系统默认，流被打开时是全缓冲的。若流引用终端设备，则该流是行缓冲的。一旦打开了流，那么在对流执行任何操作之前，如果希望，则可以使用 `setbuf` 和 `setvbuf` 改变缓冲的类型

使用 `fclose` 关闭一个打开的流

```c
#include <stdio.h>
// 返回值：若成功，返回 0；若出错，返回 EOF
int fclose(FILE *fp);
```

在该文件被关闭之前，冲洗缓冲中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准 I/O 库已经为该流自动分配了一个缓冲区，则释放此缓冲区

当一个进程正常终止时（直接调用 `exit` 函数，或从 `main` 函数返回），则所有带未写缓冲数据的标准 I/O 流都被冲洗，所有打开的标准 I/O 流都被关闭

#### 读和写流

一旦打开了流，则可在 3 种不同类型的非格式化 I/O 中进行选择，对其进行读，写操作

1. 每次一个字符的 I/O。一次读或写一个字符，如果流是带缓冲的，则标准 I/O 函数处理所有缓冲
2. 每次一行的 I/O。如果想要一次读或写一行，则使用 `fgets` 和 `fputs` 每行都以一个换行符终止。当调用 `fgets` 时，应说明能处理的最大行长。
3. 直接 I/O 。`fread` 和 `fwrite` 函数支持这种类型的 I/O。每次 I/O 操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。也被称为（二进制I/O、一次一个对象I/O、面向记录或面向结构I/O）

##### 输入函数

以下 3 个函数可用于一次读一个字符

```c
#include <stdio.h>
// 3 个函数返回值：若成功，返回下一个字符；若已到达文件尾端或出错，返回 EOF
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
```

函数 `getchar` 等同于 `getc(stdin)` 前两个函数的区别是，`getc` 可被实现为宏，而 `fgetc` 不能实现为宏：

1. `getc` 的参数不应当是具有副作用的表达式，因为它可能会被计算多次
2. 因为 `fgetc` 一定是个函数，所以可以得到其地址。这就允许将 `fgetc` 的地址作为一个参数传送给另一个函数
3. 调用 `fgetc` 所需时间很可能比调用 `getc` 要长，因为调用函数所需要的时间通常长于调用宏

这 3 个函数在返回下一个字符时，将其 `unsigned char` 类型转换为 `int` 类型（采用无符号的理由，如果最高位为 1 也不会使返回值为负，要求整型返回值的理由是，这样就可以返回所有可能的字符值再加上一个已出错或已到达文件尾端的指示值。在 `<stdio.h>` 中的常量 `EOF` 被要求是一个负值，其值经常是 -1。这就意味着不能将这 3 个函数的返回值存放在一个字符变量中，以后还要将这些函数的返回值与常量 `EOF` 比较）

不管是出错还是到达文件尾端，这 3 个函数都返回同样的值。为了区分这两种不同的情况，必须调用 `ferror` 或 `feof`

```c
#include <stdio.h>
// 两个函数返回值：若条件为真，返回非 0（真）；否则，返回 0（假）
int ferror(FILE *fp);
int feof(FILE *fp);
void clearerr(FILE *fp);
```

在大多数实现中，为每个流在 `FILE` 对象中维护了两个标志

* 出错标志

* 文件结束标志

调用 `clearerr`  可以清除这两个标志

从流中读取数据以后，可以调用 `ungetc` 将字符再压送回流中（用 `ungetc` 压送回字符时，并没有将它们写到底层文件中或设备上，只是将它们写回标准 I/O 库的流缓冲区中）

```c
#include <stdio.h>
// 返回值：若成功，返回 c;若出错，返回 EOF
int ungetc(int c, FILE *fp);
```

压送回到流中的字符以后又可从流中读出，但读出字符的顺序与压送回的顺序相反。回送的字符，不一定必须是上一次读到的字符。不能回送 `EOF`。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再读则返回 `EOF`（一次成功的 `ungetc` 调用会清除该流的文件结束标志）。

当正在读一个输入流，并进行某种形式的切词或记号切分操作时，会经常用到回送字符操作。有时需要先看一看下一个字符，以决定如果处理当前字符。然后就需要方便地将刚查看的字符回送，以便下一次调用 `getc` 时返回该字符。如果标准 I/O 库不提供回送能力，就需将该字符存放到一个我们自己的变量中，并设置一个标志以便判别在下一次需要一个字符时是调用 `getc`，还是从我们自己的变量中取用这个字符。

##### 输出函数

对应于每个输入函数都有一个输出函数

```c
#include <stdio.h>
int putc(int c, FILE *fd);
int fputc(int c, FILE *fp);
int putchar(int c);
```

与输入函数一样，`putchar(c)` 等同于 `putc(c, stdout)`，`putc` 可被实现为宏，而 `fputc` 不能实现为宏。

#### 每次一行 I/O

下面两个函数提供每次输入一行的功能

```c
#include <stdio.h>
// 两个函数返回值：若成功，返回 buf;若已到达文件尾端或出错，返回 null
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);
```

这两个函数都指定了缓冲区的地址，读入的行将送入其中。`gets` 从标准输入读，而 `fgets` 则从指定的流读

对于 `fgets`，必须指定缓冲区的长度 n。此函数一直读到下一个换行符为止，但是不超过 `n -1` 个字符，读入的字符被送入缓冲区。该缓冲区以 `null` 字节结尾。如若该行包括最后一个换行符的字符数超过`n-1`，则 `fgets` 只返回一个不完整的行，但是，缓冲区总是以 `null` 字节结尾。对 `fgets` 的下一次调用会继续读该行

`gets` 是一个不推荐使用的函数。其问题是调用者在使用 `gets` 时不能指定缓冲区的长度。这样就可能造成缓冲区溢出（如若该行长于缓冲区长度），写到缓冲区之后的存储空间中，从而产生不可预料的后果。（`gets` 并不将换行符存入缓冲区中）

`fputs` 和 `puts` 提供每次输出一行的功能

```c
#include <stdio.h>
// 两个函数的返回值：若成功，返回非负值；若出错，返回 EOF
int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
```

函数 `fputs` 将一个以 `null` 字节终止的字符串写到指定的流，尾端的终止符 `null` 不写出。并不一定是每次输出一行，因为字符串不需要换行符作为最后一个非 `null` 字节。通常，在 `null` 字节之前是一个换行符，但并不要求总是如此。

`puts` 将一个以 `null` 字节终止的字符串写到标准输出，终止符不写出。但是 `puts` 随后又将一个换行符写到标准输出

`puts` 并不像它所对应的 `gets` 那样不安全。但是还是应该避免使用它，以免需要记住它在最后是否添加了一个换行符。如果总是使用 `fgets` 和 `fputs` ，那么必须在每行终止处自己处理换行符。

#### 二进制 I/O

如果使用 `getc` 或 `putc` 读、写一个结构，那么必须循环通过整个结构，每次循环处理一个字节，一次读或写一个字节，这会非常麻烦其费时。如果使用 `fputs` 和 `fgets	` 那么因为 `fputs` 在遇到 `null` 字节时就停止，而在结构中可能含有 `null` 字节，所以不能使用它实现读结构的要求。如果输入数据中包含 `null` 字节或换行符，则 `fgets` 也不能正确工作。

下列函数以执行二进制 I/O 操作

```c
#include <stdio.h>
// 两个函数的返回值：读或写的对象数
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
```

这些函数有以下两种常见的用法

1. 读或写一个二进制数组。其中 `size` 为每个数组元素的长度，`nobj` 为欲写的元素个数
2. 读或写一个结构。其中指定 `size` 为结构的长度，`nobj` 为要写的对象个数

`fread` 和 `fwrite` 返回读或写的对象数。对于读，如果出错或到达文件尾端，则此数字可以少于 `nobj`。在这种情况，应调用 `ferror` 或 `feof` 以判断究竟是哪一种情况。对于写，如果返回值少于所要求的 `nobj`，则出错。

使用二进制 I/O 的基本问题是，它只能用于读在同一系统上已写的数据。现在，很多异构系统通过网络互连，常常需要在一个系统上写的数据，要在另一个系统上进行处理，在这种环境下，这两个函数可能就不能正常工作，其原因是：

* 在一个结构中，同一成员的偏移量可能随编译程序和系统的不同而不同（由于不同的对齐要求）；或者准确对齐，这意味着即使在同一个系统上，一个结构的二进制存放方式也可能因编译程序选项的不同而不同
* 用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同

#### 定位流

有 3 种方法定位标准 I/O 流

1. `ftell` 和 `fseek` 函数。这两个函数假定文件的位置可以存放在一个长整型中
2. `ftello` 和 `fseeko` 函数。SUS 引入，使用 `off_t` 数据类型代替了长整型
3. `fgetpos` 和 `fsetpos` 函数。ISO C 引入，使用一个抽象数据类型 `fpos_t` 记录文件的位置。这种数据类型可以根据需要定义为一个足够大的数，用以记录文件位置

```c
#include <stdio.h>
// 返回值：若成功，返回当前文件位置指示；若出错，返回 -1L
long ftell(FILE *fp);
// 返回值：若成功，返回 0；若出错，返回 -1
int fseek(FILE *fp, long offset, int whence);
//使用 rewind 函数可将一个流设置到文件的起始位置
void rewind(FILE *fp);
```

对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位的。`ftell` 用于二进制文件时，其返回值就是这种字节位置。使用 `fseek` 定位一个二进制文件，必须指定一个字节 `offset`，以及解释这种偏移量的方式。`whence` 的值与 `lseek` 函数的相同：`SEEK_SET` 表示从文件的起始位置开始，`SEEK_CUR`，`SEEK_END` 表示从文件的尾端开始。

对于文本文件，`whence` 一定要是 `SEEK_SET` ，而且 `offset` 只能有两种值：0（后退到文件的起始位置），或是对该文件的 `ftell` 所返回的值。

除了偏移量的类型是 `off_t` 而非 `long` 以外，`ftello` 函数与 `ftell` 相同，`fseeko` 函数与 `fseek` 相同

```c
#include <stdio.h>
// 返回值：若成功，返回当前文件位置；若出错，返回 off_t -1
off_t ftello(FILE *fp);
// 返回值：若成功，返回 0；若出错，返回 -1
int fseeko(FILE *fp, off_t offset, int whence);
```

`fgetpos` 将文件位置指示器的当前值存入由 `pos` 指向的对象中。在以后调用 `fsetpos` 时，可以使用此值将流重新定位至该位置

```c
#include <stdio.h>
// 两个函数返回值：若成功，返回 0；若出错，返回非 0
int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
int fsetpost(FILE *fp, const fpos_t *pos);
```

#### 格式化 I/O

##### 格式化输出

格式化输出由以下 printf 函数来处理

```c
#include <stdio.h>
// 以下 3 函数成功返回输出字符数，出错，返回负值
// 将格式化数据到标准输出
int printf(const char *restrict format, ...);
// 写至指定的流
int fprintf(FILE *restrict fp, const char *restrict format, ...);
// 写至指定的文件描述符
int dprintf(int fd, const char *restrict format, ...);
// 返回值，若成功，返回存入数组的字符数，若编码出错，返回负值
// 将格式化的字符串送入数组 buf，在该数组的尾端自动加一个 null 字节，但该字符不包括在返回值中，可能造成buf的缓冲区溢出
int sprintf(char *restrict buf, const char *restrict format, ...);
// 返回值，若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值
// 同 sprintf ，只是缓冲区长度是一个显示参数，超过缓冲区尾端写的所有字符都被丢弃
int snprintf(char *restrict buf, size_t n, const char *restrict format,...)
```

##### 格式化输入

执行格式化输入处理的是 3 个 scanf 函数

```c
#include <stdio.h>
// 三个函数返回值：负值的输入项数，若输入出错或在任一转换前已到达文件尾端，返回 EOF
int scanf(const char *restrict format,...);
int fscanf(FILE *restrict fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);
```

scanf 族用于分析输入字符串，并将字符序列转换成指定类型的变量。在格式之后的各参数包含了变量的地址，用转换结果对这些变量赋值。

#### 临时文件

ISO C 标准 I/O 库提供了两个函数以创建临时文件

```c
#include<stdio.h>
// 返回值：指向唯一路径名的指针
char *tmpnam(char *ptr);
// 返回值：若成功，返回文件指针，若出错，返回 NULL
FILE *tmpfile(void);
```



### 内存流

标准I/O库把数据缓存在内存中，因此每次一字符和每次一行的I/O更有效。可以调用 `setbuf` 或 `setvbuf` 函数让 I/O库使用我们自己的缓冲区。在 `SUSV4` 中支持了内存流。这就是标准 I/O 流，虽然仍使用 FILE 指针进行访问，但其实并没有底层文件。所有的 I/O 都是通过在缓冲区与主存之间来回传送字节来完成。即便这些流看起来像文件流，它们的某些特征使其更适用于字符操作

有 3 个函数可用于内存流的创建

```c
#include <stdio.h>
// 返回值：若成功，返回流指针；若错误，返回 null
FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);
```

`fmemopen` 函数允许调用者提供缓冲区用于内存流：`buf` 参数指向缓冲区的开始位置，`size` 参数指定了缓冲区大小的字节数。如果 `buf` 参数为空，`fmemopen` 函数分配 `size` 字节数的缓冲区。在这种情况下，当流关闭时缓冲区会被释放

*打开内存流的 `type` 参数*

![内存流的type参数](./Images/内存流的type参数.png)

这些取值对应于基于文件的标准 I/O 流的type 参数取值，但是其中有些微小差别。

* 第一，无论何时以追加写方式打开内存流时，当前文件位置设为缓冲区中的第一个 `null` 字节。如果缓冲区中不存在 `null` 字节，则当前位置就设为缓冲区结尾的后一个字节。当流并不是以追加写方式打开时，当前位置设为缓冲区的开始位置。因为追加写模式通过第一个 `null` 字节确定数据的尾端，内存流并不适合存储二进制数据（二进制数据在数据尾端之前就可能包含多个 `null` 字节）

* 第二，如果 `buf` 参数是一个 `null` 指针，打开流进行读或者写都没有任何意义。因为在这种情况下缓冲区是通过 `fmemopen` 进行分配的，没有办法找到缓冲区的地址，只写方式打开流意味着无法读取已写入的数据，同样，以读方式打开流意味着只能读取那些我们无法写入的缓冲区中的数据
* 第三，任何时候需要增加流缓冲区中数据量以调用 `fclose` 、`fflush`、`fseek`、`fseeko` 以及 `fsetpos` 时都会在当前位置写入一个 `null` 字节

```c
#include <stdio.h>
// 两个函数的返回值：若成功，返回流指针；若出错，返回 null
FILE *open_memstream(char **bufp, size_t *sizep);
#include <wchar.h>
FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);
```

`open_memstream` 函数创建的流是面向字节的，`open_wmemstream` 函数创建的流是面向宽字节的。这两个函数与 `fmemopen` 函数的不同在于：

* 创建的流只能写打开
* 不能指定自己的缓冲区，但可以分别通过 `bufp` 和 `sizep` 参数访问缓冲区地址和大小
* 关闭流后需要自行释放缓冲区
* 对流添加字节会增加缓冲区大小

但是在缓冲区地址和大小的使用上必须遵循一些原则。第一，缓冲区地址和长度只有在调用 `fclose` 或 `fflush` 后才有效；第二，这些值只有在下一次流写入或调用 `fclose` 前才有效。因为缓冲区可以增长，可能需要重新分配。如果出现这种情况，缓冲区的内存地址值在下一次调用 `fclose` 或 `fflush` 时会改变。

避免了缓冲区溢出，内存流非常适用于创建字符串。因为内存流只访问主存，不访问磁盘上的文件，所以对于把标准 I/O 流作为参数用于创建临时文件的函数来说，会有很大的新能提升

### 缓冲特征

* 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的

* 标准错误决不会时全缓冲的

* 标准错误是不带缓冲的

* 若是指向终端设备的流，则是行缓冲；否则是全缓冲

### 非阻塞 I/O

* 非阻塞 I/O 使 `open` `read` `write` 这样的 I/O 操作永远不会阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞
* 对于一个给定的描述符，有两种为其指定非阻塞 I/O 的方法：如果调用 `open`  获得描述符，则可指定 `O_NONBLOCK` 标志；对于已经打开的一个描述符，则可指定 `fcntl` ,由该函数打开 `O_NONBLOCK` 文件状态标志

### 记录锁

记录锁的功能是:当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。即字节范围锁，它锁定的只是文件中的一个区域（也可能是整个文件）

* `fcntl` 记录锁

  ```c
  #include <fcntl.h>
  // 返回值：若成功，依赖于 cmd，否则，返回 -1
  int fcntl(int fd, int cmd, .../ * struct flock *flockptr */);
  ```

  对于记录锁，`cmd` 是 `F_GETLK` ，`F_SETLK`，`F_SETLKW`

  `F_GETLK`  判断由 `flockptr` 所描述的锁是否会被另外一把锁阻塞。如果存在一把锁，它阻止创建由 `flockptr` 所描述的锁，则该现有锁的信息将重写 `flockptr` 指向的信息。如果不存在这种情况，则除了将 `l_type` 设置为 `F_UNLCK` 之外，`flockptr` 所指向结构中的其他信息保持不变。

  `F_SETLK` 设置由 `flockptr` 所描述的锁。如果试图获得一把读锁（`l_typr` 为 `F_RDLCK`) 或写锁 (`l_type ` 为 `F_WRLCK` ) ，而兼容性规则阻止系统给我们这把锁，那么 `fcntl` 会立即出错返回，此时 `errno` 设置为`EACCES` 或 `EAGAIN`

  `F_SETLKW` 这个命令是 `F_SETLK` 的阻塞版本。如果锁请求的读锁或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁而不能授予，那么调用进程会被设置为休眠。如果请求创建的锁已经可用，或休眠由信号中断，则该进程被唤醒。

  用 `F_GETLK` 测试能否建立一把锁，然后用 `F_SETLK` 或 `F_SETLKW` 企图建立那把锁，这两者不是一个原子操作。不能保证在这两次 `fcntl` 调用之间不会有另一个进程插入并建立一把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由 `F_SETLK` 返回的可能的出错。

  第三个参数是一个指向 `flock` 结构的指针

  ```c
  struct flock {
      short l_type;   /** F_RDLCK 共享读锁，F_WRLCK 独占性写锁，F_UNLCK 解锁一个区域 */
      short l_whence;    
      off_t l_start; 
      off_t l_len;   /** 区域的字节长度 */
      pid_t l_pid;  /** 进程的 ID 持有的锁能阻塞当前进程（仅由 F_GETLK返回）*/
  }
  ```

  共享读锁和独占性写锁的基本规则是：任意多个进程在一个给定的字节上可以有一把共享的读锁，但在一个给定字节上只能有一个进程有一个独占写锁。如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁；如果在一个字节上已经有一把独占性写锁，则不能再对它加任何读锁。如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加一把锁，那么新锁将替换已有锁。

  加读锁时，该描述符必须是读打开的，加写锁时，该描述符必须是写打开的

* 锁的隐含继承和释放

  锁与进程和文件两者相关联。这有两重含义：1.当一个进程终止时，它所建立的锁全部释放；2.无论一个描述符何时关闭，该进程通过这一描述符引用的文件上的任何一把锁都会释放（这些锁都是该进程设置的）

  由 `fork` 产生的子进程不继承父进程所设置的锁。这意味着：当一个进程得到一把锁，然后调用 `fork` ,那么对于父进程得到的锁而言，子进程被视为另一个进程。对于通过 `fork` 从父进程处继承过来的描述符，子进程需要调用 `fcntl` 才能获得它自己的锁。

  在执行 `exec` 后，新程序可以继承原执行程序的锁。但是，如果对一个文件描述符设置了执行时关闭标志，那么当作为 `exec` 的一部分关闭该文件描述符时，将释放相应文件的所有锁。

### I/O 多路转接

* 轮询：在所有支持非阻塞 I/O 的系统上都可以使用。将描述符都设置为非阻塞的，对第一个描述符发一个 `read` ，如果该输入上有数据，则读数据并处理它。如果无数据可读，则该调用立即返回。缺点是浪费 CPU 时间。
* 异步 I/O：当描述符准备好进行 I/O 时，用一个信号通知它。
* I/O 多路转接：先构造一张感兴趣的描述符的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行 I/O 时，该函数才返回。 `poll`，`pselect` ，`select` 这 3 个函数能够执行 I/O 多路转接。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行 I/O 了。

#### `select`

```c
#include <sys/select.h>
// 返回值：准备就绪的描述符数目；若超时，返回 0；若出错，返回 -1
int select(int maxfdpl, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict exceptfds struct timeval *restrict tvptr);
```

`tvptr` 即愿意等待的时间长度，单位为秒和微秒。

`tvptr == NULL` 永远等待，如果捕捉到一个信号则中断此无限等待。当所指定的描述符中的一个已准备好或捕捉到一个信号则返回。如果捕捉到一个信号，则 `select` 返回 -1，`errno` 设置为 `EINTR`

`tvptr->tv_sec == 0 && tvptr->tv_usec == 0` 根本不等待。测试所有的描述符并立即返回。这是轮询系统找到多个描述符状态而不阻塞 `select` 函数的方法

`tvptr->tv_sec ！= 0 && tvptr->tv_usec != 0` 等待指定的秒数和微秒数。当指定的描述符之一已准备好，或当指定的时间值已经超过时立即返回。如果在超时到期时还没有一个描述符准备好，则返回值 0.（如果系统不提供微妙级别的精度，则 `tvptr->tv_usec` 值取整到最近的支持值）这种等待可被捕捉到的信号中断。 

`readfds`，`writefds`，`exceptfds` 是指向描述符集的指针。每个描述符集存储在一个 `fd_set` 数据类型中。这个数据类型是由实现选择的，它可以为每一个可能的描述符保持一位。对于 `fd_set` 数据类型，唯一可以进行的处理是：分配一个这种类型的变量，将这种类型的一个变量值赋给同类型的另一个变量，或对这种类型的变量使用下列 4 个函数中的一个

```c
#include <sys/select.h>
// 返回值：若 fd 在描述符集中，返回非 0 值；否则，返回 0
int FD_ISSET(int fd, fd_set *fdset);  
void FD_CLR(int fd, fd_set *fdset);
void FD_SET(int fd,fd_set *fdset);
void FD_ZERO(fd_set, *fdset);
```

这些接口可实现为宏或函数。调用 `FD_ZERO` 将一个 `fd_set` 变量的所有位设置为 0，要开启描述符集中的一位，可以调用 `FD_SET`，调用 `FD_CLR` 可以清除一位。可以调用 `FD_ISSET` 测试描述符集中的一个指定位是否已打开。在声明了一个描述符集之后，必须用 `FD_ZERO` 将这个描述符集置为 0，然后在其中设置我们关心的各个描述符的位。

`select` 的中间 3 个参数（指向描述符集的指针）中的任意一个（或全部）可以是空指针，这表示对相应条件并不关心。如果所有 3 个指针都是 NULL，则 `select` 提供了比 `sleep` 更精确的定时器。

`select` 第一个参数 `maxfdpl` 的意思是：最大文件描述符编号值加 1，考虑所有 3 个描述符集，在 3 个描述符集中找出最大描述符编号值，然后加 1，这就是第一个参数值。也可将第一个参数设置为 `FD_SETSIZE` ,这是`<sys/select.h>` 中的一个常量，它指定最大描述符数（经常是 1024），通过指定我们所关注的最大描述符，内核就只需在此范围内寻找打开的位，而不必在 3 个描述符集中的数百个没有使用的位内搜索。

返回值 -1 表示出错。在所指定的描述符一个都没有准备好时捕捉到一个信号。此种情况下，一个描述符集都不修改；返回值 0 表示没有描述符准备好。若指定的描述符一个都没有准备好，指定的时间就过了，则返回 0，此时所有的描述符集都会置为 0；一个正返回值说明了已经准备好的描述符数。该值是 3 个描述符集中已准备好的描述符数之和，所有如果同一描述符已准备好读和写，那么在返回值中会对其计两次数。在这种情况下，3 个描述符集中仍旧打开的位对应于已准备好的描述符（若对读集 `readfds` 中的一个描述符进行的 `read` 操作不会阻塞，则认为此描述符是准备好的。若对写集`writefd` 中的一个描述符进行的 `write` 操作不会阻塞，则认为此描述符是准备好的。若对异常条件集`execptfds` 中的一个描述符有一个未决异常条件，则认为此描述符是准备好的。异常条件包括：在网络连接上到达带外的数据，或者在处于数据包模式的伪终端上发生了某些条件。对于读写和异常条件，普通文件的文件描述符总是返回准备好）

一个描述符阻塞与否并不影响 `select` 是否阻塞，如果希望读一个非阻塞描述符，并且以超时值 5 秒调用 `select` ，则 `select` 最多阻塞 5s，如果指定一个无限的超时值，则在描述符数据准备好，或捕捉到一个信号之前，`select` 会一直阻塞。

### poll

`poll` 函数可用于任何类型的文件描述符。与 `select` 不同，`poll` 不是为每个条件（可读性，可写性和异常条件）构造一个描述符集，而是构造一个 `pollfd` 结构的数组，每个数组元素指定一个描述符编号以及对该描述符感兴趣的条件。

```c
#include <poll.h>
// 返回值：准备就绪的描述符数目；若超时，返回 0；若出错，返回 -1
int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);
struct pollfd {
    int fd;
    short events;
    short revenet;
}
```

设置 `event` 成员的值一个或多个，告诉内核我们关心的是每个描述符的那些事件。返回时，`revents` 成员由内核设置，用于说明每个描述符发生了哪些事件。

*poll 的 events 和 revents 标志*

![](./Images/poll的events和revents标志.png)

当一个描述符被挂断后（`POLLHUP`) 后，就不能再写该描述符，但是有可能仍然可以从该描述符读取到数据。

`timeout` 指定愿意等待的时

`timeout == -1` ，永远等待。当所指定的描述符中的一个已准备好，或捕捉到一个信号时返回。如果捕捉到一个信号，则 `poll` 返回 `-1` ，`errno` 设置为 `EINTR`

`timeout == 0` ，不等待。测试所有的描述符并立即返回。这是一种轮询系统的方法，可以找到多个描述符的状态而不阻塞 `poll` 函数

`timeout > 0`，等待 `timeout` 毫秒。当指定的描述符之一已准备好，或 `timeout` 到期时立即返回。如果 `timeout` 到期时还没有一个描述符准备好，则返回值 0

一个描述符是否阻塞不会影响 `poll` 是否阻塞

