### 线程

每个线程都包含表示执行环境所必需的信息，其中包括进程中标识线程的线程 ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，`errno` 变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码，程序的全局内存和堆内存，栈以及文件描述符

POSIX 线程的功能测试宏是`_POSIX_THREADS`。应用程序可以把这个宏用于`#ifdef` 测试，从而在编译时确定是否支持线程；也可以把`_SC_THREADS`常数用于调用 `sysconf` 函数，进而在运行时确定是否支持线程。遵循 SUSv4 的系统定义符号 `_POSIX_THREADS` 的值为 `200809L`

在 Linux 下 `pthread` 非系统自带库，编译时需要链接该库：

```shell
gcc {program.c} -lpthread
```

#### 线程操作

##### 线程属性

###### 线程 ID

每个线程有一个线程 ID 只有在它所属的进程上下文中才有意义，使用 `pthread_t` 数据类型来表示的，实现时可用一个结构来代表 `pthread_t` 数据类型，所有可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程 ID 进行比较。Linux 3.2.0 使用无符号长整型表示 `pthread_t` 数据类型

```c
#include <pthread.h>
// 返回值：若相等，返回非 0 数值；否则返回 0
int pthread_equal(pthread_t tidl, pthread_t tid2);
// 返回值：返回调用线程的线程 ID
pthread_t pthread_self(void);
```

当线程需要识别以线程 ID 作为标识的数据结构时，`pthread_self` 函数可以与 `pthread_equal` 函数一起使用。

##### 线程管理

*进程和线程原语的比较*

| 进程原语  |       线程原语        |        秒数        |
| :-------: | :-------------------: | :----------------: |
|  `fork`   |   `pthread_create`    |      创建新的      |
|  `exit`   |    `pthread_exit`     |     从当前退出     |
| `waitpid` |    `pthread_join`     | 从当前获取退出状态 |
| `atexit`  | `pthread_cancel_push` | 注册退出时处理函数 |
| `getpid`  |    `pthread_self`     |    获取当前 ID     |
|  `abort`  |   `pthread_cancel`    |    请求终止当前    |

###### 线程创建

在 `posix` 线程的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。

```c
#include <pthread.h>
// 返回值：若成功，返回 0； 否则，返回错误编号
// 创建新线程，成功时：线程 ID 设置为 tidp 指针，attr 设置线程属性（null默认属性），start_rtn 新线程执行函数，arg 无限制指针指订 start_rtn 参数（如果多个参数，可以作为一个结构指针）；调用失败时通常会返回错误码，不设置 errno ，每个线程都提供 errno 副本，这只是为了与使用 errno 的现有函数兼容
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);
```

线程创建时并不能保证那个线程会先运行，是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

pthread_t ntid;
void printIds(const char *s) 
{
    pid_t pid;
    pthread_t tid;
    pid = getpid();
    tid = pthread_self();
    printf("%s pid %lu tid %lu (0x%lx)\n", s, (unsigned long)pid, (unsigned long)tid, (unsigned long)tid);
}
void *thr_fn(void *arg)
{
    printIds("new thread: ");
    return((void *)0);
}
int main(void)
{
    int err;
    err = pthread_create(&ntid, NULL, thr_fn, NULL);
    if (err != 0) {
        printf("create thread errno: %d", err);
        exit;
    }
    pthread_join(ntid, NULL);
    printIds("main thread:");
    exit;
}
```

###### 线程终止

如果进程中的任意线程调用了 `exit`， `_Exit` 或 `_exit` ，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么发送到线程的信号就会终止整个进程，单个线程可以通过（启动函数返回，返回值为线程退出码、被其他线程取消、线程调用 `pthread_exit`）方式退出，因此可以在不终止整个进程的情况下，停止它的控制流

```c
#include <pthread.h>
// rval_ptr 参数是一个无类型指针，与传给启动函数的单个参数类似。进程中的其他线程也可以通过调用 pthread_join 函数访问这个指针
void pthread_exit(void *rval_ptr)
// 返回值：若成功， 返回0；否则，返回错误编码
// 调用线程阻塞等待指定的线程终止：线程调用 pthread_exit 退出或从执行函数中返回时，进程中的其他线程可以调用此函数获得该线程的退出状态，此时 rval_ptr 包含返回码，如果线程被取消，rval_ptr 设置为 PTHREAD_CANCELED
int pthread_join(pthread_t thread, void **rval_ptr)
```

可以通过调用 `pthread_join` 自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，`pthread_join` 调用就会失败，返回 `EINVAL`，该行为与具体实现有关

如果对线程的返回值并不感兴趣，可以把 `rval_ptr` 设置为 `null`，这种情况下，调用 `pthread_join` 函数可以等待指定的线程终止，但并不获取线程的终止状态。

`pthread_create` 和 `pthread_exit` 函数的无类型指针参数可以传递的值不止一个，这个指针可以传递包含复杂信息的结构的地址，但是注意，这个结构所使用的内存在调用者完成调用以后必须仍然是有效的。例如，在调用线程的栈上分配了该结构，那么其他的线程在使用这个结构时内存内容可能已经改变了。又如，线程在自己的栈上分配了一个结构，然后把指向这个结构的指针传给 `pthread_exit`，那么调用 `pthread_join` 的线程试图使用该结构时，这个栈有可能已经被撤销，这块内存也已另作他用

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void *thr_fn(void *arg)
{
    printf("thread 1 returning\n");
    return ((void *)1);
}

void *thr_fn1(void *arg)
{
    printf("thread 2 exiting\n");
    pthread_exit((void *)2);
}

int main(void)
{
    int err;
    pthread_t tid1, tid2;
    void *tret;
    err = pthread_create(&tid1, NULL, thr_fn, NULL);
    if (err !=0) {
        printf("create thread failed %d\n", err);
    }
    err = pthread_create(&tid2, NULL, thr_fn1, NULL);
    if (err != 0) {
        printf("create thread failed %d\n", err);
    }
    err = pthread_join(tid1, &tret);
    if (err != 0) {
        printf("can't join thread %lu\n", (unsigned long)tid1);
    }
    printf("thread 1 exit code %ld\n", (long)tret);
    err = pthread_join(tid2, &tret);
    if (err != 0) {
        printf("cant' join thread %lu\n", (unsigned long)tid2);
    }
    printf("thread 2 exit code %ld\n", (long)tret);
    exit(0);
}
```

###### 线程取消

线程可以调用 `pthread_cancel` 函数来请求取消同一进程中的其他线程，线程可以选择忽略取消或者控制如何被取消。`pthread_cancel` 并不等待线程终止，它仅仅提出请求

```c
#include <pthread.h>
// 返回值：若成功，返回 0； 否则，返回错误编号
// 默认使得 tid 线程的行为同调用了参数为 PTHREAD_CANCELED 的 pthread_exit 函数
int pthread_cancel(pthread_t tid);
```

线程可以安排它的退出需要调用的函数，这与进程在退出时可以用 `atexit` 函数安排退出是类似的。这样的函数称为线程清理处理程序（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录在栈中，它们的执行顺序与它们注册时相反。

```c
#include <pthread.h>
// 当线程执行以下动作时：调用 pthread_exit 时、响应取消请求时、用非零 execute 参数调用 pthread_cleanup_pop 时，清理函数 rtn 是由 pthread_cleanup_push 函数调度的，调用时只有一个参数 arg
void pthread_cleanup_push(void (*rtn)(void *), void *arg);
// 如果 execute 参数设置为 0，清理函数将不被调用。不管发生那种情况都将删除上次 pthread_cleanup_push 调用建立的清理处理程序
void pthread_cleanup_pop(int execute);
```

这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。`pthread_cleanup_push` 的宏定义可以包含字符 `{`，这种情况下，在 `pthread_cleanup_pop` 的定义中要有对应的匹配字符

调用建立的清理处理程序。如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会调用。清理处理程序是按照与它们安装时相反的顺序被调用的。

如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会被调用

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void cleanup(void *arg) 
{
    printf("cleanup: %s\n", (char *)arg);
}

void *thr_fn1(void *arg)
{
    printf("thread 1 start\n");
    pthread_cleanup_push(cleanup, "thread 1 first handler");
    pthread_cleanup_push(cleanup, "thread 1 second handler");
    printf("thread 1 push complete\n");
    if (arg) {
        return((void *)1);
    }
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    return((void *)1);
}

void *thr_fn2(void *arg)
{
    printf("thread 2 start\n");
    pthread_cleanup_push(cleanup, "thread 2 first handler");
    pthread_cleanup_push(cleanup, "thread 2 second handler");
    printf("thread 2 push complete\n");
    if (arg) {
        pthread_exit((void *)2);
    }
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    pthread_exit((void *)2);
}

int main(void)
{
    int err;
    pthread_t tid1, tid2;
    void *tret;
    err = pthread_create(&tid1, NULL, thr_fn1, (void *)1);
    if (err != 0) {
        exit;
    }
    err = pthread_create(&tid2, NULL, thr_fn2, (void *)0);
    if (err != 0) {
        exit;
    }
    err = pthread_join(tid1, &tret);
    if (err != 0) {
        exit;
    }
    printf("thread 1 exit code %ld\n", (long)tret);
    err = pthread_join(tid2, &tret);
    if (err != 0) {
        exit;
    }
    printf("thread 2 exit code %ld\n", (long)tret);
    exit(0);
}
```

###### 分离线程

在默认情况下，线程的终止状态会保存直到对该线程调用 `pthread_join` 。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。

在线程已经被分离后，不能用 `pthread_join` 函数等待它的终止状态，因为对分离状态的线程调用 `pthread_join` 会产生未定义行为。可以调用 `pthread_detach` 分离线程：

```c
#include <pthread.h>
//返回值：成功，返回0；否则，返回错误编号
int pthread_detach(pthread_t tid);  
```

##### 线程同步

当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。

当一个线程修改变量时，其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。

如果修改操作是原子操作，那么就不存在竞争。在现在计算机系统中，存储访问需要多个总线周期，多处理器的总线周期通常在多个处理器上时交叉的，所有并不能保证数据是顺序一致的

###### 线程死锁

如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态。程序中使用一个以上的互斥量时，如果允许一个线程一直占用第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量。因为两个线程都在相互请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是产生死锁

可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量

可以使用 `pthread_mutex_trylock` 接口避免死锁。如果已经占有某些锁而且 `pthread_mutex_trylock` 接口返回成功，那么就可以前进。但是，如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再重复试。

如果锁的粒度太粗，就会出现很多线程阻塞等待相同的锁，这可能并不能改善并发性。如果锁的粒度太细，那么过多的锁开销会使系统性能受到影响，而且代码变得复杂。需要在代码复杂性和性能之间找到正确的平衡。

###### 互斥量（mutex）

可以使用线程的互斥量（使用 `pthread_mutex_t`）来保护数据，确保同一时间只有一个线程访问数据。互斥量（mutex）从本质上说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。

对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为可运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。

互斥变量是用 `pthread_mutex_t` 数据类型表示的。使用互斥变量前，必须首先对它进行初始化，可以设置为常量 `PTHREAD_MUTEX_INITIALIZER` （只是用于静态分配的互斥量），也可以通过调用 `pthread_mutex_init` 函数进行初始化。如果动态分配互斥量（例如，调用 `malloc` 函数），在释放内存前需调用 `pthread_mutex_destroy`

```c
#include <pthread.h>
// 所有函数的返回值，成功，返回 0；否则，返回错误编号
// 初始化互斥量，常量 PTHREAD_MUTEX_INITALIZER(只用于静态分配的互斥量)，要用默认属性初始化互斥量，只需要把 attr 设为 null
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
// 对动态分配的互斥量，释放内存千需调用该函数释放资源
int pthread_mutex_destroy(pthread_mutex_t *mutext);
// 互斥量进行加锁，调用线程阻塞直到互斥去解锁
int pthread_mutex_lock(pthread_mutex_t *mutex);
// 不加锁版本，调用时互斥量处于未锁住状态，将锁住互斥量，返回 0，否则，调用失败，返回 EBUSY
int pthread_mutex_trylock(pthread_mutex_t *mutex);
// 指定阻塞超时时间（绝对时间），超时时返回错误码 ETIMEDOUT
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);
// 对互斥量解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

```c
#include <pthread.h>
#include <stdlib.h>

struct foo {
    int f_count;
    pthread_mutex_t f_lock;
    int f_id;
};

struct foo *foo_alloc(int id)
{
    struct foo *fp;
    if ((fp = makkoc(sizeof(struct foo))) != NULL) {
        fp->f_count = 1;
        fp->f_id = id;
        if (pthread_mutex_init(&fp->f_lock, NULL) != 0) {
            free(fp);
            return(NULL);
        }
    }
    return(fp);
}

void foo_hold(struct foo *fp)
{
    pthread_mutex_lock(&fp->f_lock);
    fp->f_count++;
    pthread_mutex_unlock(&fp->f_lock);
}

void foo_rele(struct foo *fp)
{
    pthread_mutex_lock(&fp->f_lock);
    if (--fp->f_count == 0) {
        pthread_mutex_unlock(&fp->f_lock);
        pthread_mutex_destroy(&fp->f_lock);
        free(fp);
    } else {
        pthread_mutex_unlock(&fp->f_lock);
    }
}

int pmutextime(void)
{
    int err;
    struct timespec tout;
    struct tm *tmp;
    char buf[64];
    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

    pthread_mutex_lock(&lock);
    printf("mutex is locked\n");
    clock_gettime(CLOCK_REALTIME, &tout);
    tmp = localtime(&tout.tv_sec);
    strftime(buf, sizeof(buf), "%r", tmp);
    printf("current time is %s\n", buf);
    tout.tv_sec += 10;
    err = pthread_mutex_timedlock(&lock, &tout);
    clock_gettime(CLOCK_REALTIME, &tout);
    tmp = localtime(&tout.tv_sec);
    strftime(buf, sizeof(buf), "%r", tmp);
    printf("the time is now %s\n", buf);
    if (err == 0) {
        printf("mutex locked again!\n");
    } else {
        printf("can't lock mvtex again:%d\n", err);
    }
    exit(0);
}
```

超时指定愿意等待的绝对时间（与相对时间对比而言，指定在时间 x 之前可以阻塞等待，而不是说愿意阻塞 Y 秒）。这个超时时间是用 `timespec` 结构来表示的，它用秒和纳秒来描述时间。

阻塞的时间可能会有所不同，造成不同的原因有多种：开始时间可能在某秒的中间位置，系统时钟的精度可能不足以精确到支持我们制定的超时时间值，或者在程序继续运行前，调度延迟可能会增加时间值

###### 读写锁

读写锁（reader-writer lock）与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么是不加锁状态，而且一次只有一个线程可以对其加锁。

读写锁可以有3种状态：

*   读模式下加锁状态（所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止）
*   写模式下加锁状态（写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞）
*   不加锁状态。

一次只有一个线程可以占有写模式的读写锁，但多个线程可以同时占有读模式的读写锁。

虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁要求。这样可以避免读模式锁长期占有，而等待的写模式锁请求一直得不到满足。读写锁非常适合于对数据结构读的次数大于写的情况。

读写锁也叫共享互斥锁（share-exclusive lock）。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住时，就可以说成是以互斥模式锁住的。与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层内存之前必须销毁

```c
#include <pthread.h>
// 所有函数的返回值：若成功，返回 0；否则返回错误编号
// 初始化,读写锁默认属性，传一个 null 指针给 attr。常量（SUS 的 XSI 扩展） PTHREAD_RWLOCK_INITIALIZER 分配静态读写锁
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
// 在释放读写锁占用的内存之前，做清理工作。如果为读写锁分配了资源，将释放这些资源。如果在调用 pthread_rwlock_destroy 之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// 在读模式下锁定读写锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// 在写模式下锁定读写锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// 调用进行解锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// SUS 提供了超时版本，tsptr 参数指向 timespec 结构，指定线程应该停止阻塞的时间（绝对时间）。如果它们不能获取锁，那么超时到期时，这两个函数将返回 ETIMEDOUT 错误
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);
//  SUS 定义的读写锁原语条件版本，两个函数返回值：若成功，返回0；否则，返回错误编号
// 可以获取锁时，这两个函数返回 0，否则，它们返回错误 EBUSY，可以用于遵守某种锁层次但还不能完全避免死锁的情况
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
```

使用读写锁操作队列

```c
#include <stdlib.h>
#include <pthread.h>

struct job {
    struct job *j_next;
    struct job *j_prev;
    pthread_t j_id;
};

struct queue {
    struct job *q_head;
    struct job *q_tail;
    pthread_rwlock_t q_lock;
};

int queue_init(struct queue *qp)
{
    int err;
    qp->q_head = NULL;
    qp->q_tail = NULL;
    err = pthread_rwlock_init(&qp->q_lock, NULL);
    if (err != 0) {
        return(err);
    }
    return(0);
}

void job_insert(struct queue *qp, struct job *jp)
{
    pthread_rwlock_wrlock(&qp->q_lock);
    jp->j_next = qp->q_head;
    jp->j_prev = NULL;
    if (qp->q_head != NULL) {
        qp->q_head->j_prev = jp;
    } else {
        qp->q_tail = jp;
    }
    qp->q_head = jp;
    pthread_rwlock_unlock(&qp->q_lock);
}

void job_append(struct queue *qp, struct job *jp)
{
    pthread_rwlock_wrlock(&qp->q_lock);
    jp->j_next = NULL;
    jp->j_prev = qp->q_tail;
    if (qp->q_tail != NULL) {
        qp->q_tail->j_next = jp;
    } else {
        qp->q_head = jp;
    }
    qp->q_tail = jp;
    pthread_rwlock_unlock(&qp->q_lock);
}

void job_remove(struct queue *qp, struct job *jp)
{
    pthread_rwlock_wrlock(&qp->q_lock);
    if (jp == qp->q_head) {
        qp->q_head = jp->j_next;
        if (qp->q_tail == jp) {
            qp->q_tail = NULL;
        } else {
            jp->j_next->j_prev = jp->j_prev;
        }
    } else if (jp == qp->q_tail) {
        qp->q_tail = jp->j_prev;
        jp->j_prev->j_next = jp->j_next;
    } else {
        jp->j_prev->j_next = jp->j_next;
        jp->j_next->j_prev = jp->j_prev;
    }
    pthread_rwlock_unlock(&qp->q_lock);
}

struct job *job_find(struct queue *qp, pthread_t id)
{
    struct job *jp;
    if (pthread_rwlock_rdlock(&qp->q_lock) != 0) {
        return(NULL);
    }
    for (jp = qp->q_head; jp != NULL; jp = jp->j_next)
    {
        if (pthread_equal(jp->j_id, id)) {
            break;
        }
    }
    pthread_rwlock_unlock(&qp->q_lock);
    return(jp);
}
```

###### 条件变量

条件变量（`pthread_cond_t` ）是线程可用的另一种同步机制。使用之前，必须先初始化，条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。

条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须锁定以后才能计算条件

```c
#include <pthread.h>
//函数的返回值：若成功，返回 0；否则，返回错误编号
// 常量 PTHREAD_COND_INITIALIZER 分配静态条件变量。attr null 设置默认条件变量属性
int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);
// 释放条件变量底层内存空间
int pthread_cond_destroy(pthread_cond_t *cond);
//pthread_cond_wait/pthread_cond_timedwait 调用成功返回时，线程需重新计算条件,其他线程可能已在运行并改变条件
// 等待条件变量为真。传递的互斥量对条件进行保护，调用者把锁住的互斥量传给函数，函数自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。返回时，互斥量再次被锁住
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
// 带超时等待条件变量，超时将重新获取互斥量，返回错误编号
int pthread_cond_timewait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);
// 通知条件已经满足，至少唤醒一个等待该条件的线程
int pthread_cond_signal(pthread_cond_t *cond);
// 唤醒该条件的所有线程
int pthread_cond_broadcast(pthread_cond_t *cond);
```

使用条件变量和互斥量对线程进行同步

```c
#include <pthread.h>
struct msg {
    struct msg *m_next;
}
struct msg *workq;
pthread_cond_t qready = PTHREAD_COND_INITIALIZER;
pthread_mutex_t qlock = PTHREAD_MUTEX_TNITIALIZER;
void process_msg(void)
{
    struct msg *mp;
    for (;;) {
        pthread_mutex_lock(&qlock);
        while (workq == NULL) {
            pthread_cond_wait(&qready, &qlock);
        }
        mp = workq;
        workq = mp->m_next;
        pthread_mutex_unlock(&qlock);
    }
}
void enqueue_msg(struct msg *mp)
{
    pthread_mutex_lock(&qlock);
    mp->m_next = workq;
    workq = mp;
    pthead_mutex_unlock(&qlock);
    pthead_cond_signal(&qready);
}
```

条件是工作队列的状态。我们用互斥量保护条件，在 `while`  循环中判断条件，把消息放到工作队列时，需要占有互斥量。但在给等待线程发信号时，不需要占有互斥量。只要线程在调用 `pthread_cond_signal` 之前把消息从队列中拖出了，就可以在释放互斥量以后完成这部分工作。因为是在 `while` 循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍为空，然后返回继续等待。如果代码不能容忍这种竞争，就需要在给线程发信号的时候占有互斥量。

##### 自旋锁

​	自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处理忙等（自旋）阻塞状态。自旋锁可以用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本

​	自旋锁通常作为底层原语用于实现其他类型的锁。根据它们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当然这里说的有效还是会导致 CPU 资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因

​	当自旋锁用在非抢占式内核中时非常有用：除了提供互斥机制外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自旋锁。在这种类型的内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁

​	在用户层，自旋锁并不是非常有用，除非运行在不允许抢占的实时调度类中。运行在分时调度类中的用户层线程在两种情况下可以被取消调度：当它们的时间片到期时，或者具有更高调度优先级的线程就绪变成可运行时。在这些情况下，如果线程拥有自旋锁，它就会进入休眠状态，阻塞在锁上的其他线程自旋的时间可能会比预期的时间长。

​	很多互斥量的实现非常高效，以至于应用程序采用互斥锁的性能与曾经采用过自旋锁的性能基本是相同的。事实上，有些互斥量的实现在试图获取互斥量的时候会自旋一小段时间，只有在自旋计算到达某一阈值的时候才会休眠。这些因素，加上现代处理器的进步，使得上下文切换越来越快，也使得自旋锁只在某些特定的情况下有用

​	自旋锁的接口与互斥量的接口类似，这使得它可以比较容易地从一个替换为另一个。可以用 `pthread_spin_init` 函数对自旋锁进行初始化。用 `pthread_spin_destroy` 函数进行自旋锁的反初始化

```c
#include <pthread.h>
// 两个函数的返回值：成功返回0，否则返回错误编号
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *lock);
```

​	只有一个属性是自旋锁特有的，这个属性只在支持线程进程共享同步（Thread Process-Shared Synchronization）选项的平台上才用的到。`pshared` 参数表示进程共享属性，表明自旋锁是如何获取的。如果它设为 `PTHREAD_PROCESS_SHARED` ，则自旋锁能被访问锁底层内存的线程所获取，即便那些线程属于不同的进程，情况也是如此。`pshared` 参数设为 `PTHREAD_PROCESS_PRIVATE` ，自旋锁就只能被初始化该锁的进程内部的线程所访问。

​	可用 `pthread_spin_lock` 或 `pthread_spin_trylock` 对自旋锁进行加锁，前者在获取锁之前一直自旋，后者如果不能获取锁，就立即返回 `EBUSY` 错误。`pthread_spin_trylock`不能自旋。不管以何种方式加锁，自旋锁都可以调用 `pthread_spin_unlock` 函数解锁

```c
#include <pthread.h>
// 所有函数返回值：若成功，返回 0；否则返回错误编号
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
int pthread_spin_unlock(pthread_spinlock_t *lock);
```

​	如果自旋锁当前在解锁状态 `pthread_spin_lock` 函数不要自旋就可以对它加锁。如果线程已经对它加锁，结果就是未定义的。调用`pthread_spin_lock` 会返回 `EDEADLK`  错误或其他错误，或者调用可能会永久自旋。具体行为依赖于实际的实现。试图对没有加锁的自旋锁进行解锁，结果也是未定义的。

​	`pthread_spin_lock` 及 `pthread_spin_trylock`，返回值为 0 的话就表示自旋锁被加锁。不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费 CPU 资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。

##### 屏障

​	屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。`pthread_join` 函数就是一种屏障，允许一个线程等待，直到另一个线程退出。但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作

​	使用 `pthread_barrier_init` 函数对屏障进行初始化，用 `thread_barrier_destroy` 函数反初始化。

```c
#include <pthread.h>
// 两个函数，成功，返回 0；否则返回错误编码
int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned_int count);
int pthread_barrier_destroy(pthread_barrier_t *barrier);
```

​	初始化屏障时，使用 `count` 参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用 `attr` 参数指定屏障对象的属性（为 null，用默认属性初始化屏障）。如果使用 `pthread_barrier_init` 函数为屏障分配资源，那么在反初始化屏障时可以调用 `pthread_barrier_destroy` 函数释放相应的资源

​	使用 `pthread_barrier_wait` 函数来表明，线程已完成工作，准备等所有其他线程赶上来

```c
#include <pthread.h>
// 返回值：若成功，返回 0 或者 PTHREAD_BARRIER_SERIAL_THREAD；否则，返回错误编号
int pthread_barrier_wait(pthread_barrier_t *barrier);
```

​	调用 `pthread_barrier_wait` 的线程在屏障计数（调用 `pthread_barrier_init` 时设定）未满足条件时，会进入休眠状态。如果该线程是最后一个调用 `pthread_barrier_wait` 的线程，就满足了屏障计数，所有的线程都被唤醒。

​	对于一个任意线程，`pthread_barrier_wait` 函数返回了 `PTHREAD_BARRIER_SERIAL_THREAD` 。剩下的线程看到的返回值是 0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。

​	一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。但是除非调用了 `pthread_barrier_destroy` 函数之后，又调用 `pthread_barrier_init` 函数对计数用另外的数进行初始化，否则屏蔽计数不会改变。



