### 线程控制

#### 线程限制

线程限制（SUS定义）和 `sysconf` 的 `name` 参数

|            限制名称             |                         描述                         |             name 参数              |
| :-----------------------------: | :--------------------------------------------------: | :--------------------------------: |
| `PTHREAD_DESTRUCTOR_ITERATIONS` | 线程退出时操作系统实现试图销毁线程特定数据的最大次数 | `_SC_THREAD_DESTRUCTOR_ITERATIONS` |
|       `PTHREAD_KEYS_MAX`        |              进程可以创建的键的最大数目              |       `_SC_THREAD_KEYS_MAX`        |
|       `PTHREAD_STACK_MIN`       |             一个线程的栈可用的最小字节数             |       `_SC_THREAD_STACK_MIN`       |
|      `PTHREAD_THREADS_MAX`      |               进程可以创建的最大线程数               |      `_SC_THREAD_THREADS_MAX`      |

#### 线程属性

`pthread` 接口允许通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些熟悉的函数都遵循相同的模式。

* 每个对象与它自己类型的属性对象进行关联（线程与线程属性关联，互斥量与互斥量属性关联）。一个属性对象可以代表多个属性。属性对象对应用程序来说是不透明的。这意味着应用程序并不需要了解有关属性对象内部结构的详细细节，这样可以增强应用程序的可移植性。取而代之的是，需要提供相应的函数来管理这些属性对象
* 有一个初始化函数，把属性设置为默认值
* 销毁属性对象的函数。如果初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源
* 每个属性都有一个从属性对象中获取属性值的函数。由于函数成功时会返回 0，失败时会返回错误编号，所以可以通过把属性值存储在函数的某一个参数指定的内存单元中，把属性值返回给调用者
* 每个属性都有一个设置属性值的函数。属性值作为参数按值传递

可以使用 `pthread_attr_t` 结构修改线程默认属性，并把这些属性与创建的线程联系起来。可以使用 `pthread_attr_init` 函数初始化 `pthread_attr_t` 结构，在调用 `pthread_attr_init` 以后，`pthread_attr_t` 结构所包含的就是操作系统实现支持的所有线程属性的默认值

```c
#include <pthread.h>
// 返回值：成功：0；失败：错误编号
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
```

POSIX.1 定义了线程属性，还为线程指向调度（Thread Execution Scheduling）选项定义了额外的属性，用以支持实时应用。

<img src="../Images/POSIX线程属性.png" style="zoom:75%;" />

* 分离线程

  如果对现有某个线程的终止状态不感兴趣，可以使用 `pthread_detach` 函数让操作系统在线程退出时回收它所占资源。

  如果在创建线程时就知道不需要了解线程的终止状态，就可以修改 `pthread_attr_t` 结构中的 `detachstate`  线程属性，让线程一开始就处于分离状态。可以使用 `pthread_attr_setdetachstate` 函数把线程属性 `detachstate` 设置成以下两个合法值之一：`PTHREAD_CREATE_DETACHED`（以分离状态启动线程）；`PTHREAD_CREATE_JOINABLE`（正常启动线程，应用程序可以获取线程的终止状态）

  ```c
  #include <pthread.h>
  /**
   * 获取当前的 detachstate 线程属性
   * params detachstate : PTHREAD_CREATE_DETACHED PTHREAD_CREATE_JOINABLE
   * return 成功 0；失败 错误编号
   */
  int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr, int *detachstate);
  /**
   * 设置当前 detachstate 线程属性
   * params detachstate : PTHREAD_CREATE_DETACHED PTHREAD_CREATE_JOINABLE
   * return 成功 0；失败 错误编号
   */
  int pthread_attr_setdetachstate(pthread_attr_t *attr, int *detachstate);
  ```

* 线程栈

  对于遵循 POSIX 标准的操作系统来说，并不一定要支持线程栈属性，但是对于遵循 Single UNIX Specification 中 XSI 选项的系统来说，支持线程栈属性就是必需的。可以在编译阶段使用 `_POSIX_THREAD_ATTR_STACKADDR` 和`_POSIX_THREAD_ATTR_STACKSIZE` 符号来检查系统是否支持每一个线程栈属性。如果系统定义了这些符号中的一个，就说明它支持相应的线程栈属性。或者，也可以在运行阶段把 `_SC_THREAD_ATTR_ STACKADDR`和`_SC_THREAD_ATTR_STACKSIZE` 参数传给 `sysconf` 函数，检查运行时系统对线程栈属性的支持情况

  ```c
  #include <pthread.h>
  /**
   * 获取线程栈
   * @return 成功，返回 0；返回错误编号
   * @params stackaddr 由 stackaddr 参数指定的地址可以用作线程栈的内存范围中的最低可寻址地址，该地址与
   *                   处理器结构相应的边界应对齐
   */
  int pthread_attr_getstack(const pthread_attr_t *restrict attr, void **restrict stackaddr, size_t *restrict stacksize);
  /**
   * 设置线程栈
   * @return 成功, 返回 0；返回错误编号
   */
  int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);
  ```

  对于进程来说，虚地址空间的大小是固定的。因为进程中只有一个栈，所以它的大小通常不是问题。但对于线程来说，同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程，以致这些线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分配了大量的自动变量，或者调用的函数涉及许多很深的栈帧（stack frame），那么需要的栈大小可能要比默认的大

  如果线程栈的虚地址空间都用完了，那可以使用 `malloc` 或者 `mmap` 来为可替代的栈分配空间，并用`pthread_attr_setstack` 函数来改变新建线程的栈位置。`stackaddr` 线程属性被定义为栈的最低内存地址，但这并不一定是栈的开始位置。对于一个给定的处理器结构来说，如果栈是从高地址向低地址方向增长的，那么 `stackaddr` 线程属性将是栈的结尾位置，而不是开始位置

  应用程序也可以通过 `pthread_attr_getstacksize` 和 `pthread_attr_setstacksize` 函数读取或设置线程属性 `stacksize`

  ```c
  #include <pthread.h>
  int pthread_attr_getstacksize(const pthread_attr_t *restrict attr, size_t *restrict stacksize);
  int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
  ```

  如果希望改变默认的栈大小，但又不想自己处理线程栈的分配问题，这时使用 `pthread_attr_setstacksize` 函数就非常有用。设置 `stacksize` 属性时，选择的 `stacksize` 不能小于 `PTHREAD_STACK_MIN`

* 扩展内存

  线程属性 `guardsize` 控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小。这个属性默认值是由具体实现来定义的，但常用值是系统页大小。可以把 `guardsize` 线程属性设置为 0，不允许属性的这种特征行为发生：在这种情况下，不会提供警戒缓冲区。同样，如果修改了线程属性 `stackaddr`，系统就认为我们将自己管理栈，进而使栈警戒缓冲区机制无效，这等同于把 `guardsize` 线程属性设置为 0

  ```c
  #include <pthread.h>
  int pthread_attr_getguardsize(const pthread_attr_t *restrict attr, size_t *restrict guardsize);
  int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
  ```

  线程属性 `guardsize` 控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小。这个属性默认值是由具体实现来定义的，但常用值是系统页大小。可以把 `guardsize` 线程属性设置为0，不允许属性的这种特征行为发生：在这种情况下，不会提供警戒缓冲区。同样，如果修改了线程属性 `stackaddr`，系统就认为我们将自己管理栈，进而使栈警戒缓冲区机制无效，这等同于把 `guardsize` 线程属性设置为 0

#### 线程同步属性

##### 互斥量属性

互斥量属性是用 `pthread_mutexattr_t` 结构表示。每次对互斥量进行初始化时，使用 `PTHREAD_MUTEX_INITIALIZER` 常量或者用指向互斥量属性结构的空指针作为参数调用 `pthread_mutex_init` 函数，得到互斥量的默认属性

对于非默认属性，可以用 `pthread_mutexattr_init` 初始化 `pthread_mutexattr_t` 结构，用 `pthread_mutexattr_destroy` 来反初始化

```c
#include <pthread.h>
// 两个函数的返回值：若成功，返回 0；否则返回错误编号
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
```

`pthread_mutexattr_init` 函数将用默认的互斥量属性初始化 `pthread_mutexattr_t` 结构。值得注意的是 3 个属性：进程共享属性，健壮属性以及类型属性。`POSIX.1` 中，进程共享属性是可选的。可以通过检查系统中是否定义了 `_POSIX_THREAD_PROCESS_SHARED` 符号来判断这个平台是否支持进程共享这个属性，也可以在运行时把 `_SC_THREAD_PROCESS_SHARED` 参数传给 `sysconf` 函数进行检查。

在进程中，多个线程可以访问同一个同步对象。这是默认行为。在这种情况下，进程共享互斥量属性需设置为 `PTHREAD_PROCESS_PRIVATE`

允许相互独立的多个进程把同一个内存数据映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为 `PTHREAD_PROCESS_SHARED` ，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步

使用 `pthread_mutexattr_getpshared` 函数查询 `pthread_mutexattr_t` 结构，得到它的进程共享属性，使用 `pthread_mutexattr_setpshared` 函数修改进程共享属性

```c
#include <pthread.h>
// 两个函数的返回值，成功，返回 0；否则，返回错误编号
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr, int *restrict pshared);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);
```

进程互斥量属性设置为 `PTHREAD_PROCESS_PRIVATE` 时，允许 `pthread` 线程库提供更有效的互斥量实现，这在多线程应用程序中时默认的情况。在多个进程共享多个互斥量的情况下，`pthread` 线程库可以限制开销较大的互斥量实现。

互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着，当持有互斥量的进程终止时，需要解决互斥量状态恢复的问题。这种情况发生时，互斥量处于锁定状态，恢复起来很困难。其他阻塞在这个锁的进程将会一直阻塞下去

使用 `pthread_mutexattr_getrobust` 函数获取健壮的互斥量属性的值。可以调用 `pthread_mutexattr_setrobust` 函数设置健壮的互斥量属性的值

```c
#include <pthread.h>
// 两个函数的返回值，成功，返回 0；否则，返回错误编号
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict attr, int *restrict robust);
int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr, int robust);
```

健壮属性取值有两种可能的情况。默认值是 `PTHREAD_MUTEX_STALLED` ，这意味着持有互斥量的进程终止时不需要采取特别的动作。这种情况下，使用互斥量后的行为是未定义的，等待该互斥量解锁的应用程序会被有些地“拖住”，另一个值是 `PTHREAD_MUTEX_ROBUST` ，这个值将导致线程调用 `pthread_mutex_lock` 获取锁，而该锁被另一个进程持有，但它终止时并没有对该锁进行解锁，此时线程会阻塞，从 `pthread_mutex_lock` 返回的值为 `EOWNERDEAD` 而不是 0。应用程序可以通过这个特殊的返回值获知，若有可能（要保护状态的细节以及如何进行恢复会因不同的应用程序而异），不管它们保护的互斥量状态如何，都需要进行恢复。

使用健壮的互斥量改变了我们使用 `pthread_mutex_lock` 的方式，因为现在必须检查 3 个返回值而不是之前的两个：不需要恢复的成功，需要恢复的成功以及失败。但是，即使不用健壮的互斥量，也可以只检查成功或者失败。

如果应用状态无法恢复，在线程对互斥量解锁以后，该互斥量将处于永久不可用状态。为了避免这样的问题，线程可以调用 `pthread_mutex_consistent` 函数，指明与该互斥量相关的状态在互斥量解锁之前是一致的

```c
#include <pthread.h>
// 返回值：若成功，返回 0；否则返回，错误编号
int pthread_mutex_consistent(pthread_mutex_t *mutex);
```

如果线程没有先调用 `pthread_mutex_consistent` 就对互斥量进行了解锁，那么其他试图获取该互斥量的阻塞线程就会得到错误码 `ENOTRECOVERABLE` ，如果发生这种情况，互斥量将不再可用。线程通过提前调用 `pthread_mutex_consistent` ，能让互斥量正常工作，这样它就可以持续被使用。

类型互斥量属性控制着互斥量的锁定特性。POSIX.1 定义了 4 种类型

* `PTHREAD_MUTEX_NORMAL` 一种标准的互斥量类型，不做任何特殊的错误检查或死锁检测
* `PTHREAD_MUTEX_ERRORCHECK` 此互斥量类型提供错误检查
* `PTHREAD_MUTEX_RECURSIVE` 此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以，如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量将依然处理加锁状态，对它再次解锁以前不能释放该锁
* `PTHREAD_MUTEX_DEFAULT` 此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候可以把这种类型自由地映射到其他互斥量类型中的一种。

*互斥量类型行为*

<img src="../Images/互斥量类型行为.png" style="zoom:75%;" />

用 `pthread_mutexattr_gettype` 函数得到互斥量类型属性，用 `pthread_mutexattr_settype` 函数修改互斥量类型属性

```c
#include <pthread.h>
// 两个函数的返回值：若成功，返回 0；否则返回错误编号
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
```

互斥量用于保护与条件变量关联的条件。在阻塞线程之前，`pthread_cond_wait` 和 `pthread_cond_timedwait` 函数释放与条件相关的互斥量。这就允许其他线程获取互斥量、改变条件、释放互斥量以及给条件变量发信号。既然改变条件时必须占有互斥量，使用递归互斥量就不是一个好主意。如果递归互斥量被多次加锁，然后用在调用 `pthread_cond_wait` 函数中，那么条件永远都不会得到满足，因为 `pthread_cond_wait` 所做的解锁操作并不能释放互斥量

##### 读写锁属性

读写锁与互斥量类似，也是有属性的。可以用 `pthread_rwlockattr_init` 初始化 `pthread_rwlockattr_t` 结构，用 `pthread_rwlockattr_destory` 反初始化结构

```c
#include <pthread.h>
// 两个函数的返回值，成功0，否则错误编号
int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
```

读写锁的支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。就像互斥量的进程共享属性一样，有一对函数用于读取和设置读写锁的进程共享属性。

```c
#include <pthread.h>
// 两个函数的返回值：成功，返回 0；否则，返回错误编号
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr, int *restrict pshared);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
```

##### 条件变量属性

SUS 目前定义了条件变量的两个属性：进程共享属性和时钟属性。与其他的属性对象一样，有一对函数用于初始化和反初始化条件变量属性

```c
#include <pthread.h>
// 两个函数返回值，成功 0；否则，返回错误编号
int pthread_condattr_init(pthread_condattr_t *attr);
int pthread_condattr_destory(pthread_condattr_t *attr);
```

条件变量支持进程共享属性。它控制着条件变量是可以被单进程的多个线程使用，还是可以被多进程的线程使用。要获取进程共享属性的当前值，可用 `pthread_condattr_getpshared` 函数。设置该值可用`pthread_condattr_setpshared` 函数

```c
#include <pthead.h>
// 两个函数的返回值：若成功，返回 0；否则，返回错误编号
int pthread_condattr_getpshared(const pthread_condattr_t * restrict attr,int *restrict pshared);
int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);
```

时钟属性控制计算 `pthread_cond_timewait` 函数的超时参数（`tsptr`）时采用的是那个时钟。可以使用 `pthread_condattr_getclock` 函数获取可被用于 `pthread_cond_timedwait` 函数的时钟 ID，在使用 `pthread_cond_timedwait` 函数前需要用 `pthread_condattr_t` 对象对条件变量进行初始化。可以用 `pthread_condattr_setclock` 函数对时钟 ID 进行修改

```c
#include <pthread.h>
int pthread_condattr_getclock(const pthread_condattr_t *restrict attr, clockid_t *restrict clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr, clockid_t clock_id);
```

SUS 并没有为其他有超时等待函数的属性对象定义时钟属性

##### 屏障属性

屏障也有属性。可用使用 `pthread_barrierattr_init` 函数对屏障属性对象进行初始化，用 `pthread_barrierattr_destroy` 函数对屏障属性对象进行反初始化

```c
#include <pthrea.h>
// 两个函数的返回值：若成功，返回 0；否则，返回错误编号
int pthread_barrierattr_init(pthread_barrierattr_t *attr);
int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
```

目前定义的屏障属性只有进程共享属性，它控制着屏障是可以被多进程的线程使用，还是只能被初始化屏障的进程内的多线程使用。与其他属性对象一样，一个获取属性值的函数 `pthread_barrierattr_getpshared` 和一个设置属性值的函数`pthread_barrierattr_setpshared`

```c
#include <pthread.h>
// 两个函数的返回值，成功，返回 0；否则返回错误编号
int pthread_barrieattr_getpshared(const pthread_barrierattr_t *restrict attr, int *restrict pshared);
int pthread_barrieattr_setpshared(pthread_barrierattr_t *attr, int pshared);
```

进程共享属性值可以是：`PTHREAD_PROCESS_SHARED`（多进程中的多个线程可用），也可以是 `PTHREAD_PROCESS_PRIVATE`（只有初始化屏障的那个进程内的多个线程可用）；

#### 重入

线程在遇到重入问题时与信号处理程序是类似的，在这两种情况下，多个控制线程是在相同的时间有可能调用相同的函数。

如果一个函数在相同的时间点可以被多个线程安全的调用，就称该函数是线程安全的。`ctermid` 和 `tmpnam` 函数在参数传入空指针时并不能保证是线程安全的。类似地，如果参数 `mbstate_t` 传入的是空指针，也不能保证 `wcrtomb` 和`wcsrtombs` 函数是线程安全的

*POSIX.1中不能保证线程安全的函数*

![](../Images/POSIX.1中不能保证线程安全的函数.png)

支持线程安全函数的操作系统实现会在 `<unistd.h>` 中定义符号 `_POSIX_THREAD_SAFE_FUNCTIONS`。应用程序也可以在`sysconf` 函数中传入`_SC_THREAD_SAFE_FUNCTIONS` 参数在运行时检查是否支持线程安全函数。在 SUSv4 之前，要求所有遵循 XSI 的实现都必须支持线程安全函数，但是在 SUSv4 中，线程安全函数支持这个需求已经要求具体实现考虑遵循POSIX

操作系统实现支持线程安全函数这个特性时，对POSIX.1中的一些非线程安全函数，它会提供可替代的线程安全版本，这些函数的命名方式与它们的非线程安全版本的名字相似，只不过在名字最后加了 `_r`，表明这些版本是可重入的。很多函数并不是线程安全的，因为它们返回的数据存放在静态的内存缓冲区中。通过修改接口，要求调用者自己提供缓冲区可以使函数变为线程安全

如果一个函数对多个线程来说是可重入的，就说这个函数是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是异步信号安全的。

POSIX.1 还提供了以线程安全的方式管理FILE对象的方法。可以使用 `flockfile` 和 `ftrylockfile` 获取给定 FILE 对象关联的锁。这个锁是递归的：当你占有这把锁的时候，还是可以再次获取该锁，而且不会导致死锁。虽然这种锁的具体实现并无规定，但要求所有操作 FILE 对象的标准 I/O 例程的动作行为必须看起来就像它们内部调用了 `flockfile` 和`funlockfile`

```c
#include <stdio.h>
// 返回值，若成功，返回 0；若不能获取锁，返回非 0 数值
int ftrylockfile(FILE *fp);

void flockfile(FILE *fp);
void funlockfile(FILE *fp);
```

如果标准 I/O 例程都获取它们各自的锁，那么在做一次一个字符的 I/O 时就会出现严重的性能下降。在这种情况下，需要对每一个字符的读写操作进行获取锁和释放锁的动作。为了避免这种开销，出现了不加锁版本的基于字符的标准I/O例程。

```c
#include <stdio.h>
// 两个函数返回值：若成功，返回下一个字符；若遇到文件尾或者出错，返回 EOF
int getchar_unlocked(void);
int getc_unlocked(FILE *fp);
// 两个函数的返回值：若成功，返回 C；若出错，返回 EOF
int putchar_unlocked(int c);
int putc_unlocked(int c, FILE *fp);
```

除非被 `flockfile`（或 `ftrylockfile`）和 `funlockfile` 的调用包围，否则尽量不要调用这4个函数，因为它们会导致不可预期的结果（比如，由于多个控制线程非同步访问数据引起的种种问题）

一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次的数据读写上分摊总的加解锁的开销

#### 线程特定数据

线程特定数据（thread-specific data）即线程私有数据（thread-private data），是存储和查询某个特定线程相关数据的一种机制。每个线程可以访问它自己单独的数据副本，而不需要担心与其他线程的同步访问问题。

有时候需要维护基于每个线程的数据。因为线程 ID 并不能保证是小而连续的整数，所以不能简单地分配一个每线程数据数组，用线程 ID 作数组的索引。即使线程 ID 确实是小而连续的整数，还需要一些额外的保护，防止某个线程的数据与其他线程的数据相混淆

采用线程私有数据的第二个原因是，它提供了基于进程的接口适应多线程环境的机制。实例为 `errno` 线程出现之前，把 `errno` 定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置 `errno` ，把它作为操作失败时的附属结果。为了让线程也能够使用哪些原本基于进程的系统调用和库例程，`errno` 被重新定义为线程私有数据。这样，一个线程重置了 `errno` 的操作也不会影响进程中其他线程的 `errno` 值

一个进程中的所有线程都访问这个进程的整个地址空间。除了使用寄存器以外，一个线程没有办法阻止另一个线程访问它的数据。线程特定数据也不例外。虽然底层的实现部分并不能阻止这种访问能力，但管理线程特定数据的函数可以提高线程间的数据独立性，使得线程不太容易访问到其他线程的特定数据

**在分配线程特定数据之前，需要创建与该数据关联的键。这个键用于获取对线程特定数据的访问。使用 `pthread_key_create` 创建一个键**

```c
#include <pthread.h>
// 返回值：若成功，返回 0；否则，返回错误编号
int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *));
```

创建的键存储在 `keyp` 指向的内存单元中，这个键可以被进程中的所有线程使用，但每个线程把这个键与不同线程特定数据地址进行关联。创建新键时，每个线程的数据地址设为空值

除了创建键以外，`pthread_key_create` 可以为该键关联一个可选择的析构函数。当这个线程退出时，如果数据地址已经被设置为非空值，那么析构函数就会被调用，它唯一的参数就是该数据地址。如果传入的析构函数为空，就表明没有析构函数与这个键关联。当线程调用 `pthread_exit` 或者线程执行返回，正常退出时，析构函数就会被调用。同样，线程取消时，只有在最后的清理处理程序返回之后，析构函数才会被调用。如果线程调用了 `exit`,`_exit`,`_Exit` ,`abort` ,或者出现其他非正常的退出时，就不会调用析构函数。

**线程通常使用 `malloc` 为线程特定数据分配内存。析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了，那么这块内存就会丢失，即线程所属进程就出现了内存泄漏**

线程可以为线程特定数据分配多个键，每个键都可以有一个析构函数与它关联。每个键的析构函数可以互不相同，当然所有键也可以使用相同的析构函数。每个操作系统实现可以对进程可分配的键的数量进行限制（PTHREAD_KEYS_MAX）。

线程退出时，线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数，该函数可能会创建新的线程特定数据，并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后，系统会检查是否还有非空的线程特定数据值与键关联，如果有的话，再次调用析构函数。这个过程将会一直重复直到线程所有的键都为空线程特定数据值，或者已经做了 `PTHREAD_DESTRUCTOR_ITERATIONS` 中定义的最大次数的尝试

对所有的线程，可以通过调用 `pthread_key_delete` 来取消键与线程特定数据值之间的关联关系。

```c
#include <pthread.h>
// 返回值，成功 0；否则，错误编号
int pthread_key_delete(pthread_key_t key);
```

调用 `pthread_key_delete` 并不会激活与键关联的析构函数。要释放任何与键关联的线程特定数据值的内存，需要在应用程序中采取额外的步骤。

需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。解决竞争的办法是使用 `pthread_once` 

```c
#include <pthread.h>
// 返回值：若成功，返回 0；否则，返回错误编号
pthread_once_t initflag = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *initflag void(*initfn)(void));
```

`initflag` 必须是一个非本地变量（如全局变量或静态变量）。而且必须初始化为 `PTHREAD_ONCE_INIT` 

如果每个线程都调用 `pthread_once` ，系统就能保证初始化例程 `initfn` 只被调用一次，即系统首次调用 `pthread_once` 时。

键一旦创建以后，就可以通过调用 `pthread_setspecific` 函数把键和线程特定数据关联起来。可以通过 `pthread_getspecific` 函数获得线程特定数据的地址

```c
#include <pthread.h>
// 返回值：线程特定数据值；若没有值与该键关联，返回 null
void *pthread_getspecific(pthread_key_t key);
// 返回值：成功，返回 0；否则，返回错误编号
int pthread_setspecific(pthread_key_t key, const void *value);
```

如果没有线程特定数据值与键关联，`pthread_getspecific` 将返回一个空指针，可以用这个返回值来确定是否需要调用 `pthread_setspecific` 

#### 取消选项

有两个线程属性并没有包含在 `pthread_attr_t` 结构中，它们是可取消状态和可取消类型。这两个属性影响着线程在响应 `pthread_cancel` 函数调用时的行为

可取消状态属性可以是 `PTHREAD_CANCEL_ENABLE` 或 `PTHREAD_CANCEL_DISABLE` 线程可通过调用 `pthread_setcancelstate` 修改它的可取消状态

```c
#include <pthread.h>
// 返回值，成功返回 0；否则返回错误编号
int pthread_setcancelstate(int state, int *oldstate);
```

`pthread_setcancelstate` 把当前的可取消状态设置为 `state` ，把原来的可取消状态存储在由 `oldstate` 指向的内存单元，这两步是一个原子操作

`pthread_cancel` 调用并不等待线程终止。在默认情况下，线程在取消请求发出以后还是继续运行，直到线程到达某个取消点。取消点事线程检查它是否被取消的一个位置，如果取消了，则按照请求行事。POSIX.1 保证在线程调用下列任何函数时，取消点都会出现。

`POSIX.1` 定义的取消点

![取消点函数](../Images/取消点函数.png)

线程启动时默认的可取消状态是 `PTHREAD_CANCEL_ENABLE`，当状态设为 `PTHREAD_CANCEL_DISABLE` 时，对 `pthread_cancel` 的调用并不会杀死线程。相反，取消请求对这个线程来说还处于挂起状态，当取消状态再次变为 `PTHREAD_CANCEL_ENABLE` 时，线程将在下一个取消点上对所有挂起的取消请求进行处理。

可以调用`pthread_testcancel` 函数在程序中添加自己的取消点。

```c
#include <pthread.h>
void pthread_testcancel(void);
```

调用 `pthread_testcancel` 时，如果有某个取消请求正处于挂起状态，而且取消并没有设置为无效，那么线程就会被取消。但是，如果取消被设置为无效，`pthread_testcancel` 调用就没有任何效果了。

默认取消类型为推迟取消。调用 `pthread_cancel` 以后，在线程到达取消点之前，并不会出现真正的取消。可以调用 `pthread_setcanceltype` 来修改取消类型

```c
#include <pthread.h>
// 返回值：成功返回 0；否则，返回错误编号
int pthread_setcanceltype(int type, int *oldtype);
```

`pthread_setcanceltype` 函数把取消类型设置为 `type` (类型参数可以是 `PTHREADCANCEL_DEFERRED`（默认，推迟取消） 或 `PTHREAD_CANCEL_ASYNCHRONOUS` （异步取消）)，把原来的取消类型保存到 `oldtype` 指向的整型单元

异步取消与推迟取消不同，因为使用异步取消时，线程可以在任意时间撤销，不是非得遇到取消点才能被取消。

#### 线程和信号

每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号，但当某个线程修改了与某个给定信号相关的处理行为以后，所有的线程都必须共享这个处理行为的改变。这样，如果一个线程选择忽略某个给定信号，那么另一个线程就可以通过以下两种方式撤销上述线程的信号选择：恢复信号的默认处理行为，或者为信号设置一个新的信号处理程序

进程中的信号是递送到单个线程的。如果一个信号与硬件故障有关，那么该信号一般会被发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程

使用 `pthread_sigmask` 函数阻止信号发送。

```c
#include <signal.h>
// 返回值：成功，返回0；否则，返回错误编号
int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);
```

`set` 参数包含线程用于修改信号屏蔽字的信号集。`how` 参数可以取下列 3 个值之一：`SIG_BLOCK` ，把信号集添加到线程集合屏蔽字中，`SIG_SETMASK` ，用信号集替换线程的信号屏蔽字；`SIG_UNBLOCK` ，从线程信号屏蔽字中移除信号集。如果 `oset` 参数不为空，线程之前的信号屏蔽字就存储在它指向的 `sigset_t` 结构中。线程可以通过把 `set` 参数设置为 `null`，并把 `oset` 参数设置为 `sigset_t` 结构的地址，来获取当前的信号屏蔽字。这种情况中的 `how` 参数会被忽略

线程可以通过调用 `sigwait` 等待一个或多个信号的出现

```c
#include <signal.h>
// 返回值。若成功，返回 0；否则，返回错误编号
int sigwait(const sigset_t *restrict set, int *restrict signop);
```

`set` 参数指定了线程等待的信号集。返回时，`signop` 指向的整数将包含发送信号的数量。

如果信号集中某个信号在 `sigwait` 调用的时候处于挂起状态，那么 `sigwait` 将无阻塞地返回。在返回之前，`sigwait` 将从进程中移除哪些处于挂起等待状态的信号。如果具体实现支持排队信号，并且信号的多个实例被挂起，那么`sigwait` 将会移除该信号的一个实例，其他的实例还有继续排队。

为了避免错误行为发生，线程在调用 `sigwait` 之前，必须阻塞那些它正在等待的信号。`sigwait` 函数会原子地取消信号集的阻塞状态，直到有新的信号被递送。在返回之前，`sigwait` 将恢复线程的信号屏蔽字。如果信号在`sigwait` 被调用的时候没有被阻塞，那么在线程完成对 `sigwait` 的调用之前会出现一个时间窗，在这个时间窗中，信号就可以被发送给线程。

使用 `sigwait` 的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。为了防止信号中断线程，可以把信号加到每个线程的信号屏蔽字中。然后可以安排专用线程处理信号。这些专用线程可以进行函数调用，不需要担心在信号处理程序中调用那些函数是安全的，因为这些函数调用来自正常的线程上下文，而非会中断线程正常执行的传统信号处理程序。

如果多个线程在 `sigwait` 的调用中因等待同一个信号而阻塞，那么在信号递送的时候，就只有一个线程可以从 `sigwait` 中返回。如果一个信号被捕获（例如进程通过使用 `sigaction` 建立了一个信号处理程序），而且一个线程正在 `sigwait` 调用中等待同一信号，那么这时由操作系统实现来决定以何种方式递送信号。操作系统实现可以让 `sigwait` 返回，也可以激活信号处理程序，但这两种情况不会同时发生。

要把信号发送给进程，可以调用 `kill` ，要把信号发送给线程，可以调用 `pthread_kill` 

```c
#include <signal.h>
// 返回值：若成功，返回 0；否则，返回错误编号
int pthread_kill(pthread_t thread, int signo);
```

可以传一个 0 值的 `signo` 来检查线程是否存在。如果信号默认处理动作是终止该进程，那么把信号传递给某个线程仍然会杀死整个进程。

闹钟定时器是进程资源，并且所有的线程共享相同的闹钟。进程中多个线程不可能互不干扰地使用闹钟定时器

#### 线程和 fork

当线程调用 `fork` 时，就为子进程创建了整个进程地址空间的副本。子进程通过继承整个地址空间的副本，还从父进程那儿继承了每个互斥量，读写锁和条件变量的状态。如果父进程包含一个以上的线程，子进程在 `fork` 返回以后，如果紧接着不是马上调用 `exec` 的话，就需要清理锁状态。

在子进程内部，只存在一个线程，它是由父进程中调用 `fork` 的线程的副本构成的。如果父进程中的线程占有锁，子进程将同样占有这些锁。子进程并不包含占有锁的线程的副本，所以子进程没有办法知道它占有了哪些锁，需要释放哪些锁。

如果子进程从 `fork` 返回以后马上调用其中一个 `exec` 函数，就可以避免这样的问题。这种情况下，旧的地址空间就被丢弃，所以锁的状态无关紧要。如果子进程需要继续做处理工作的话，这种策略就行不通，还需要其他的策略。

在多线程的进程中，为了避免不一致状态的问题，`POSIX.1` 声明，在 `fork` 返回和子进程调用其中一个 `exec` 函数之间，子进程只能调用异步信号安全的函数。这就限制了在调用 `exec` 之前子进程能做什么，但不涉及子进程锁状态的问题。

要清楚锁状态，可以调用 `pthread_atfork` 函数建立 `fork` 处理程序（fork handler)

```c
#include <pthread.h>
// 返回值，成功，返回 0；否则，返回错误编号
int pthread_atfork(void (*prepare) (void), void (*parent)(void), void (*child)(void));
```

用 `pthread_atfork` 函数最多可以安装 3 个帮助清理锁的函数。`prepare fork` 处理程序由父进程在 `fork` 创建子进程前调用。这个 `fork` 处理程序的任务时获取父进程定义的所有锁。`parent fork` 处理程序时在 `fork` 创建子进程以后，返回之前在父进程上下文调用的。这个 `fork` 处理程序的任务是对 `prepare fork` 处理程序获取的所有锁进行解锁。`child fork` 处理程序在 `fork` 返回之前在子进程上下文中调用。与 `parent fork` 处理程序一样，`child fork` 处理程序必须释放 `prepare fork` 处理程序获取的所有锁。

注意，不会出现加锁一次解锁两次的情况，虽然看起来也许会出现。子进程地址空间在创建时就得到了父进程定义的所有锁的副本。因为prepare fork处理程序获取了所有的锁，父进程中的内存和子进程中的内存内容在开始的时候是相同的。当父进程和子进程对它们锁的副本进程解锁的时候，新的内存是分配给子进程的，父进程的内存内容是复制到子进程的内存中（写时复制），所以我们就会陷入这样的假象，看起来父进程对它所有的锁的副本进行了加锁，子进程对它所有的锁的副本进行了加锁。父进程和子进程对在不同内存单元的重复的锁都进行了解锁操作，就好像出现了下列事件序列。

虽然 `pthread_atfork` 机制的意图是使 `fork` 之后的锁状态保持一致，但它还是存在一些不足之处，只能在有限情况下可用。

* 没有很好的办法对较复杂的同步对象（如条件变量或者屏障）进行状态的重新初始化。
* 某些错误检查的互斥量实现在 `child fork` 处理程序试图对被父进程加锁的互斥量进行解锁时会产生错误。
* 递归互斥量不能在 `child fork` 处理程序中清理，因为没有办法确定该互斥量被加锁的次数。
* 如果子进程只允许调用异步信号安全的函数，`child fork` 处理程序就不可能清理同步对象，因为用于操作清理的所有函数都不是异步信号安全的。实际的问题是同步对象在某个线程调用fork时可能处于中间状态，除非同步对象处于一致状态，否则无法被清理。
* 如果应用程序在信号处理程序中调用了 `fork`（这是合法的，因为fork本身是异步信号安全的），`pthread_atfork` 注册的 `fork` 处理程序只能调用异步信号安全的函数，否则结果将是未定义的

#### 线程和 I/O

`pread` 和 `pwrite` 函数。这些函数在多线程环境下是非常有用的，因为进程中的所有线程共享相同的文件描述符。

考虑两个线程，在同一时间对同一个文件描述符进行读写操作。
线程A　　　　　　　　　　　　　　　　　　 线程B
`lseek(fd, 300, SEEK_SET);`　　　　　　　　`lseek(fd, 700, SEEK_SET);`
`read(fd, buf1, 100);`　　　　　　　　　　 `read(fd, buf2, 100);`
如果线程 A 执行 `lseek` 然后线程B在线程 A 调用 `read` 之前调用 `lseek`，那么两个线程最终会读取同一条记录。很显然这不是我们希望的。
为了解决这个问题，可以使用 `pread`，使偏移量的设定和数据的读取成为一个原子操作。
线程A　　　　　　　　　　　　　　　　　　 线程B
`pread(fd, buf1, 100, 300)`;　　　　　　　 `pread(fd, buf2, 100, 700)`;
使用 `pread` 可以确保线程A读取偏移量为 300 的记录，而线程B读取偏移量为700的记录。可以使用 `pwrite` 来解决并发线程对同一文件进行写操作的问题。