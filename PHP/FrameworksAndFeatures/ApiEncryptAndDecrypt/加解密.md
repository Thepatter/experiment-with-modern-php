## 加解密相关

### 名词解释

#### 对称加密

即加密解密使用相同的密钥，优点是速度快，缺点是密钥传输，当前主流对称加密算法是 `aes` 加密算法

##### AES 加密

* 数据填充，`aes` 采用分块加密，默认 32 字节，如果最后不够 32 字节，则必须填充，常用填充模式为 `pkcs5` 和 `pkcs7` 。`pkcs5` 为 `pkcs7` 子集，`pkcs5` 采用末尾填 0，而 `pkcs7` 采用填充“分块的默认字节减去当前字节的剩余字节“。
* `aes-128-cbc`  指的是，使用 16 字节密钥及 16 字节初始化向量`iv`  ，采用 `cbc` 加密模式。
* `aes-128-ecb`  指的是，使用 16 字节密钥，采用 `ecb` 模式加密，该模式不需要初始化向量 `iv`

##### AES/ECB/PKCS5Padding

*java 代码实现*

```java
class AESCrypt {
 	private static final String CipherMode = "AES/ECB/PKCS5Padding";
    
    private static final String key = "VxwJRypPI5S7GBY9";
    
    /**
     * aes加密
     *
     * @param content 加密前内容
     * @return 加密后的数据转16进制大写
     */
    public static String encrypt(String content) {
        byte[] data = null;
        try {
            data = content.getBytes(StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
        }
        data = encrypt(data, new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "AES").getEncoded());
        String result = byte2hex(data);
        return result;
    }
    /**
     * aes解密
     *
     * @param content 密文字符串
     * @return 解密后的字符串
     */
    public static String decrypt(String content) {
        byte[] data = null;
        try {
            data = hex2byte(content);
        } catch (Exception e) {
            e.printStackTrace();
        }
        data = decrypt(data, key.getBytes(StandardCharsets.UTF_8));
        if (data == null)
            return null;
        String result = new String(data, StandardCharsets.UTF_8);
        return result;
    }
    private static byte[] encrypt(byte[] content, byte[] key) {
        try {
            Cipher cipher = Cipher.getInstance(CipherMode);
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES"));
            byte[] result = cipher.doFinal(content);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    private static byte[] decrypt(byte[] content, byte[] key) {
        try {
            Cipher cipher = Cipher.getInstance(CipherMode);
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES"));
            byte[] result = cipher.doFinal(content);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    private static byte[] hex2byte(String inputString) {
        if (inputString == null || inputString.length() < 2) {
            return new byte[0];
        }
        inputString = inputString.toLowerCase();
        int l = inputString.length() / 2;
        byte[] result = new byte[l];
        for (int i = 0; i < l; ++i) {
            String tmp = inputString.substring(2 * i, 2 * i + 2);
            result[i] = (byte) (Integer.parseInt(tmp, 16) & 0xFF);
        }
        return result;
    }
    public static String byte2hex(byte[] b) {
        StringBuffer sb = new StringBuffer(b.length * 2);
        String tmp;
        for (int n = 0; n < b.length; n++) {
            tmp = (Integer.toHexString(b[n] & 0XFF));
            if (tmp.length() == 1) {
                sb.append("0");
            }
            sb.append(tmp);
        }
        return sb.toString().toUpperCase();
    }  
}
```

*对应PHP代码*

```php
// openssl
strtoupper(bin2hex(openssl_encrypt($origin, 'AES-128-ECB', $key, OPENSS_
```



#### 非对称加密

即使用公钥私钥加密，用公钥加密的只能私钥解密，用私钥加密的只能用公钥加密。无法从公钥推断出私钥匙，当前主流非对称加密算法是 `RSA` 或 `RSA2` 算法