## 加解密相关

### 名词解释

#### 对称加密

即加密解密使用相同的密钥，优点是速度快，缺点是密钥传输，当前主流对称加密算法是 `aes` 加密算法

##### AES 加密

* 数据填充，`aes` 采用分块加密，默认 32 字节，如果最后不够 32 字节，则必须填充，常用填充模式为 `pkcs5` 和 `pkcs7` 。`pkcs5` 为 `pkcs7` 子集，`pkcs5` 采用末尾填 0，而 `pkcs7` 采用填充“分块的默认字节减去当前字节的剩余字节“。
* `aes-128-cbc`  指的是，使用 16 字节密钥及 16 字节初始化向量`iv`  ，采用 `cbc` 加密模式。
* `aes-128-ecb`  指的是，使用 16 字节密钥，采用 `ecb` 模式加密，该模式不需要初始化向量 `iv`

##### AES/ECB/PKCS5Padding

*java 代码实现*

```java
class AESCrypt {
 	private static final String CipherMode = "AES/ECB/PKCS5Padding";
    
    private static final String key = "VxwJRypPI5S7GBY9";
    
    /**
     * aes加密
     *
     * @param content 加密前内容
     * @return 加密后的数据转16进制大写
     */
    public static String encrypt(String content) {
        byte[] data = null;
        try {
            data = content.getBytes(StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
        }
        data = encrypt(data, new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "AES").getEncoded());
        String result = byte2hex(data);
        return result;
    }
    /**
     * aes解密
     *
     * @param content 密文字符串
     * @return 解密后的字符串
     */
    public static String decrypt(String content) {
        byte[] data = null;
        try {
            data = hex2byte(content);
        } catch (Exception e) {
            e.printStackTrace();
        }
        data = decrypt(data, key.getBytes(StandardCharsets.UTF_8));
        if (data == null)
            return null;
        String result = new String(data, StandardCharsets.UTF_8);
        return result;
    }
    private static byte[] encrypt(byte[] content, byte[] key) {
        try {
            Cipher cipher = Cipher.getInstance(CipherMode);
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES"));
            byte[] result = cipher.doFinal(content);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    private static byte[] decrypt(byte[] content, byte[] key) {
        try {
            Cipher cipher = Cipher.getInstance(CipherMode);
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES"));
            byte[] result = cipher.doFinal(content);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    private static byte[] hex2byte(String inputString) {
        if (inputString == null || inputString.length() < 2) {
            return new byte[0];
        }
        inputString = inputString.toLowerCase();
        int l = inputString.length() / 2;
        byte[] result = new byte[l];
        for (int i = 0; i < l; ++i) {
            String tmp = inputString.substring(2 * i, 2 * i + 2);
            result[i] = (byte) (Integer.parseInt(tmp, 16) & 0xFF);
        }
        return result;
    }
    public static String byte2hex(byte[] b) {
        StringBuffer sb = new StringBuffer(b.length * 2);
        String tmp;
        for (int n = 0; n < b.length; n++) {
            tmp = (Integer.toHexString(b[n] & 0XFF));
            if (tmp.length() == 1) {
                sb.append("0");
            }
            sb.append(tmp);
        }
        return sb.toString().toUpperCase();
    }  
}
```

*对应PHP代码*

```php
// openssl $origin 如果数据小于 32 byte
bin2hex(openssl_encrypt($origin, 'AES-128-ECB', $key, OPENSSL_RAW_PADDING));
// openssl $origin 数据大于 32 byte
bin2hex(openssl_encrypt($this-pkcs5($origin), 'AES-128-ECB', $key, OPENSSL_NO_PADDING))
// encrypt
public function mcencrypt($input) {
        $size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
        $input = $this->pkcs7($input, $size);
        $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_ECB, '');
        $iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
        mcrypt_generic_init($td, static::key, $iv);
        $data = mcrypt_generic($td, $input);
        mcrypt_generic_deinit($td);
        mcrypt_module_close($td);
        $data = bin2hex($data);
        return $data;
}
private function pkcs5 ($text, $blocksize = 32) {
    $pad = $blocksize - (strlen($text) % $blocksize);
    return $text . str_repeat(chr($pad), $pad);
}
private function pkcs7($data, $blockSize = 32)
{
    $pad = $blockSize - (strlen($data) % $blockSize);
    return $data . str_repeat(chr($pad), $pad);
}
```

此种情况下，pkcs5 与 pkcs7 填充结果一样

`openssl` 如果省略 `options` 则默认采用 pkcs7 填充，并返回一个加密后的base64 字符串；`options` 为 1 时，候默认 `pkcs7` 填充，返回二进制字符串；`option` 为 3 时候，需要自己填充，返回二进制字符串；`options` 为 2 时返回 `false`  ，加密失败。

*cbc加密模式*

`openssl` 函数同上

```php
// mcrypt 模块
public function aesCBC($str) {
        $str = $this->pkcs5($str);
        $encrypt_str = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, self::key, $str, MCRYPT_MODE_CBC, self::iv);
        return base64_encode($encrypt_str);
}
```

pkcs5 与 pkcs7 填充结果一样

#### 非对称加密

即使用公钥私钥加密，用公钥加密的只能私钥解密，用私钥加密的只能用公钥加密。无法从公钥推断出私钥匙，当前主流非对称加密算法是 `RSA` 或 `RSA2` 算法