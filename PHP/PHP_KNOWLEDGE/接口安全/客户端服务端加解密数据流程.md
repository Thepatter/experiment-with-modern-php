## 客户端服务端加解密数据流程

### 约定

* md5 校验值为小写字符
* AES 加密方法为 `AES-128-CBC`  `key` 为随机32 位小写字符串， `vi` 为加密方法对应向量长度随机字节串,填充方式为 `PKSC7Padding`
* RSA 加密 `padding = OPENSSL_PKCS1_PADDING`

### 客户端加密思想为：

* **原始数据采用 AES 对称加密**
* **AES 密钥采用 RSA 公钥加密**

### 客户端加密流程为：(实例代码为 php)

* 获取服务端 RSA 公钥(预先存储在客户端)

* 将原始数据转成 json 字符串，并进行 base64 编码，得到  `op1`

* 将编码的数据进行 md5 校验，得到 sign 值 `op2` ，与 `op1` 组成待 AES 加密数据，并转成 json 字符串，进行base64 编码,得到待 AES 加密字符串 `op3`

  ```php
  $op3 = base64_encode(json_encode(['data' => $op1, 'sign' => $op2]))
  ```

* 生成 AES 加密  key （随机 32 位小写字符） 及 iv 偏移量

  ```php
  $aeskey = md5(str_random(6));
  $ivLength = openssl_cipher_iv_length(config('services.aes.method'));
  $iv = openssl_random_pseudo_bytes($ivLength);
  ```

* 加密待加密字符串 `op3`

  ```php
  private function addPKCS7Padding($source)
  {
      $source = trim($source);
      $block = mcrypt_get_block_size('rijndael-128', 'cbc');
      $pad = $block - (strlen($source) % $block);
      if ($pad <= chr($pad)) {
          $char = chr($pad);
          $source .= str_repeat($char, $pad);
      }
      return $source;
  }

  public function aesEncrypt($str)
  {
      $str = $this->addPKCS7Padding($str);
      $encrypt_str = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $this->key, $str, MCRYPT_MODE_CBC, $this->iv);
      return base64_encode($encrypt_str);
  }
  ```

* RSA 公钥加密 AES key

  ```php
  openssl_public_encrypt($aesKey, $secret, $publicKey);
  ```

* 生成传输数据 AES 加密数据 key 为 `data`,值为 base64 字符串， RSA 加密数据 key 为 `secret` ( secret 由 RSA 加密后的 key 进行base64后由`.` 连接 进行 base64 转换的 `iv` 组成 )

  ```php
  $data = [
    	'data' => base64_encode($data),
    	'secret' => base64_encode($secret) . '.' . base64_encode($iv)
  ];
  ```

**客户端解密思想为：**

* 接收服务端加密数据后用 RSA 公钥解密获取 AES 密钥
* 用 AES 密钥解密获取原始数据

#### 客户端解密流程：

* 将服务器回传的 `secret` 截取，获取 `key`  及  `iv`

  ```php
  $secret = explode('.', $secret);
  $iv = base64_decode($secret[1]);
  $aesKey = base64_decode($secret[0]);
  ```

* 将 `key`  base64 解密后，使用 RSA 私钥解密, 将 `iv` 偏移量 base64 转码

  ```php
  openssl_private_decrypt($data, $aesKey, "file://publicKey.pem");
  ```

* 将得到的 AES `key` 与  `iv` 进行 AES 解密，获取 `data` 及 `sign`

  ```php
  public function aesDecrypt($str) {
      $str = base64_decode($str);
      $encrypt_str = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this->key, $str, MCRYPT_MODE_CBC, $this->iv);
      $encrypt_str = $this->removePKCS7Padding($encrypt_str);
      return $encrypt_str;
  }
  private function removePKCS7Padding($source)
  {
      $char = substr($source, -1);
      $num = ord($char);
      $source = substr($source, 0, -$num);
      return $source;
  }
  ```

* 将 `data` 进行 md5 后与 `sign` 校验

  ```php
  if (md5($source['data']) !== $sour['sign']) {
      next($request);
  }
  ```

* 将 `data` 进行 base64解码后进行 json 字符串序列化，得到原始数据 

  ```php
  foreach($source as $key => $value) {
      $request->{$key} = $value;
      $request->offsetSet($key, $value);
  }
  ```

**如解密及校验不正确则丢弃数据**

### 服务端加解密流程

####服务端接收客户端数据解密

* 接收客户端传的 `secret` 和 `data`
* 以 `.` 分割 `secret`  将第一部分进行 `rsa` 解密，获取 `aes` key , 将第二部分进行 `base64_decode` 得到偏移量 `iv`
* 将 `data` , `key` , `iv` 进行 `aes` 解密后进行 `base64_decode` 后进行 `json_decode`  得到原始数据

#### 服务端响应数据加密

* 将原始数据转成 json 字符串，并进行 base64 编码 得到字符串 `op1`

* 对编码的数据进行 md5 校验得到字符串 `op2`

* 将 `op1` 与 `op2` 组成数组，键值为 `['data' => op1, 'sign' => op2]` 进行 `json` 编码后进行 base64_encode,得到 `aes` 加密原始数据 `op3`

* 生成 `aes` 加密偏移量 `iv` , 和 32 位随机字符串为 `aeskey` 

* 将 `op3` 原始数据进行 `aes` 加密后进行 `base64` 编码得到 最终 data

* 将 `aeskey` 进行 `rsa` 私钥加密后进行`base64` 编码后以 `.` 拼接 `base64` 编码后的 `iv `得到最终 secret 

* 将 data 与 secret 组成数组 `['data' => data, 'secret' => secret]`

  ​

