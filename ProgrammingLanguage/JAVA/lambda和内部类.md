## lambda 表达式和内部类

### Java 接口特性

* 接口不是类，不能使用 `new` 运算符实例化一个接口
* 可以声明接口的变量，接口变量必须引用实现了接口的类对象
* 可以使用 `instance` 检查一个对象是否实现了某个特定的接口
* 接口可以被扩展
* 接口可以定义常量
* 接口的方法自动设置为 `public`，常量自动设置为 `public static final`

### Java SE 8 接口新特性

* 允许在接口中增加静态方法。
* 默认方法，可以为接口方法提供一个默认实现。必须用 `default` 修饰符标记这样的的方法

#### 默认方法冲突

如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。Java 的相应规则是：

1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略

2）接口冲突。如果一个超接口提供了一个默认方法。另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突

3）如果两个接口都没有为共享方法提供默认实现，那么就与 Java 8 之前的情况一样，不存在冲突。实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，这个类本身就是抽象的

4）一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。即类优先规则

### lambda 表达式

#### lambda 表达式语法

参数，箭头（`->`）以及一个表达式。

```java
(String first, String second)
    ->first.length() - seconde.length()
```

如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 `｛｝`  中，并包含显式的 `return` 语句。

```java
(String first, String second)->
	{
        if (first.length() < second.length()) {
            return 1;
        } else {
            return 0;
        }
	}
```

即使 `lambda` 表达式没有参数，仍然要提供空括号，就像无参数方法一样。

```
()->{
    for (int i = 100; i )
}
```

如果可以推导出一个 `lambda` 表达式的参数类型，则可以忽略其类型。如果方法只有一个参数，而且这个参数的类型可以推导得出，那么可以省略小括号

```java
(first, second)->first.length() - second.length()
```

#### 函数式接口

对于只有一个抽象方法的接口，需要这种情况的对象时，可以提供一个 `lambda` 表达式。这种接口即函数式接口

### 内部类

内部类是定义在另一个类中的类：

* 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据
* 内部类可以对同一个包中的其他类隐藏起来
* 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较方便

#### 局部内部类

局部类不能用 `public` 或 `private` 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，即对外部世界可以完成地隐藏起来。即使外部类中的其他代码也不能访问它。

与其他内部类想比较，局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过那些局部变量必须事实上为 `final`

#### 匿名内部类

将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类即为匿名内部类

```java
public void start(int interval, boolean beep)
    {
        ActionListener listener = new ActionListener()
        {
            public void actionPerformed(ActionEvent event) {
                System.out.println("At the tone, the time is " + new Date());
                if (beep) {
                    Toolkit.getDefaultToolkit().beep();
                }
            }
        };
        Timer t = new Timer(interval, listener);
        t.start();
    }
```

#### 静态内部类

如果使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为 `static`，以便取消产生的引用

### 代理

利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。

假定有一个表示接口的 `Class` 对象（有可能只包含一个接口），它的确切类型在编译时无法知道。要构造一个实现这些接口的类，就需要使用 `newInstance` 方法或反射找出这个类的构造器。但是，不能实例化一个接口，需要在程序处于运行状态时定义一个新类（为了解决这个问题，有些程序将会生成代码：将这些代码放置在一个文件中；调用编译器；然后再加载结果类文件。这样速度比较慢，而且需要将编译器与程序放在一起。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。它具有指定接口所需的全部方法和Object类中的全部方法）然而不能再运行时定义这些方法的新代码。而是要提供一个调用处理器。调用处理器是实现了 `InvocationHandler` 接口的类对象。在这个接口中只有一个方法：

```java
Object invoke(Object proxy, Method method, Object[] args);
```

要创建一个代理对象，需要使用 `Proxy` 类的 `newProxyInstance` 方法，该方法的三个参数是：

* 一个类加载器，null 表示使用默认的类加载器
* 一个 `Class` 对象数组，每个元素都是需要实现的接口
* 一个调用处理器



