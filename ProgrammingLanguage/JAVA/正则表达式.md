## Java 正则表达式

正则表达式用于指定字符串的模式，可以在任何需要定位匹配某种特定模式的字符串的情况下使用正则表达式。

正则表达式的常用就是测试某个特定的字符串是否与它匹配。在 Java 中，首先用表示正则表达式的字符串构建一个 `Pattern` 对象。然后从这个模式获得一个 `Matcher`，并调用它的 `matches` 方法

```java
Pattern pattern = Pattern.compile(patternSing);
Matcher matcher = pattern.matcher(input);
if (matcher.matches()) {}
```

这个匹配器的输入可以实任何实现了 `CharSequence` 接口的类的对象

在编译这个模式时，可以设置一个或多个标志

```java
Pattern pattern = Pattern.compile(expression, Pattern.CASE_INSENSIVE + Pattern.UNICODE_CASE);
```

标志：

* `Pattern.CASE_INSENSITIVE` 或 `r`：匹配字符时忽略字母的大小写，默认情况下，这个标志只考虑 `US ASCII` 字符
* `Pattern.UNICODE_CASE` 或 `u`：当与 `CASE_INSENSITIVE` 组合使用时，用 `Unicode` 字母的大小写来匹配
* `Pattern.UNICODE_CHARACTER_CLASS` 或 `U`：选择 `Unicode` 字符流代替 `POSIX` ，其中蕴含了 `UNICODE_CASE`
* `Patern.MULITLINE` 或 `m`：`^` 和 `$` 匹配行的开头和结尾，而不是整个输入的开头和结尾
* `Pattern.UNIX_LINES` 或 `d`：在多行模式中匹配 `^` 和 `$` 时，只有 `\n` 被识别成行终止符
* `Pattern.DOTALL` 或 `s`：当使用这个标志时，`.` 符号匹配所有字符，包括行终止符
* `Pattern.COMMENTS` 或 `x`：空白字符和注释（从 # 到行末尾）将被忽略
* `Pattern.LITERAL`：该模式将被逐字地采纳，必须精确匹配，因字母大小写而造成的差异除外
* `Pattern.CANON_EQ`：考虑 `Unicode` 字符规范的等价

最后两个标志不能在正则表达式内部指定

如果想要在集合或流中匹配元素，可以将模式转换为谓词

```java
Stream<String> strings = ...;
Stream<String> result = strings.filter(pattern.asPredicate());
```

其结果中包含了正则表达式的所有字符串

如果正则表达式包含群组，那么 `Matcher` 对象可以揭示群组的边界。