## MySQL 锁机制

数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁

### 全局锁

全局锁就是对整个数据库实例加锁。`MySQL` 提供了一个加全局读锁的方法，命令是 `flush tables with read lock`（`FTWRL`）。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句

全局锁的典型使用场景是，做全库逻辑备份。即把整库每个表都 `select` 出来存成文本

但让整库都只读，听上去很危险：

* 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
* 如果在从库上备份，那么备份期间从库不能执行主库同步过来的 `binlog`，会导致主从延迟

但不加锁，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。在可重复读隔离级别下开启一个事务，能够拿到一致性视图的。

官方自带的逻辑备份工具是 `mysqldump`。当 `mysqldump` 使用参数 `-single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 `MVCC` 的支持，这个过程中数据是可以正常更新的。`single-transaction` 方法只适应于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 `FTWRL` 方法。

一致性读的前提是引擎要支持这个隔离级别。比如，对于 `MyISAM` 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，就需要使用 `FTWRL` 命令了。

全库只读，可以使用 `set global readonly=true` 的方式。`readonly` 方式可以让全库进入只读状态，但建议使用 `FTWRL` 方式，主要有两个原因

* 有些系统中，`readonly` 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 `global` 变量的方式影响面更大。
* 在异常处理机制上有差异。如果执行 `FTWRL` 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 `readonly` 之后，如果客户端发生异常，则数据库就会一直保持 `readonly` 状态，这样会导致整个库长时间处于不可写状态，风险较高

业务的更新不只是增删改数据（DML），还有可能是加字段等修改表结构的操作（DDL）。不论是那种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的。

### 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL）

表锁的语法是 `lock tables ... read/write`。与 `FTWRL` 类似，可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。`lock tables` 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

如果在某个线程 A 中执行 `lock tables t1 read, t2 write` ；这个语句，则其他线程写 `t1`、读写 `t2` 的语句都会被阻塞。用时，线程 A 在执行 `unlock tables` 之前，也只能执行读 `t1`、读写 `t2` 的操作。写 `t1` 都不允许，自然不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 `InnoDB` 这种支持行锁的引擎，一般不使用 `lock tables` 命令来控制并发，毕竟锁住整个表的影响面还是太大

另一类表级别的锁是 MDL （metadata lock）。MDL 不需要显示使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定不对。

因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当对表做结构变更操作时，加 MDL 写锁

* 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查
* 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

虽然 MDL 锁是系统默认会加的，但事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

如何安全地给小表加字段

1. 解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 `information_schema` 库的 `innodb_trx` 表中，可以查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 `Kill` 掉这个长事务。

如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而不得不加个字段：这时候 `kill` 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 `alter table` 语句里面设定等待时间，如果在这个指定的等待时间里能够拿到 MDL 写锁最后，拿不到也不要阻塞后面的业务语句，先放弃。之后 DBA 再通过重试命令重复这个过程

```mysql
ALTER TABLE tb1_name NOWAIT add column ...
ALTER TABLE tb1_name WAIT N add column ...
```

全局锁主要用在逻辑备份过程中。对于全剧是 `InnoDB` 引擎的库，使用 `-single-transaction` 参数，对应用会更好。

表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果程序里有 `lock tables` 的语句，比较可能的情况是：

* 系统现在还在用 `MyISAM` 这类不支持事务的引擎
* 引擎升级了，但是代码还没升级，业务开发需将`lock tables`  和 `unlock tables` 改成 `begin` 和 `commit`

### 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，`MyISAM` 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。`InnoDB` 是支持行。