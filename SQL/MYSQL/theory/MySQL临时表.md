## MySQL 临时表

### 临时表

#### 临时表于内存表区别

* 内存表，指的是使用 `Memory` 引擎的表，建表语法是 `create table ...engine=memory`。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。其余特性与普通表一致
* 而临时表，可以使用各种引擎类型。如果是使用 `InnoDB` 引擎或者 `MyISAM` 引擎的临时表，写数据的时候是写道磁盘上的。

#### 临时表的特性

临时表在使用上有以下几个特点

1.建表语法是 `create temporary table ...`

2.一个临时表只能被创建它的 `session` 访问，对其他线程不可见。

3.临时表可以与普通表同名

4.一个 `session` 内有同名的临时表和普通表的时候，`show create` 语句，以及增删改查语句访问的是临时表

5.`show tables` 命令不显示临时表

由于临时表只能被创建它的 `session` 访问，所以这个 `session` 结束的时候，会自动删除临时表。因为这个特性，临时表特别适合 `join` 优化的场景

不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开。或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作

#### 临时表的应用

由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。

一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。如将一个大表 ht，按照字段 f，拆分成 1024 个分表，然后分布到 32 个数据库实例上。

*分库分表简图*

![](./Images/分库分表简图.png)

一般情况下，这种分库分表系统都有一个中间层 `proxy`。不过，也有一些方案会让客户端直接连接数据库，即，没有 `proxy` 这一层。在这个架构中，分区 `key` 的选择是以 "减少跨库和跨表查询" 为依据的。如果大部分语句都会包含 f 的等值条件，那么就要用 f 做分区键。这样，在 `proxy` 这一层解析完 SQL 语句以后，就能确定将这条语句路由到那个分表做查询

```mysql
select v from ht where f=N
```

这时，可以通过分表规则（如，N%1024）来确认需要的数据被放在那个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。