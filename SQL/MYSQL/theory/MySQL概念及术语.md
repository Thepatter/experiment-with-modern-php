## MySQL 概念及术语

* **`redo log`**：**重做日志**，是 `innodb` 引擎更新语句时候在内存里写的更新日志，是循环写的。

* **`binlog`**：**归档日志，** 是 `MySQL Server` 层记录的逻辑日志，与具体引擎无关，是记录在某个数据页上做了什么修改的物理日志，是追加写入的。

* **`WAL`** 机制：**Write-Ahead Logging**：先写日志，再写磁盘。当有一条记录需要更新的时候，`InnoDB` 引擎会把记录写到 `redo log` 里面，并更新内存。

* **两阶段提交:** `redo log` 与 `binlog` 的两阶段提交：写入 `redo log` 处于 `prepare` 阶段，写 `binlog` 提交事务。

* **`undo log`**: 回滚日志，语句更新时生成的，记录包含有关如何撤消事务到聚簇索引记录的最新更改的信息

* **事务**：ACID（`Atomicity`，`Consistency`，`Isolation`，`Durability`）原子，一致，隔离，持久。

* **事务隔离级别**，读未提交（`read uncommitted`），读提交( `read committed`)，可重复读(`repeatable read`)，串行化(`serializable`)

  读未提交：一个事务还没提交时，它做的变更就能被别的事务看到

  读提交：一个事务提交之后，它做的变更才会被其他事务看到（在每条语句执行时，生成一个一致性视图）

  可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（在事务启动时，生成一个一致性视图，整个事务期间都使用该视图）

  串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。读写锁互斥，后访问的事务必须等前一个事务执行完成，才能继续执行

* **主键索引**：也称为聚簇索引（`clustered index`），主键索引的叶子节点存的是整行数据

* **非主键索引**：也称为二级索引（`secondary index`），二级索引的叶子节点内容是主键的值

* **回表:**  普通索引查询时，需要先搜索普通的索引树，得到主键值，再到主键索引树上搜索一次

* **页分裂**：B+ 树为了维护索引有序性，在插入新值的时候做必要的维护。如果应插入值的位置满了，需要申请一个新的数据页，移动部分数据过去。

* **页合并**：相邻的页由于删除了数据，利用率很低的时候，会将数据页做合并，合并的过程为分裂的逆过程，不过合并后并不会收缩该空间，只是把该页标记为可复用。

* **覆盖索引：** 在查询里面，索引已经覆盖了查询请求（如，查询主键，但条件字段已加了索引）

* **最左前缀原则**：索引项是按照索引定义里面出现的字段顺序排序的，可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符

* **索引下推：** 5.6 开始，在索引遍历过程中，对索引中包含的字符先做判断，直接过滤掉不满足条件的记录，减少回表次数

* **全局锁：** 即对整个数据库加锁。当加全局锁之后数据处于只读状态，数据更新语句、数据定义语句和更新事务的提交语句会全部阻塞

* **`FTWRL`:** `Flush tables with read lock`，加全局锁

* **`DML`:**  增删改数据

* **`DDL`:** 修改表结构

* **`MVCC`:** 同一行数据有多个数据版本。是 `innodb` 事务更改行数据的时候记录的以事务id的数据行记录

* **表级锁:** `lock tables t read`，可以用 `unlock tables` 主动释放锁。除了会限制别的线程的读写外，也限定了本线程接下来的操作对象

* **元数据锁:** `meta data lock，MDL`，不需要显示使用，在访问一个表的时候会被自动加上。`MDL` 的作用是，保证读写的正确性。5.5 版本引入，当对一个表做增删改查操作的时候，加 `MDL` 读锁；当要对表做结构变更操作的时候，加 `MDL` 写锁。读锁之间不互斥，写锁，读写锁之间是互斥。

* **行锁：** 针对数据表中行记录的锁，由 `InnoDB` 引擎层实现

* **两阶段锁协议:** 在 `InnoDB` 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
* **死锁:** 不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，会导致这些线程进入无限等待的状态
* **主动死锁检测:** 发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 `on`，表示开启这个逻辑
* **一致性视图：** `InnoDB` 实现 `MVCC` 时用到的视图，即 `consistent read view`，用于支持 `RC` 和 `RR` 隔离级别的实现
* **`transaction id`**: 事务开始的时候向 `InnoDB` 的事务系统申请的，是按照申请顺序严格递增的
* **`row trx_id`:**  每个事务更新数据的时候，都会生成一个新的数据版本，并且把 `transaction id` 赋值给这个数据版本的事务 ID，记为 `row trx_id`。
* **当前读：** `current read` ，更新数据都是先读后写的，而这个读，只能读当前的值，即为当前读
* **`change buffer`** : 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中，在不影响数据一致性的前提下，`InnoDB` 会将这些更新操作缓存在 `change buffer` 中，这样就不需要从磁盘中读入这个数据页了。
* **`merge`**: 从磁盘读入数据页到内存（老版本的数据页），从 `change buffer` 里找出这个数据页的 `change buffer` 记录（可能有多个），依次应用，得到新版本数据页，写 `redo log` 这个 `redo log` 包含数据的变更和 `change buffer` 的变更
* **脏页：** 内存数据页跟磁盘数据页内容不一致的时候，内存页为脏页。

