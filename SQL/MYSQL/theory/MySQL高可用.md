## MySQL 高可用相关

正常情况下，只要主库执行更新生成的所有 `binlog` ，都可以穿到备库被正确的执行，备库就能达到跟主库一致的状态，这就是最终一致性，但是，MySQL 要提供高可用，只有最终一致性是不够的，有如下情景要考虑

### 主备延迟

主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电

主动切换的场景

#### 同步延迟

与数据同步有关的时间点主要包括以下三个：

1.主库 A 执行完成一个事物，写入 `binglog`，这个时刻为 T1；

2.之后传给备库 B，我们把备库 B 接收完这个 `binlog` 的时刻记为 T2；

3.备库 B 执行完成这个事务，这个时刻记为 T3；

主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 `T3-T1` 可以在备库上执行 `show slave status` 命令，返回结果里面会显示 `seconds_behind_master` ，表示当前备库延迟多少秒。

`seconds_behind_master` 的计算方式是这样的

1.每个事务的 `binlog` 里面都有一个时间段，用于记录主库上写入的时间

2.备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 `seconds_behind_master`，就是 `T3-T1` 。这个值的时间精度是秒（备库连接到主库的时候，会通过执行 `SELECT UNIX_TIMESTEAMP()` 函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行 `seconds_behind_master` 计算的时候会自动扣掉这个差值

在网络正常的时候，日志从主库传给备库所需的时间是很短的，即 `T2-T1` 的值是非常小的。即在网络正常情况下，主备延迟的主要来源是备库接收完 `binlog` 和执行完这个事务之间的时间差。

主备延迟最直接的表现是，备库消费中转日志的速度，比主库生产 `binlog` 的速度要慢。

### 主备延迟的来源

* 有些部署条件下，备库所在机器的性能要比主库所在的机器性能差，或者多个库备份在同一机器上。更新请求对 `IOPS` 的压力，在主库和备库上是无差别的。更新过程中触发大量读操作。当备库机器上多个备库都在争抢资源的时候，就可能会导致主备延迟了。

  现阶段由于主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称不是，是现在比较常见的情况。

* 备库压力较大，因为主库提供了写能力，备库可能会提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。备库的查询耗费了大量的 CPU 资源，影响了同步速度，造成了主备延迟

  这种情况下的处理一般为

  1.一主多从，除了备库外，可以多接几个从库，让这些从库来分担读的压力

  2.通过`binlog` 输出到外部系统，如 `Hadoop` 这类系统，让外部系统提供统计类查询的能力

  