## Schema 与数据类型优化

### 选择优化的数据类型

#### 更小的通常更好

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘，内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少，但是要确保没有低估需要存储的值的范围，因为在 `schema` 中的多个地方增加数据类型的范围时一个非常耗时和痛苦的操作。如果无法确定那个数据类型是最好的，就选择不会超过范围的最小类型（如果系统不是很忙或者存储的数据量不多，或者是在可以轻易修改设计的早期阶段，那之后修改数据类型也比较容易）

#### 简单就好

简单数据类型的操作通常需要更少的 CPU 周期。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。（如，使用时间类型而不是字符串来存储时间，使用整型存储ip而不是字符串）

#### 尽量避免 null

很多表都包含可为 null 空值的列，即使应用程序并不需要保存 null 也是如此，因为可为 null 是列的默认属性（如果定义表结构时没有指定列为 not null，默认都是允许为 null 的）。通常情况下最好指定列为 not null，除非真的需要存储 null 值。如果查询中包含可为 null 的列，对 `MySQL` 来说更难优化，因为可为 null 的列使得索引、索引统计和值比较都更复杂。可为 null 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。当可为 null 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至可能导致固定大小的索引（如一个整数列的索引）变成可变大小的索引

通常把可为 null 的列改为 not null 带来的性能提升比较小，所以调优时没必要首先在现有 schema 中查找并修改这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为 null 的列

InnoDB 使用单独的位存储 null 值，所以对于稀疏数据（很多值为 null，只有少数列有非 null 值）有很好的空间效率。但这一点不适用 MyISAM 

 