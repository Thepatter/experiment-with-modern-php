## Schema 与数据类型优化

### 数据类型

#### 更小的通常更好

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘，内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少，但是要确保没有低估需要存储的值的范围，因为在 `schema` 中的多个地方增加数据类型的范围时一个非常耗时和痛苦的操作。如果无法确定那个数据类型是最好的，就选择不会超过范围的最小类型（如果系统不是很忙或者存储的数据量不多，或者是在可以轻易修改设计的早期阶段，那之后修改数据类型也比较容易）

#### 简单就好

简单数据类型的操作通常需要更少的 CPU 周期。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。（如，使用时间类型而不是字符串来存储时间，使用整型存储ip而不是字符串）

#### 尽量避免 null

很多表都包含可为 null 空值的列，即使应用程序并不需要保存 null 也是如此，因为可为 null 是列的默认属性（如果定义表结构时没有指定列为 not null，默认都是允许为 null 的）。通常情况下最好指定列为 not null，除非真的需要存储 null 值。如果查询中包含可为 null 的列，对 `MySQL` 来说更难优化，因为可为 null 的列使得索引、索引统计和值比较都更复杂。可为 null 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。当可为 null 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至可能导致固定大小的索引（如一个整数列的索引）变成可变大小的索引

通常把可为 null 的列改为 not null 带来的性能提升比较小，所以调优时没必要首先在现有 schema 中查找并修改这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为 null 的列

`InnoDB` 使用单独的位存储 null 值，所以对于稀疏数据（很多值为 null，只有少数列有非 null 值）有很好的空间效率。但这一点不适用 `MyISAM `

#### 整数类型

**如果存储整数，可以使用这几种整数类型：`TINYINT`，`SMALLINT`，`MEDIUMINT`，`INT`，`BIGINT`。分别使用 8，16，24，32，64 位存储空间。它们可以存储的值的范围从− 2（ N − 1） 到 2（ N − 1） − 1， 其中 N 是 存储 空间 的 位数。整数类型有可选的 `UNSIGNED` 属性，表示不允许负值，这大致可以使正数的上限提高一倍。有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境也是如此，一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算**

**MySQL可以为整数类型指定宽度，`int(11)`，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL 的一些交互工具（如命令行客户端）用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同**

一些第三方存储引擎，如 `Infobright`，有时也有自定义的存储格式和压缩方案，并不一定使用常见的 MySQL 内置引擎的方式

#### 实数类型

实数是带有小数部分的数字。它们不只是为了存储小数部分；也可以使用 `DECLMAL` 存储比 `BIGINT` 还大的整数。

`FLOAT` 和 `DOUBLE` 类型支持使用标准的浮点运算进行近似计算。

`DECLMAL` 类型用于存储精确的小数，在 5.0 版本及以后，`DECLMAL` 类型支持精确计算。因为 CPU 不支持对 `DECLMAL` 的直接计算，在 5.0 后，MySQL 自身实现了 `DECLMAL` 的高精度计算。相对而言，CPU 直接支持原生浮点运算会更快

浮点和 `DECLMAL` 类型都可以指定精度。对于 `DECLMAL` 列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。5.0 和更高版本将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。`DECLMAL (18, 9)` 小数点两边各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占用 1 个字节。5.0 和更高版本的 `DECLMAL` 类型允许最多 65 个数字

浮点类型在存储同样范围的值时，通常比 `DECLMAL` 使用更少的空间，`FLOAT` 使用 4 个字节存储。`DOUBLE` 占用 8 个字节，MySQL 使用 `DOUBLE` 作为内部浮点计算的类型

在数据量比较大的时候，可以考虑使用 `BIGINT` 代替 `DECLMAL` ，将需要存储的小数位数乘以相应的倍数即，这样可以避免浮点存储计算不精确和 `DECIMAL` 精确计算代价高的问题

#### VARCHAR和CHAR类型

VARCHAR和CHAR是两种最主要的字符串类型。存储引擎存储 CHAR 或 VARCHAR 值的方式在内存中和在磁盘上可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式

##### varchar

VARCHAR 类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，它使用必要的空间。如果 MySQL 表使用 `ROW_FORMAT=FIXED` 创建的话，每一行都会使用定长存储，这会很浪费空间

VARCHAR 需要使用 1 或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节。VARCHAR 节省了存储空间，对性能也有帮助。但是，由于行是变长的，在 `UPDATE` 时可能使行变得比原来更长（页分裂）。

VARCHAR 适用场景：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题。使用像 UTF-8 这样的复杂的字符集，每个字符都使用不同的字节数进行存储。5.0 或更高版本，MySQL 在存储和检索时会保留末尾空格。在更老版本，MySQL会剔除末尾空格

##### char

CHAR 类型是定长的：MySQL 总是根据定义的字符串长度分配足够的空间。当存储 CHAR 值时，MySQL 会删除所有的末尾空格。**CHAR 值会根据需要采用空格进行填充以方便比较**

CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。对于经常变更的数据，CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不会产生碎片。对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率

数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串。Memory 引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。**填充和截取空格的行为在不同存储引擎都是一样的，因为这是服务器层进行处理的**

#### BINARY和VARBINARY

`BINARY` 和 `VARBINARY` ，它们存储的是二进制字符串。二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符，填充也不一样：MySQL 填充 BINARY 采用的是 `\0` （零字节）而不是空格，在检索时也不会去掉填充值。（如果需要在检索时保持值不变，则需要特别小心 `BINARY` 类型，MySQL 会用 `\0` 将其填充需要的长度）

当需要存储二进制数据，并且希望 MySQL 使用字节码而不是字符进行比较时，这些类型是非常有用的。二进制比较的优势并不仅仅是大小写敏感，MySQL 比较 BINARY 字符串时，每次比较一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单的多，速度也更快。

MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表或磁盘临时表进行排序或操作时会更糟糕，最好的策略时只分配真正需要的空间

#### BLOB 和 TEXT 类型

BLOB 和 TEXT 都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型家族：字符类型是 `TINYTEXT`，`SMALLTEXT`，`TEXT`，`MEDIUMTEXT`，`LONGTEXT`：对应的二进制类型是 `TINYBLOB`，`SMALLBLOB`， `BLOB`，`MEDIUMBLOB`，`LONGBLOB`。`BLOB` 是 `SMALLBLOB` 的同义词，`TEXT` 是 `SMALLTEXT` 的同义词

MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当 `BLOB` 和 `TEXT` 值太大时，`InnoDB` 会使用专门的外部存储区域进行存储，此时每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值

`BLOB` 和 `TEXT` 家族之间不同是 `BLOB` 类型存储的是二进制数据，没有排序规则或字符串，而 `TEXT` 类型有字符集和排序规则。MySQL 对 `BLOB` 和 `TEXT` 列进行排序与其他类型是不同的：它只对每个列的最前 `max_sort_length` 字节而不是整个字符串做排序，如果只需要排序前面一小部分字符，则可以减少 `max_sort_length` 的配置，或者使用 `ORDER BY SUBSTRING(column, length)` 

**MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序**

Memory 引擎不支持 BLOB 和 TEXT 类型，如果查询使用了 BLOB 或 TEXT 列并且需要使用隐式临时表，将不得不使用磁盘临时表，即使只有几行数据也是如此。这会导致严重的性能开销。即使配置 MySQL 将临时表存储在内存块设备上，依然需要许多昂贵的系统调用。最好的解决方案是尽量避免使用 BLOB 和 TEXT 类型。如果实在无法避免，可以在所有用到 BLOB 字段的地方都使用 `SUBSTRING(column, length)` 将列值转换为字符串在 `ORDERY BY` 子句中也适用，这样就可以使用内存临时表了。但是要确保截取的子字符串足够短，不会使临时表的大小超过 `max_heap_table_size` 或 `tmp_table_size`，超过以后 MySQL 会将内存临时表转换为磁盘临时表

#### 枚举类型

枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL 在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表 `.frm` 文件中保存 ”数字-字符串“ 映射关系的 ”查找表“。如果使用数字作为 ENUM 枚举常量，这种双重性很容易导致混乱，应尽量避免。**枚举字段是按照内部存储的整数而不是定义的字符串进行排序的**

可以使用 `FIELD()` 函数显式地指定排序顺序，但这会导致 MySQL 无法利用索引消除排序，建议定义时按字母的顺序，就可以消除排序

枚举的缺点在于，字符串列表是固定的，添加或删除字符串必须使用 `ALTER TABLE` 因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素，这样在 5.1 及以后就可以不用重建整个表来完成修改。由于 MySQL 把每个枚举值保存为整数，并且必须进行查找才能转换为字符串，所以枚举列有一些开销。通常枚举的列表都比较小，所以开销还可以控制，在特定情况下，把 `CHAR/VARCHAR` 列与枚举列进行关联可能会比直接关联 `CHAR/VARCHAR` 列更慢

#### 日期和时间类型

MySQL 提供两种相似的日期类型：`DATETIME` 和 `TIMESTAMP`。对于很多应用程序，它们都能工作，但在某些场景，一个比另一个工作得好。

##### DATETIME

**这个类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。它把日期和时间封装到格式为 `YYYYMMDDHHMMSS` 的整数中，与时区无关。使用 8 个字节的存储空间**。默认情况下，MySQL 以一种可排序、无歧义的格式显示 `DATETIME` 值，如 `2009-01-16 22:37:08`。这是 ANSI 标准定义的日期和时间表示方法

##### TIMESTAMP

**TIMESTAMP类型保存了从格林尼治标准时间以来的秒数，它和UNIX 时间戳相同。TIMESTAMP 只使用 4 个字节的存储空间，因此它的范围比 `DATETIME` 小得多：只能表示从 1970 年到 2038 年。MySQL 提供了 `FROM_UNIXTIME()` 函数把 UNIX 时间戳转为日期，并提供了 `UNIX_TIMESTAMP()` 函数把日期转换为 `UNIX` 时间戳**

4.1 及更新的版本按照 `DATETIME` 方式格式化 `TIMESTAMP` 的值，之前版本不会在各个部分之间显示任何标点符号。仅仅时显示格式上的区别，存储格式在各个版本都一样

**TIMESTAMP显示的值依赖于时区。MySQL 服务器，操作系统，客户端连接都有时区设置**，因此存储值为 0 的 `TIMESTAMP` 在美国东部显示为 ”19969-12-31 19:00:00"，与格林尼治时差 5 个小时。如果在多个时区存储或访问数据，`TIMESTAMP` 和 `DATETIME` 的行为将很不一样。前者提供的值与时区有关系，后者则保留文本表示的日期和时间

`TIMESTAMP` 有 `DATETIME` 没有的特殊属性，默认情况下，如果插入时没有指定第一个 `TIMESTAMP` 列的值，`MySQL` 则设置这个列的值为当前时间。在插入一行记录时，默认会更新第一个 `TIMESTAMP` 列的值（除非在 UPDATE语句中明确指定了值）。可以配置任何 `TIMESTAMP` 列的的插入和更新行为。`TIMESTAMP` 列默认为 `NOT NULL`

推荐使用 `TIMESTAMP`，它比 `DATETIME` 空间效率更高。如果需要存储更小粒度的日期和时间，可以使用 BIGINT 类型存储微妙级别的时间戳，或者使用 DOUBLE 存储秒之后的小数部分，也可以使用 MariaDB 替代 MySQL

#### 位数据类型

MySQL 有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型

##### BIT

5.0 之前，BIT 是 TININT 的同义词。5.0 之后，这是一个特性完全不同的数据类型。**可以使用BIT列在一列中存储一个或多个true/false值。BIT(1) 定义一个包含单个位的字段，BIT(2) 存储2个位，依次类推。BIT 列的最大长度是 64个位**

BIT 数据类型被用于存储比特值，范围 1 - 64，存储的是二进制字符串。如果为小于位长的列分配值，则会在左侧用零填充该值。

BIT 的行为因存储引擎而不同。MYISAM 会打包存储所有的 BIT 列，即 17 个单独的 BIT 列只需要 17 个位存储（假设没有可为 NULL 的列），这样 MYISAM 只使用 3 个字节就能存储这 17 个 BIT 列。其他存储引擎如 `Memory` 和 `InnoDB`，为每个 BIT 列使用一个足够存储的最小整数类型来存放，所以不能节省空间

MySQL 把 BIT 当成字符串类型，而不是数字类型。当检索 BIT (1) 的值时，结果是一个包含二进制 0 或 1 值的字符串，而不是 ASCII 码的 “0” 或 “1”。在数字上下文中，结果将是位字符串转换成的数字。即，如果存储一个值 `b'0011101'` （二进制值等于 57）到 `BIT(8)` 的列并且检索它，得到的内容是字符码为 57 的字符串。也就是说得到 ASCII 码为 57 的字符 “9”。但是在数字上下文场景中，得到的是数字 57

如果想在一个 `bit` 的存储空间中存储一个 `true/false` 值，可以创建一个可以为空的 `char(0)` 列。该列可以保存空值（NULL）或者长度为零的字符串（空字符串）来代替使用 BIT 类型

##### SET

如果需要保存很多 `true/false` 值，可以考虑合并这些列到一个 `SET` 数据类型，它在  `MySQL` 内部是以一系列打包的位的集合来表示的。这样可以有些的利用存储空间，并且 MySQL 有 `FIND_IN_SET()` 和 `FIELD()` 这样的函数，方便地在查询中使用。它的主要缺点是改变列的定义的代价比较高：需要 `ALTER TABLE`，这对大表来说是非常昂贵的操作。一般来说，也无法在 `SET` 列上通过索引查找

