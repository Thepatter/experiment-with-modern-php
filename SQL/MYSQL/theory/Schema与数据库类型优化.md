## Schema 与数据类型优化

### 数据类型

#### 更小的通常更好

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘，内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少，但是要确保没有低估需要存储的值的范围，因为在 `schema` 中的多个地方增加数据类型的范围时一个非常耗时和痛苦的操作。如果无法确定那个数据类型是最好的，就选择不会超过范围的最小类型（如果系统不是很忙或者存储的数据量不多，或者是在可以轻易修改设计的早期阶段，那之后修改数据类型也比较容易）

#### 简单就好

简单数据类型的操作通常需要更少的 CPU 周期。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。（如，使用时间类型而不是字符串来存储时间，使用整型存储ip而不是字符串）

#### 尽量避免 null

很多表都包含可为 null 空值的列，即使应用程序并不需要保存 null 也是如此，因为可为 null 是列的默认属性（如果定义表结构时没有指定列为 not null，默认都是允许为 null 的）。通常情况下最好指定列为 not null，除非真的需要存储 null 值。如果查询中包含可为 null 的列，对 `MySQL` 来说更难优化，因为可为 null 的列使得索引、索引统计和值比较都更复杂。可为 null 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。当可为 null 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至可能导致固定大小的索引（如一个整数列的索引）变成可变大小的索引

通常把可为 null 的列改为 not null 带来的性能提升比较小，所以调优时没必要首先在现有 schema 中查找并修改这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为 null 的列

`InnoDB` 使用单独的位存储 null 值，所以对于稀疏数据（很多值为 null，只有少数列有非 null 值）有很好的空间效率。但这一点不适用 `MyISAM `

#### 整数类型

**如果存储整数，可以使用这几种整数类型：`TINYINT`，`SMALLINT`，`MEDIUMINT`，`INT`，`BIGINT`。分别使用 8，16，24，32，64 位存储空间。它们可以存储的值的范围从− 2（ N − 1） 到 2（ N − 1） − 1， 其中 N 是 存储 空间 的 位数。整数类型有可选的 `UNSIGNED` 属性，表示不允许负值，这大致可以使正数的上限提高一倍。有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境也是如此，一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算**

**MySQL可以为整数类型指定宽度，`int(11)`，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL 的一些交互工具（如命令行客户端）用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同**

一些第三方存储引擎，如 `Infobright`，有时也有自定义的存储格式和压缩方案，并不一定使用常见的 MySQL 内置引擎的方式

#### 实数类型

实数是带有小数部分的数字。它们不只是为了存储小数部分；也可以使用 `DECLMAL` 存储比 `BIGINT` 还大的整数。

`FLOAT` 和 `DOUBLE` 类型支持使用标准的浮点运算进行近似计算。

`DECLMAL` 类型用于存储精确的小数，在 5.0 版本及以后，`DECLMAL` 类型支持精确计算。因为 CPU 不支持对 `DECLMAL` 的直接计算，在 5.0 后，MySQL 自身实现了 `DECLMAL` 的高精度计算。相对而言，CPU 直接支持原生浮点运算会更快

浮点和 `DECLMAL` 类型都可以指定精度。对于 `DECLMAL` 列，可以指定小数点前后所允许的最大位数。这会影响列的空间小号。5.0 和更高版本将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。`DECLMAL (18, 9)` 小数点两边各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占用 1 个字节。5.0 和更高版本的 `DECLMAL` 类型允许最多 65 个数字

浮点类型在存储同样范围的值时，通常比 `DECLMAL` 使用更少的空间，`FLOAT` 使用 4 个字节存储。`DOUBLE` 占用 8 个字节，MySQL 使用 `DOUBLE` 作为内部浮点计算的类型

在数据量比较大的时候，可以考虑使用 `BIGINT` 代替 `DECLMAL` ，将需要存储的小数位数乘以相应的倍数即，这样可以避免浮点存储计算不精确和 `DECIMAL` 精确计算代价高的问题

#### VARCHAR和CHAR类型

VARCHAR和CHAR是两种最主要的字符串类型。存储引擎存储 CHAR 或 VARCHAR 值的方式在内存中和在磁盘上可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式

VARCHAR 类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，它使用必要的空间。如果 MySQL 表使用 `ROW_FORMAT=FIXED` 创建的话，每一行都会使用定长存储，这会很浪费空间

VARCHAR 需要使用 1 或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节。VARCHAR 节省了存储空间，对性能也有帮助。但是，由于行是变长的，在 `UPDATE` 时可能使行变得比原来更长（页分裂）。

字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题。使用像 UTF-8 这样的复杂的字符集，每个字符都使用不同的字节数进行存储。5.0 或更高版本，MySQL 在存储和检索时会保留末尾空格。在更老版本，MySQL会剔除末尾空格

CHAR 类型是定长的：MySQL 总是根据定义的字符串长度分配足够的空间。当存储 CHAR 值时，MySQL 会删除所有的末尾空格。**CHAR 值会根据需要采用空格进行填充以方便比较**

CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。对于经常变更的数据，CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不会产生碎片。对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率

数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串。Memory 引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。**填充和截取空格的行为在不同存储引擎都是一样的，因为这是服务器层进行处理的**

`BINARY` 和 `VARBINARY` ，它们存储的是二进制字符串。二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符，填充也不一样：MySQL 填充 BINARY 采用的是 `\0` （零字节）而不是空格，在检索时也不会去掉填充值。（如果需要在检索时保持值不变，则需要特别小心 `BINARY` 类型，MySQL 会用 `\0` 将其填充需要的长度）

当需要存储二进制数据，并且希望 MySQL 使用字节码而不是字符进行比较时，这些类型是非常有用的。二进制比较的比较的优势并不仅仅是大小写敏感，MySQL 比较 BINARY 字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单的多，速度也更快。

MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表或磁盘临时表进行排序或操作时会更糟糕，最好的策略时只分配真正需要的空间

#### BLOB 和 TEXT 类型

BLOB 和 TEXT 都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型家族：字符类型是 `TINYTEXT`，`SMALLTEXT`，`TEXT`，`MEDIUMTEXT`，`LONGTEXT`：对应的二进制类型是 `TINYBLOB`，`SMALLBLOB`， `BLOB`，`MEDIUMBLOB`，`LONGBLOB`。`BLOB` 是 `SMALLBLOB` 的同义词，`TEXT` 是 `SMALLTEXT` 的同义词

MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当 `BLOB` 和 `TEXT` 值太大时，`InnoDB` 会使用专门的外部存储区域进行存储，此时每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值

`BLOB` 和 `TEXT` 家族之间不同是 `BLOB` 类型存储的是二进制数据，没有排序规则或字符串，而 `TEXT` 类型有字符集和排序规则。MySQL 对 `BLOB` 和 `TEXT` 列进行排序与其他类型是不同的：它只对每个列的最前 `max_sort_length` 字节而不是整个字符串做排序，如果只需要排序前面一小部分字符，则可以减少 `max_sort_length` 的配置，或者使用 `ORDER BY SUBSTRING(column, length)` 