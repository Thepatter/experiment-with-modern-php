## 为什么还有 kill 不掉的语句

在 MySQL 中有两个 kill 命令：一个是 `kill query + 线程 id`，表示终止这个线程中正在执行的语句；一个是 `kill connection + 线程 id`，这里 `connection` 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的

使用了 `kill` 命令，却没能断开这个连接。再执行 `show processlist` 命令，这条语句的 `Command` 列显示的是 `killed`

其实大多数情况下，`kill query/connection` 命令是有效的。执行一个查询的过程中，发现执行时间太久，要放弃继续查询，这时我们可以用 `kill query` 命令，终止这条查询语句。

还有一种情况是，语句处于锁等待的时候，直接使用 `kill` 命令也是有效的。

*kill query 成功的例子*

![](./Images/keyquery成功的例子.png)

`session C` 执行 `key query` 以后。`session B` 几乎同时提示了语句被中断。

## 收到 kill 以后，线程做什么？

kill 并不是马上停止的意思，而是告诉执行线程，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”

实现上，当用户执行 `kill query thread_id_B` 时，`mysql` 里处理 `kill` 命令的线程做了两件事：

1.把 `session B` 的运行状态改成 `THD::KILL_QUERY`(将变量 `killed` 赋值为: `THD::KILL_QUERY`)

2.给 `session B` 的执行线程发一个信号

`session B` 处于锁等待状态，如果只是把 `session B` 的线程状态设置 `THD:KILL_QUERY`，线程 B 并不知道这个状态变化，还是会继续等待，发一个信号的目的，就是让 `session B` 退出等待，来处理这个 `THD::KILL_QUERY` 状态

上面的分析中，隐含了这么三层意思：

1.一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 `THD:KILL_QUERY`，才开始进入语句终止逻辑

2.如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处

3.语句从开始进入终止逻辑，到终止逻辑完全完成，是一个过程

如果一个线程的状态是 `KILL_CONNECTION`，就把 `Command` 列设置成 `killed`

### kill 无效的情况

#### 客户端虽然断开了连接，但实际上服务端这条语句还在执行过程中

在实现了，等行锁时，使用的是 `pthread_cond_timedwait` 函数，这个等待状态可以被唤醒。

#### 线程没有执行到判断线程状态的逻辑

跟这种情况相同的，还有由于 IO 压力过大，读写 IO 的函数一直无法返回，导致不能及时判断线程的状态

#### 终止逻辑耗时较长

这时候，从 `show processlist` 结果上看也是 `Command=killed`，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种

1.超大事务执行期间被 `kill`。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作。耗时很长

2.大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长

3.DDL 命令执行到最后阶段，如果被 `kill`，需要删除中间过程的临时文件，如果此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长

直接在客户端执行 `Ctrl+C` 的话

