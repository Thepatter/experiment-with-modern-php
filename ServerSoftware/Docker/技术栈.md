## docker 技术栈

### 简介

技术栈是一组相关的服务，它们共享依赖项并且可以一起进行编排和扩展。单个技术栈能够定义和协调整个应用的功能（很复杂的应用可能需要使用多个技术栈）`docker stack deploy` 即是技术栈

### 添加新服务和重新部署

* 向 `docker-compose.yml` 文件添加新的服务

  *docker-compose.yml*

  ```yml
  version: "3"
  services:
    web:
    	image: username/repo:tag
    	deploy:
    	  replocas: 5
    	  restart_policy:
    	    condition: on-failure
    	  resources:
    	    limits:
    	      cpus: "0.1"
    	      memory: 50M
      ports:
        - "80:80"
      networks:
        - webnet
    visualizer:
      images: dockersamples/visualizer:stable
      ports:
        - "8080:8080"
      volumes:
        - "/var/run/docker.sock:/var/run/docker.sock"
      deploy:
        placement:
          constraints: [node.role == manager]
      networkds:
        - webnet
  networks:
    webnet:
  ```

  添加了新内容 `web` 的对等服务 `visualizer` ：`volumes` 键（使可视化程序能够访问 `Docker` 的主机套接字文件）；`placement` 键（用于确保此服务仅在 `swarm` 管理节点上运行，而从不工作节点上运行）。因为根据 `Docker` 所创建的开源项目构建的此容器在图中显示了 `swarm` 上运行的 `Docker` 服务

* 上传到 `myvm1` 

  ```shell
  docker-machine scp docker-compose.yml myvm1:~
  ```

* 在管理节点上重载并更新服务

  ```
  docker-machine ssh myvm1 "docker stack deploy -c docker-compose.yml getstartedlab"
  ```

* 访问 `Visualizer` 服务 

  `curl http://ip:8080`

  `visualizer` 的单个副本已经运行，并且 `web` 的 5 个实例已在 `swarm` 中展开。

  查看服务

  ```shell
  docker-machine ssh myvm1 "docker stack ps getstartedlab"
  ```

  可视化程序是一项独立服务，它可以在技术栈中的任何应用（包括它自己）中运行，它不依赖于任何其他内容

### 添加相互依赖服务

* 添加 `redis` 服务

  ```yaml
  version: "3"
  services:
    web:
      image: <username>/repo:tag
      deploy: 
        replicas: 5
        restart_policy:
          condition: on-failure
        resources:
        	limit:
        	  cpus: "0.1"
        	  memory: 50M
      ports:
        - "80:80"
      networks:
        - webnet
    visualizer:
    	image: dockersamples/visualizer:stable
    	ports:
    	  - "8080:8080"
    	volumes:
    	  - "/var/run/docker.sock:/var/run/docker.sock"
    	deploy:
    	  placement:
    	    constraints: [node.role == manager]
    	networks:
        - webnet
  redis:
    image: redis
    ports:
      - "6379:6379"
    volumes:
      - "/home/docker/data:/data"
    deploy:
      placement:
        constraints: [node.role == manager]
    command: redis-server --appendonly yes
    networks:
      - webnet
  networks:
    webnet:
  ```

  `Redis` 在 `Docker` 库中有一个官方图像，并且已被授予简称 `redis`。`redis` 端口 6379 已由 `Redis` 预先配置为从容器暴露给主机。在我们的 `Compose` 文件中，将它从主机暴露给外部。

  `redis` 规范中有一些事情会使数据在此堆栈的部署之间保持不变：`redis` 总是在管理器上运行，所以它总是使用相同的文件系统；`redis` 访问主机文件系统中的任意目录作为 `/data` 容器内部，这是 `Redis` 存储数据的位置。这是在主机的物理文件系统中为 `Redis` 数据创建“真实来源”。如果没有这个，`Redis` 会将数据存储容器内部文件系统 `/data` 中，如果重新部署该容器，将会删除数据。这个真实来源有两个组成部分：配置在 `Redis` 服务上的配置约束，确保它始终使用管理节点；创建的容器允许容器访问主机上的 `/home/docker/data`，与容器内的 `/data` 。当容器销毁或创建时，存储在主机上的 `/home/docker/data` 文件仍然存在，确保数据不丢失。



