## 通过 EXPLAIN 语句分析 SQL 执行及性能

### EXPLAIN 命令概述

EXPLAIN 命令是查看查询优化器是如何决定执行查询的主要方法。这个功能有局限性，并不总是正确。

#### 使用 EXPLAIN 命令

要使用 EXPLAIN 命令，只需在查询中的 SELECT 关键字前添加 EXPLAIN。MySQL 会在查询上设置一个标记。当执行查询时，这个标记会使其返回关于在执行计划中每一步的信息，而不是执行它。会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序。在查询中每个表在输出中只有一行。如果查询时两个表的连接，输出中会有两行，别名表也算一个表（表包含：子查询，UNION 结果，实体表）

#### EXPLAIN 扩展

* EXPLAIN EXTENDED 和正常 EXPLAIN 一样，但会告诉服务器”逆向编译“执行计划为一个 SELECT 语句。可以通过紧接其后运行 `SHOW WARNINGS` 看到生成的这个语句。这个语句直接来自执行计划， 而不是原 SQL 语句。大部分场景下与原语句不同。（已废弃）
* EXPLAIN PRITITIONS 会显示查询将访问的分区，如果查询时基于分区表的话

#### EXPLAIN 局限性

* 如果查询在 FROM 子句中包括子查询，MySQL 实际会执行子查询，将其结果放在临时表中，然后完成外层查询优化。必须在完成外层查询优化之前处理类似的子查询。在 5.6 中取消该限制
* EXPLAIN 是近似结果
* 不区分具有相同名字的事物。内存排序和临时文件都使用 `filesort`，磁盘和内存临时表都显示 `Using temporary`
* 不会显示执行计划的所有信息，及特定优化，不支持存储过程。
* 不支持 SELECT 以为语句

### EXPLAIN 中的列

#### id

包含一个编号，表示 SELECT 所属的行。

#### select_type

这一列显示了对应行是简单还是复杂 SELECT （如果是后者，那么是三种复杂类型中的哪一种）SIMPLE 值意味着查询不包括子查询和 UNION。如果查询由任何复杂的字部分，则最外层部分标记为**PRIMARY**。其他部分标记如下：

* SUBQUERY

  包含在 SELECT 列表中的子查询中的 SELECT （即不再 FROM 子句中）标记为 SUBQUERY

  ```mysql
  SELECT (SELECT 1 FROM <table> LIMIT 1) from <table>
  ```

* DERIVED

  用来表示包含在 FROM 子句的子查询中的 SELECT，mysql 会递归执行并将结果放到一个临时表中。服务器内部标识为"派生表"，因为该临时表是从子查询中派生来的

* UNION

  在 UNION 中的第二个和随后的 SELECT 被标记为 UNION。第一个 SELECT 被标记就好像它以部分外查询来执行。如果 UNION 被 FROM 子句中子查询包含，那么它的第一个 SELECT 会被标记为 DERIVED

* UNION RESULT

  用来从 UNION 的匿名临时表检索结果的 SELECT 被标记为 UNION RESULT

SUBQUERY 和 UNION 还可被标记为 DEPENDENT 和 UNCACHEABLE。DEPENDENT 意味着 SELECT 依赖于外层查询中发现的数据；UNCACHEABLE 意味着 SELECT 中的某些特性组织结果被缓存与一个 Item_cache 中。

#### table

显示了对应行正在访问那个表。通常情况下，它就是那个表或该表的别名。可以在这一行中从上往下观察 MySQL 的关联优化器为查询选择的关联顺序。

* 派生表和联合

  当 FROM 子句中有子查询或有 UNION 时，table 列会变得复杂的多。在这些场景下，确实没有一个表可以参考，因为 MySQL 创建的匿名临时表仅在查询执行过程中存在

  当在 FROM 子句中有子查询时，table 列是 `<derivedN>` 的形式，其中 N 是子查询的 id。总是向前引用，N 指向 EXPLAIN 输出中后面的一行

  当有 UNION 时，UNION RESULT 的 table 列包含一个参与 UNION 的 id 列表。总是向后引用，因为 UNION RESULT 出现在 UNION 中所有参与行之后。

#### type

关联类型（mysql 决定如何查找表中的行）以下一次从最差到最优

* ALL

  全表扫描，必须扫描整张表，从头到尾，去找需要的行。

* Index

  这个跟全表扫描一样，只是 MySQL 扫描表时按索引次序进行而不是行。避免了排序；要承担按索引次序读取整个表的开销（通常意味着是按随机次序访问的行，开销非常大）如果 Extra 列中看到 "Using index" 说明 MySQL 正在使用覆盖索引，它只扫描所有的数据，而不是按索引次序的每一行。比按索引次序全表扫描的开销要少很多

* range

  范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这比全索引扫描好一些，因为它用不着遍历全部索引。显而易见的范围扫描是带有 BETWEEN 或在 WHERE 子句里带有  > 的查询。

  当 mysql 使用索引去查找一系列值时，IN() 和 OR 列表，也会显示为范围扫描（但其实是不同的访问类型，在性能上有重要差异）

* ref

  索引访问（查找），返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，是查找和扫描的混合体。此类访问只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生。 `ref` 是因为索引要跟某个参考值比较。这个参考值或者是一个常数，或者是来自多表查询前一个表里的结果值。

  `ref_or_null` 是 ref 之上的一个变体，意味着 MySQL 必须在初次查找的结果里进行第二次查找以找出 NULL 条目

* eq_ref

  索引查找：mysql 知道最多只返回一条符合条件的记录。这种访问方法可以在 MySQL 使用主键或者唯一性索引查找时看到，它会将它们与某个参考值做比较。MySQL 对于这类访问类型的优化做的非常好，因为它知道无须估计匹配行的范围或者找到匹配行后再继续查找

* const，system

  当 mysql 能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型。

* NULL

  这种访问意味着 MySQL 能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。

#### possible_keys

这一列显示了查询可以使用哪些索引，这是基于查询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早期创建，因此有些罗列出来的索引可能对于后续优化过程没有用

#### key

这一列显示了 MySQL 决定采用那个索引类优化对该表的访问。如果该索引没有出现在 `possible_keys` 列中，那么 mysql 选用它是出于另外的原因（如，它可能选择了一个覆盖索引，哪怕没有 where 子句）

即，`possible_keys` 揭示了那一个索引能有助于高效地行查找，而  `key` 显示的是优化采用哪一个索引可以最小化查询成本。

#### key_len

显示了 MySQL 在索引里使用的字节数（使用的索引中字段的字节长度和）。如果 MySQL 正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列。

MySQL 并不是总显示一个索引真正使用了多少。对一个前缀模式匹配执行 LIKE 查询，它会显示列的完全宽度正在被使用

key_len 列显示了在索引字段中可能的最大长度，而不是表中数据使用的实际字节数。即 key_len 通过查找表的定义而被计算出，而不是表中的数据的实际字节长度

#### ref

显示了之前的表在 key 列记录的索引中查找值所用的列或常量。

#### rows

估计为了找到所需的行而要读取的行数。这个数字是内嵌循环关联计划里的循环数目。不是 MySQL 认为它最终要从表里读取出来的行数，而是 MySQL 为了找到符合查询的每一点上标准的那些行而必须读取的行的平均数。

是 MySQL 认为它要检查的行数，而不是结果集里的行数。

#### filtered

针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估算。如果把 rows 列和这个百分比相乘，就能看到 MySQL 估算它将和查询计划里亲一个表关联的行数。优化器只有在 ALL，INDEX，RANGE，INDEX_MERGE 访问方法时才会用这一估算

#### Extra

这一列包含的是不适合在其他列显示的额外信息。常见的值：

* `Using index`

  此值表示 MySQL 将使用覆盖索引，比避免访问表。

* `Using where`
  
  MySQL 服务器将在存储引擎检索行后再进行过滤。许多 WHERE 条件里涉及索引中的列，当它读取索引时，就能被存储引擎检验，因此不是所有带 WHERE 子句的查询都会显示 "Using where"
  
  表示 MySQL 服务器将存储引擎返回行以后再应用 WHERE 过滤条件，此时引擎层已锁住获取的所有行
  
* `Using temporary`

  MySQL 在对查询结果排序时会使用一个临时表

* `Using filesort`

  MySQL 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。

* `Range checked for each record(index map: N)`

   意味没好用的索引，新的索引将在联接的每一行上重新估算。N 是显示在 possible_keys 列中索引的位图，并且是冗余的

