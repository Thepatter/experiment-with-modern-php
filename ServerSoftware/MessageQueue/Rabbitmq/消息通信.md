## 消息通信

### 队列

#### 消息订阅

消费者通过以下两种方式从特定的队列中接收消息：

* 通过 AMQP 的 `basic.consume` 命令订阅。这样做会将信道置为接收模式，直到取消对队列的订阅为止。订阅了消息后，消费者在消费（或者拒绝）最近接收的那条消息后，就能从队列中（可用的）自动接收下一条消息。如果消费者处理队列消息，并且需要在消息一到达队列时就自动接收的话，应该使用 `basic.consume`
* 某些时候，只想从队列获得单条消息而不是持续订阅。向队列请求单条消息是通过 `AMQP` 的 `basic.get` 命令实现的。这样做可以让消费者接收队列中的下一条消息。如果要获得更多消息的话，需要再次发送 `basic.get` 命令。大致上讲，`basic.get` 命令会订阅消息，获得单条消息，然后取消订阅。**消费者应该始终使用 `basic.consume` 来实现高吞吐量**

如果至少有一个消费者订阅了队列，消息会立即发送给这些订阅的消费者。如果消息到达了无人订阅的队列，消息会在队列中等待。一旦有消费者订阅了该队列，那么队列上的消息就会发送给消费者。当队列有多个消费者时，队列收到的消息将以循环的方式发送给消费者。每条消息只会发送给一个订阅的消费者

#### 消息确认

消费者接收到的每一条消息都必须进行取人。消费者必须通过 AMQP 的 `basic.ack` 命令显式的向 `RabbitMQ` 发送一个确认。消费者必须通过 AMQP 的 `basic.ack` 命令显式的向 `RabbitMQ` 发送一个确认。或者在订阅到队列的时候就将 `auto_ack` 参数设置为 `true`。当设置 `auto_ack` 时，一旦消费者接收消息，`RabbitMQ` 会自动视其确认了消息。消费者通过确认命令告诉 `RabbitMQ` 它已经正确地接收了消息，同时 `RabbitMQ` 才能安全地把消息从队列中删除。如果消费者收到一条消息，然后确认之前从 `Rabbit` 断开连接（或者从队列上取消订阅），`RabbitMQ` 会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。

#### 消息拒绝

AMQP 的 `basic.reject` 命令允许消费者拒绝 `RabbitMQ` 发送的消息。如果把 `reject` 命令的`requeue` 参数设置成 `true` 的话，`RabbitMQ` 会将消息重新发送给下一个订阅的消费者。如果设置成 `false` 的话，`RabbitMQ` 立即会把消息从队列中移除，而不是把它发送给新的消费者。也可以通过对消息确认的方式来简单地忽略该消息。

#### 创建队列

* 消费者和生产者都能使用 `AMQP` 的 `queue.declare` 命令来创建队列。
* 但是如果消费者在同一条信道上订阅了另一个队列的话，就无法再声明队列了。必须首先取消订阅，将信道置为"传输"模式。
* 消费者订阅队列时需要队列名称，并在创建绑定时也需要指定队列名称。如果不指定队列名称的话，`Rabbit` 会分配一个随机名称并在 `queue.declare` 命令的响应中返回
* 队列的 `exclusive` 参数如果设置为 `true` 的话，队列将变成私有的，此时只有你的应用程序才能够消费队列消息（当想要限制一个队列只有一个消费者的时候很有帮助）。
* 队列的 `auto-delete` 当最后一个消费者取消订阅的时候，队列就会自动移除（如果需要一个临时队列只为一个消费者服务的胡啊，可以使用 `auto-delete` 和 `exclusive` ）当消费者断开连接时，队列就被移除了
* 如果尝试声明一个已经存在的队列，只要声明参数完全匹配现存的队列的话，`Rabbit` 就什么都不做，并成功返回，如果参数不匹配的话，队列声明会失败。
* 如果需要检测队列是否存在，可以设置 `queue.declare` 的 `passive` 选项为 `true` 。在该设置下，如果队列存在，那么 `queue.declare` 命令会成功返回；如果队列不存在的话，`queue.declare` 命令不会创建队列而会返回一个错误

### 交换器和绑定

当想要将消息投递到队列时，通过把消息发送到交换器来完成。然后，根据确定的规则，`RabbitMQ` 将会决定消息该投递到那个队列。这些规则被称作路由键（routing key）。队列通过路由键绑定到交换器。当消息发送到代理服务器时，消息将拥有一个路由键（即使是空的）`RabbitMQ` 也会将其和绑定使用的路由键进行匹配。如果相匹配的话，那么消息将会投递到该队列。如果路由的消息不匹配任何绑定模式的话，消息将进入"黑洞"

协议中定义了不同类型交换器

* `direct`

  如果路由键匹配的话，消息就被投递到对应的队列。服务器必须实现 `direct` 类型交换器，包含一个空白字符串名称的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键。

  ```shell
  # $channel 信道实例，第一个参数为消息内容，第二个参数交换器，第三个参数是路由键
  $channel->basic_publish($msg, '', 'queue_name');
  ```

* `fanout`

  这种类型的交换器会将收到的消息广播到绑定的队列上。消息通信模式很简单：当发送一条消息到 `fanout` 交换器时，它会把消息投递给所有附加在此交换器上的队列。

* `topic`

  使得来自不同源头的消息能够到达同一个队列。

* `headers`

  `headers` 交换器允许匹配 AMQP 消息的 `headers` 而非路由键。除此之外，`headers` 交换器和 `direct` 交换器完全一致，但性能会差很多。 因此它并不太实用，而且几乎再也用不到了

### 消息持久化

#### 消息持久化原理

默认情况下，重启 `RabbitMQ` 服务器后，队列和交换器就都消失了（连同里面的消息）。**每个队列和交换器的 `durable` 属性。该熟悉默认情况为 `false` **，它决定了 `RabbitMQ` 是否需要在崩溃或者重启之后重新创建队列（或者交换器）。将它设置为 `true`，就不需要在服务器断电后重新创建队列和交换器了。

在消息发布前，**通过把它的"投递模式"（delivery mode）选项设置为 2 来吧消息标记成持久化。到目前为止，消息还只是被表示为持久化的，它还必须被发布到持久化的交换器中到达持久化的队列中才行**。如果不是这样的话，则包含持久化消息的队列（或交换器）会在 `Rabbit` 崩溃重启后不复存在，从而导致消息成为了孤儿。即，**如果消息想要从 `Rabbit` 崩溃中恢复，那么消息必须：**

* 把它的投递模式选项设置为 2 （持久）
* 发送到持久化的交换器
* 到达持久化的队列

`RabbitMQ` 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上一个持久化日志文件。当发布一条持久性消息到持久性交换器上时，`Rabbit` 会在消息提交到日志文件后才发送响应。之后，这条消息如果路由到了非持久队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复。一旦从持久化队列中消费了一条持久性消息，并且确认了它，`RabbitMQ` 会在持久化日中把这条消息标记为等待垃圾手机。在消费持久性消息前，如果 `RabbitMQ` 重启的话，服务器会自动重建交换器和队列及绑定，重放持久性日志文件中的消息到合适的队列或者交换器上（取决于服务器宕机时，消息处在路由过程的那个环节）

#### 消息持久化缺点

* 写入磁盘要比存入内存中慢不止一点，而且会极大地减少 `RabbitMQ` 服务器每秒可处理的消息总数。使用持久化机制而导致消息吞吐量降低至少 10 倍的情况并不少见。

* 持久性消息在 `RabbitMQ` 内建集群环境下工作的并不好。虽然 `RabbitMQ` 集群允许和集群中的任意节点的任一队列进行通信，但是事实上那些队列均匀地分布在各个节点而没有冗余（集中中任何一个队列都没有备份的拷贝）。如果运行特定队列的集群节点崩溃了，那么直到节点恢复前，这个队列也就从整个集群中消失了（如果队列是可持久化的）。更重要的是，当节点宕机是，其上的队列也都不可用了，而且持久化队列也无法重建。这就会导致消息丢失。

  