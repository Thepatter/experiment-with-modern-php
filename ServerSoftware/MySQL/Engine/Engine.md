### Engine

#### Engine

##### 表信息

在文件系统中，MySQL 将每个数据库保存为数据目录的一个子目录。创建表时，MySQL 会在数据库子目录下创建一个和表同名的 .frm 文件保存表的定义。

MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台相关。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是 Server 层统一处理的

可以查询 INFORMATION_SCHEMA 获取表或执行以下查询查看表详情

```mysql
show table status like 'user'\G
```

包含以下信息：

|      名称       |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
|      Name       |                             表名                             |
|     Engine      |                 表存储引擎，5.0 之前为 Type                  |
|   Row_format    |                行格式，不同引擎支持不同行格式                |
|      Rows       |      表中行数，依据存储引擎，该值可能是确值也可能是估值      |
| Avg_row_length  |                     平均每行包含的字节数                     |
|   Data_length   |               表数据的最大容量（以字节为单位）               |
| Max_data_length |             表数据的最大容量，该值和存储引擎有关             |
|  Index_length   |                  索引的大小（以字节为单位）                  |
|    Data_free    | 对于 MyISAM，表示已分配未使用的空间，该空间包括了志气删除的行，以及后续可以被 INSERT 利用的空间 |
| Auto_increment  |                  下一个 AUTO_INCREMENT 的值                  |
|   Create_time   |                           建表时间                           |
|   Update_time   |                      表数据最后更新时间                      |
|   Check_time    | 使用 CHECK TABLE 命令或 m yisamchk 工具最后一次检查表的时间  |
|    Collation    |               表的默认字符集和字符序列排序规则               |
| Create_options  |                    创建表时指定的其他选项                    |
|     Comment     |           其他额外信息，默认存储的是建表时带的注释           |

#### MyISAM

##### 特性

5.1 及之前的版本中，是默认的存储引擎。提供了：全文索引、压缩、空间函数（GIS），但不支持事务和行锁，崩溃后无法安全恢复。MyISAM 会存储表的确切行数，表信息中的 Rows 是个精确值

###### 加锁与并发

对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加拍他锁。但在表有读取查询的同时，也可以往表中插入新的记录（并发插入，**CONCURRENT INSERT**）

###### 修复

对于 MyISAM 表，MySQL 可以手工活自动执行检查和修复操作（非事务恢复及崩溃恢复）。执行表的修复可能导致一些数据丢失，而且修复操作非常慢。

```mysql
# 检查表错误
check table table_name;
# 修复表
repair table table_name;
```

如果 MySQL 服务器已经关闭，可以通过 *myisamchk* 命令行工具检查和修复

###### 索引

对于 **BLOB**、**TEXT** 等长字段，也可以基于其前 500 个字符创建索引。支持基于分词创建全文索引

###### 延迟更新索引键

创建 MyISAM 表的时候，如果指定了『DELAY_KEY_WRITE』选项，在每次修改执行完成时，不会立刻将数据写入磁盘，而是会写到内存中的键缓冲区（in-memory key buffer），只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。

可以极大提升写入性能，但是在奔溃时会造成索引破坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置

```mysql
# 建表时指定
create table table_name() engine=myisam delay_key_write=1;
# 修改表
alter table table_name delay_key_write=1;
```

##### 存储

会将表存储在两个文件中：数据文件和索引文件，分别以 .MYD 和 .MYI 为扩展名

可以包含动态或静态（长度固定）行，会根据表的定义来采用行格式。可以存储的行数，受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。

5.0 中，表如果是变长行，则默认支持 256T 数据（指向数据记录的指针长度是 6 个字节），5.0 之前，指针长度默认是 4 字节，只支持 4 GB 数据。所有的版本都支持 8 字节的指针，要改变 MyISAM 表指针的长度（跳高或调低）通过修改『MAX_ROWS』和『AVG_ROW_LENGTH』选项的值，两者相乘就是表可能达到的最大大小。修改这两个参数会导致重建整个表和表的所有索引。

##### 压缩表

如果表在创建并导入数据后，不会再进行修改操作，可以采用 MyISAM 压缩表。

可以使用 *myisampack* 对 MyISAM 表进行压缩（即打包 pack）。压缩表不能进行修改（除非先将表解压缩，修改数据，再压缩）压缩表可以减少磁盘占用，可以减少磁盘 I/O，从而提供查询性能。压缩表支持索引，但索引是只读的。

压缩表中的记录是独立压缩的，读取单行的时候不需要解压整个表（甚至也不解压行所在的整个页面）

##### 行格式

对于 MyISAM 表，可选的值为

###### Dynamic

行长度可变，一般包含可变长度的字段，如 VARCHAR 或 BLOB

###### Fixed

行长度是固定的，只包含固定长度的列

###### Compress

只在压缩表中存在

##### 性能

数据以紧密格式存储，在某些场景下的性能很好。MyISAM有一些服务器级别的性能扩展限制，比如对索引键缓冲区（key cache）的 Mutex 锁，MariaDB 基于段（segment）的索引键缓冲区机制来避免该问题。

但 MyISAM 最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处于 Locked 状态，那么毫无疑问表锁就是罪魁祸首。 

#### Archive

不是一个事务型引擎，是一个针对高速插入和压缩做了优化的简单引擎。只支持 **INSERT**、**SELECT** 操作，5.1 之前不支持索引。会缓存所有的写并利用 zlib 对插入的行进行压缩，所以比 MyISAM 表的磁盘 I/O 更少。但是每次 **SELECT** 查询都需要执行全表扫描。适合日志和数据采集类应用

支持行级锁和专用的缓冲区，可以实现高并发的插入。在一个查询开始直到返回表中存在的所有行数之前，会阻止其他的 **SELECT** 执行，以实现一致性读。实现了批量插入在完成之前对读操作是不可见的。模仿了事务和 MVCC 一些特性。

#### Blackhole

没有实现任何的存储机制，它会丢弃所有插入的数据，不做任何保存。但是服务器会记录表的日志，可以作为复制拓扑的中间转储。

#### CSV

可以将普通的 CSV 文件作为表处理，不支持索引。可以将 Execl 等电子表格软件中的数据存储为为 CSV 文件，然后复制到数据目录下，就能在 MySQL 中打开使用。

如果将数据写入到一个 CSV 引擎表。其他的外部程序也能立即从表的数据文件中读取 CSV 格式的数据。因此 CSV 引起可以作为一种数据交换的机制

#### Federated

Federated 引擎是访问其他 MySQL 服务器的一个代理，它会创建一个到远程 MySQL 服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。最初设计该存储引擎是为了和企业级数据库如Microsoft SQL Server 和 Oracle 的类似特性竞争的，可以说更多的是一种市场行为。尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。MariaDB 使用了它的一个后续改进版本，叫做 FederatedX。

#### Memory

如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表（以前也叫做HEAP表）是非常有用的。Memory 表至少比 MyISAM 表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘 I/O。Memory 表的结构在重启以后还会保留，但数据会丢失。

Memroy 表在很多场景可以发挥作用：

* 用于查找（lookup）或映射（mapping）表
* 用于缓存周期性聚合数据的结构
* 用于保存数据分析中产生的中间数据

Memory 表支持 Hash 索引，因此查找操作非常快。虽然 Memory 表的速度非常快，但还是无法取代传统的基于磁盘的表。Memroy 表是表级锁，因此并发写入的性能较低。它不支持 **BLOB** 或 **TEXT** 类型的列，并且每行的长度是固定的，所以即使指定了 **VARCHAR** 列，实际存储时也会转换成 **CHAR**，这可能导致部分内存的浪费（其中一些限制在 Percona 版本已经解决）。

#### Merge

Merge引擎是MyISAM引擎的一个变种。Merge表是由多个MyISAM表合并而来的虚拟表。如果将MySQL用于日志或者数据仓库类应用，该引擎可以发挥作用。但是引入分区功能后，该引擎已经被放弃