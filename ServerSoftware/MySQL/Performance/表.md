## 表相关

### 分区表

#### 概述

分区功能并不是在存储引擎层完成的，不是只有 InnoDB 存储引擎支持分区，MyISAM、NDB 等都支持。5.1 版本增加了对分区的支持，分区的过程是将一个表或索引分解成多个更小部分。就访问数据库的应用从逻辑上，只有一个表或一个索引，但在物理上这个表或索引可能由数十个物理分区组成，每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

mysql 支持的分区类型为水平分区，并不支持垂直分区。mysql 的数据库分区是局部分区索引，一个分区中即存放了数据又存放了索引，而全局分区是指，数据存放在各个分区中，但所有数据的索引放在一个对象中，目前 mysql 数据库还不支持全局分区

```mysql
# 查看是否包含 partition 支持
show plugins
```

分区可能会给某些 SQL 语句性能带来提高，但是分区主要用于数据库高可用性的管理。当前支持分区类型：

* RANGE 分区

  行数据基于属于一个给定连续区间的列值被放入分区，5.5 开始支持 RANGE CLOUMNS 分区

* LIST 分区

  类似 RANGE，LIST 分区面向的是离散的值，5.5 开始支持

* HASH 分区

  根据用户自定义的表达式的返回值来进行分区，返回值不能是负数

* KEY 分区

  根据数据库提供的哈希汗水来进行分区

不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引可以是允许 NULL 值的，并且分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。如果建表时没有指定主键，唯一索引，可以知道任何一个列为分区列。一个分区会生成一个 `.ibd` 文件

在 RANGE 分区下，null 值被放入最左边分区，如果删除这个分区，将删除包含 null 值的记录，LIST 分区下要使用 NULL，必须显式定义哪个丰南区存放 NULL 值，HASH 和 KEY 对于 NULL 值的记录返回为 0.

#### 分区类型

##### RANGE 分区

```mysql
# 基于 id 列的分区，< 10 数据出入 p0 分区 10 - 20 插入 p1 分区
create table t(id int) engine=innodb partition by range(id)(partition p0 values less than (10), partition p1 values less than (20));
```

可以通过插入 `information_schema` 架构下 `partitions` 表来查看每个分区的信息：

```mysql
select * from information_schema.PARTITIONS where table_schema=database() AND table_name='t'\G;
```

对插入的值应该严格遵守分区的定义，当插入一个不在分区中定义的值时，会抛出异常

```
ERROR 1526 (HY000): Table has no partition for value 30
```

```mysql
# 添加 maxvalue 分区
alter table t add partition(partition p2 values less than maxvalue);
# 删除指定分区
alter table sales drop partition p2009;
```

对于 RANGE 分区的查询，优化器只能对 `YEAR()`，`TO_DAYS()`，`TO_SECONDS()`，`UNIX_TIMESTAMP()` 这类汗水进行优化选择。

##### List 分区

```mysql
create table t (a int, b int) engine=innodb partition by list(b)(partition p0 values in (1,3,5,7,9), partition p1 values in (0,2,4,6,8));
```

在使用 INSERT 插入多个行数据的过程中遇到分区未定义的值时，MyISAM 会将之前的行数据全部插入，Innodb 则将其视为一个事务

##### HASH 和 LINEAR HASH 分区

HASH 分区目的是将数据均匀地分布到预先定义的各个分区中，保证分区的数据量大致相等。在 RANGE 和 LIST 分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在 HASH 分区中，MySQL 自动完成这些工作，用户所要做的只是基于将要进行哈希分区的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。

使用 hash 分区，`partition by hash(expr)`，`expr` 返回一个整数的表达式，可以是字段类型为整型的列名。需要添加一个 `partitions num` 子句，不添加则分区数量默认为 1.

```mysql
# 创建 hash 分区，分区按日期列 b
create table t_hash(a int, b datetime) engine=innodb partition by hash (year(b)) partitions 4;
```

LINEAR HASH 分区，它使用一种更加复杂的算法来确定新行插入到已经分区的表中的位置。语法与 hash 类型，除了将 hash 改成 linear hash，优势在于，curd 更快，适合处理含有大量数据的表，缺点，分布不如 hash 分区均衡

即使使用自增主键做 hash 分区也不能保证分区数据的均匀，插入的自增 ID 并非总是连续的

##### key 分区

key 分区类似 hash 分区，key 使用数据库提供的函数进行分区，支持 linear key 分区。

##### COLUMNS 分区

columns 分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得，不需要转化为整型，range columns 分区可以对多个列的值进行分区，支持数据类型：所有的整型，日期类型（DATE，DATETIME），字符串（CHAR，VARCHAR，BINARY，VARBINARY）

```mysql
# 日期分区
partition by range columns (B)(partition p0 values less than('2019-09-01'), partition p1 values less than('2020-09-01'));
# 字符串分区
partition by list columns(city)(partition pEgion_1 values in('a', 'b'));
# 多个列进行分区
partition by range columns(a,b,c)(partition p0 values less than(5,10,'ggg'));
```

#### 子分区

是在分区的基础上再进行分区，允许在 RANGE 和 LIST 分区上再进行 HASH 和 KEY 的子分区，使用 SUBPARTITION

```mysql
create table ts(
	a int,
	b date
) engine = innodb
partition by range (year(b))
subpartition by hash(to_days(b))
subpartitions 2 (
	partition p0 values less than (1990),
  partition p1 values less than (2000),
  partition p2 values less than maxvalue);
```

每个子分区的数量必须相同，要在任何分区上使用 SUBPARTITION 来明确定义任何子分区，就必须定义所有的子分区

#### 分区交换数据

5.6 开始支持 `ALTER TABLE ... EXCHAGNE PARTITION` 语法。用来将分区或子分区中的数据与另一个非分区的表中的数据进行交换。如果非分区表中的数据为空，那么相当于将分区中的数据移动道非分区中，若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。该语句必须前置条件：

* 交换的表和分区结构相同，但表不能含有分区
* 在非分区表中的数据必须在交换的分区定义内
* 被交换的表中不能含有外键，或其他表含有对该表的外键引用
* 需要 drop 权限，不会触发交换表和被交换表的触发器，AUTO_INCREMENT 列将被重置

```mysql
alter table e exchange partition p0 with table e2
```

