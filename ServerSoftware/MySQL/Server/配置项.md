### MySQL 配置项

### 参数

当 MySQL 实例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数 `mysql --help | grep my.cnf` 来确认配置文件读取顺序，MySQL 实例可以不需要参数，这时所有的参数值取决于编译 MySQL 时指定的默认值和源代码中指定参数的默认值。

数据库参数为 key/value 对，使用 `show variables` 查看数据库中的所有参数。MySQL 数据库中的参数可以分为：

* 动态（dynamic）参数

  可以在 MySQL 实例运行中进行更改

  ```mysql
  # 配置动态参数
  SET [global | session] system_var_name = expr
  # 等效
  SET [@@global. | @@session. | @@]system_var_name = expr
  ```

* 静态（static）参数

  静态参数在整个实例生命周期内都不得进行更改

对变量的全局值进行了修改，在这次的实例生命周期内都有效，但 MySQL 实例本身并不会对参数文件中的该值进行修改，在下次启动时 MySQL 实例还是会读取参数文件。

### 服务器 SQL 模式

#### SQL 模式概述

MySQL 可以在不同的 SQL 模式下运行，并且可以针对不同的 clients 应用这些模式，具体取决于 `sql_mode` 系统变量。模式会影响 MySQL 支持的 SQL 语法以及它执行的数据验证检查。每种模式都可以独立开启和关闭。使用 `InnoDB` 表时，还要考虑 `innodb_strict_mode` ，5.7.6 以后该值默认开启

SQL 模式可以在运行中设置，支持会话与全局设置，复制分区表时，master 和 slave 上的不同 SQL 模式也会导致问题。为了获得最佳结果，应始终在 master 和 slave 上使用相同的服务器 SQL 模式

#### SQL 模式

* `ALLOW_INVALIDDATES`

  不对日期进行全面检查。仅检查月份是否在 1 ～ 12 的范围内，日期是否在 1～31 的范围内。此模式使用于

  `date` 和 `datetime` ，不适用于 `timestamp` （它总是需要有效的 `date`）

  禁用 `ALLOW_INVALIDDATES` 时，服务器要求月和日值合法，而不仅仅在在 1~12，1～31 的范围内。禁用严格模式后，`2001-04-31` 等无效日期将转换为 `0000-00-00` 并生成警告。启用严格模式后，无效日期会生成错误

* `ANSI_QUOTES`

  将 `"` 视为引用字符，启用后，不能使用双引号引用 `strings`，它们被解释为标识符

* `ERROR_FOR_DIVISION_BY_ZERO`

  对于除 0 的处理，包括 `MOD(N, 0)`，对于数据更改操作插入和更新，其效果取决于是否启用了严格的 SQL 模式。未启用严格模式：未启用该模式，除 0 将插入 NULL 并且不产生警告，启用此模式，则除 0 会插入 NULL 并插上警告）启用严格模式：启用该模式，则除非另外指定 `IGNORE`，否则除 0 会产生错误，对于 `INSERT IGNORE` ，`UPDATE IGNORE`，除 0 将插入 NULL，并产生警告。

  对于 `SELECT` ，除 0 将返回 NULL。启用该模式也会产生警告，无论是否启用严格

  该模式已过时，不是严格模式的一部分，但应该于严格模式结合使用，并且默认情况下处于启用状态。如果在未启用严格模式下启用该模式，则会产生警告。如果启用该模式但未启用严格模式，也会产生警告

* `HIGH_NOT_PRECEDENCE`

  `NOT` 运算法的优先级`NOT a BETWEEN b AND c` 等表达式被解析为 `NOT (a BETWEEN b AND C)`。在某些旧版本中被解析为 `(NOT a) BETWEEN b AND c`。启用该模式，可以获得旧的解析行为。

* `IGNORE_SPACE`

  允许函数和 `(` 之间的空格，这会使函数名被视为保留字（只适用于内置函数名）

* `NO_AUTO_CREATE_USER`

  除非指定了身份验证信息，否则防止 `GRANT` 语句自动创建用户。该语句必须使用 `IDENTIFIED BY` 指定非空秘密或使用 `INENTIFIED WITH` 指定身份验证插件

* `NO_AUTOVALUE_ON_ZERO`

  会影响 `AUTO_INCREMENT` 列的处理，通常可以指定 `null` 或 0 来生成下一个自增值。启用该模式，则传入 0 值时不会生成自增值

* `NO_BACKSLASH_ESCAPES`

  禁止在字符串和标识符中使用 `\` 作为转义字符。启用此模式后，反斜杠就像其他任何一个普通字符一样

* `NO_DIR_IN_CREATE`

  当创建表时，忽略所有 `INDEX DIRECTORY` 和 `DATA DIRECTORY` 指令。此选项在从属服务器上很有用

* `NO_ENGINE_SUBSTITUTION`

  当诸如 `CREATE TABLE` 或 `ALTER TABLE` 之类的语句指定禁用或未编译的存储引擎时，控制默认存储引擎的自动替换。禁用该模式，对于 `create table` 将使用默认引擎。并且如果所需的引擎不可用，则会发生警告。对于 `alter table` ，发生警告，并且该表未更改，启用该模式，如果所需引擎不可用，不会修改或创建表，则会报错

* `NO_FIELD_OPTIONS`

  不在 `SHOW CREATE TABLE` 的输出中打印特定于 MySQL 的列选项。`mysqldump`在可移植模式下使用此模式，5.7.22 开始，不推荐使用，未来会移除

* `NO_KEY_OPTIONS`

  不在 `SHOW CREATE TABLE` 的输出中打印 MySQL 特定的索引选项。`mysqldump` 在可移植模式下使用此模式。5.7.22 开始，不推荐使用，未来会移除

* `NO_TABLE_OPTIONS`

  不在 `show create table` 的输出中打印特定 MySQL 选项，5.7.22 开始，不推荐使用，未来会移除

* `NO_UNSIGNED_SUBTRACTION`

  `UNSIGNED` 默认情况下，整数值之间的减法会产生无符号结果。如果结果为负，则将导致错误。如果启用了该模式，则结果为负。

  如果将此类操作的结果用于更新 `UNSIGNED` 整数列，则结果将被裁剪为该列类型的最大值，如果启用该模式，则将其裁剪为 0。启用严格模式后，将发生错误，并且列保持不变。

* `NO_ZERO_DATE`

  影响是否允许将 `0000-00-00` 作为有效日期。其效果取决于是否启用了严格模式。如果未启用该模式，`0000-00-00` 允许插入不会产生警告。如果启用该模式 `0000-00-00` 则允许插入会产生警告。如果启用此模式和严格模式，则不允许 `0000-00-00` 插入且会产生错误。除非指定 `IGNORE`，对于 `INSERT IGNORE` 和 `UPDATE IGNORE`，`0000-00-00` 允许插入并产生警告

  不推荐使用，`NO_ZERO_DATE` 不是严格模式的一部分，但应与严格模式结合使用，并且默认情况下处于启用状态。如果未启用严格模式启用了该模式则会产生警告，反之亦然。

* `NO_ZERO_IN_DATE`

  影响服务器是否允许年份部分非零，但月份和日期部分为 0（`2010-00-01`，`2019-01-00`）但不影响 `0000-00-00`，还取决于是否启用严格模式。如果未启用该模式，则允许零部分的日期，并且插入不会产生任何警告。如果启用此模式，则将零部分日期插入为 `0000-00-00` 并产生警告。如果启用了此模式和严格模式，除非同时指定 `IGNORE`，否则不允许插入，且会报错。对于 `INSERT IGNORE` 和 `UPDATE IGNORE`，将零部分的日期作为 `0000-00-00` 插入并产生警告

* `ONLY_FULL_GROUP_BY`

  对于使用 `GROUP BY` 进行查询的 SQL，不允许 `SELECT` 部分出现 `GROUP BY` 中未出现的字段即 `SELECT` 查询的字段必须是 `GROUP BY` 中出现的或者使用聚合函数的或者是具有唯一属性的。不论是否启用该模式，`HAVING` 子句都可以引用别名

* `PADCHAR_TO_FULL_LENGTH`

  默认情况下，在检索时从 `CHAR` 列值修剪尾部空格。启用该模式则不会修剪。并且检索的 `CHAR` 值将填充到其全长。此模式不适用于 `VARCHAR` 列，在检索时保留尾部空格

* `PIPES_AS_CONCAT`

  将 `||` 视为连接操作符与 `CONCAT` 相同，而不是或的同义词

* `REAL_AS_FLOAT`

  将 `REAL` 作为 `FLOAT` 代名词，默认情况下，`REAL` 作为 `DOUBLE` 代名词

* `STRICT_ALL_TABLES`

  为所有存储引擎启用严格的 SQL 模式，无效的数据值将被拒绝

* `STRICT_TRANS_TABLES`

  为事务性存储引擎以及可能的情况下为非事务性存储引擎启用严格的 SQL 模式

* `TIME_TRUNCATE_FRACTIONAL`

  控制是否舍入或截断插入时出现 `TIME`，`DATE`，`TIMESTAMP` 与小数部分秒值转换成具有相同的类型，但更少的小数位的列。默认行为是使用舍入。如果启用此模式，则会发生截断。

#### 组合 SQL 模式

提供以下特殊模式作为模式值组合的简写

* `ANSI`

  相当于 `REAL_AS_FLOAT`，`PIPES_AS_CONCAT`，`ANSI_QUOTES`，`IGNORE_SPACE`，`ONLY_FULL_GROUP_BY`

* `TRADITIONAL`

  相当于 `STRICT_TRANS_TABLES`，`STRICT_ALL_TABLES`，`NO_ZERO_IN_DATE`，`NO_ZERO_DATE`，`ERROR_FOR_DIVISION_BY_ZERO`，`NO_ENGINE_SUBSTITUTION`

#### 严格 SQL 模式

严格模式控制 MySQL 如何处理数据更改语句（INSERT 或 UPDATE）中的无效或缺失值，还会影响 DDL 语句。如果严格模式未启用，则 MySQL 会为无效或缺失的值插入调整后的值并产生警告。在严格模式下，可以通过 `INSERT IGNORE` 和 `UPDATE IGNORE` 来达到此效果。

对于 SELECT 不更改数据的语句，无效值会在严格模式下生成警告，而不是错误。严格模式不影响是否检查外键约束（`foreign_key_cheks`）

`STRICT_ALL_TABLES` 和 `STRICT_TRANS_TABLES` 区别：

* 对于事务表，启用 `STRICT_ALL_TABLES` 时，数据更改语句中的无效值和缺失值会发生错误，该语句被中止并回滚
* 对于非事务表，如果在要插入或更新的第一行中出现错误，则在两种模式下的香味都相同：语句中止且表保持不变。如果该语句插入或修改了多行，并且错误值出现在第二行或更高行中，则结果却居于启用了那种严格模式：对于 `STRICT_ALL_TABLES`，MySQL 返回错误，并忽略其余行。但是，由于已插入或更新了较早的行，因此结果时部分更新的。为了避免这种情况，请使用单行语句，该语句可以在不更改表的情况下中止；对于 `STRICT_TRANS_TABLES`，MySQL 将无效值转换为该列的最接近的有效值，并插入调整后的值。如果缺少值，MySQL 将为列数据类型插入隐式默认值。无论哪种情绪，MySQL 都会生成警告而不是错误，并继续处理该语句

严格模式会影响按零，零日期和日期零和除零处理。

* 严格模式会影响除零的处理，对于数据更改操作：如果未启用严格模式，则除以零将插入 NULL 并且不产生警告；如果启用了严格模式，则除非 IGNORE 同样给出，否则除零会产生错误。对于 `INSERT IGNORE` 和 `UPDATE IGNORE`，除零将插入 NULL 并产生警告；对于 select 除零返回 null。启用严格模式也会引起警告
* 如果未启用严格模式，`0000-00-00` 则允许插入切不会产生任何警告，启用严格模式，不允许插入且会报错，除非指定 `IGNORE` 关键字，将零备份的日期作为 `0000-00-00` 插入并产生警告；严格模式与 `ERROR_FOR_DIVISION_BY_ZERO`，`NO_ZERO_DATE`，`NO_ZERO_IN_DATE` 一起影响

|         操作模式         | 当语句默认为错误时 | 当语句默认为警告时 |
| :----------------------: | :----------------: | :----------------: |
| 未指定 IGNORE 或严格模式 |        错误        |        警告        |
|       指定 IGNORE        |        警告        |        警告        |
|         严格模式         |        错误        |        错误        |
|  指定 IGNORE 的严格模式  |        警告        |        警告        |

当 IGNORE 关键字和严格模式都有效时，IGNORE 优先。