## 创建高性能的索引

索引（在 MySQL 中也称为 “键”（key））是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键。尤其是当表中的数据越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响还不明显，但当数据量逐渐增大时，性能则会急剧下降。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级

### 索引基础

在 MySQL 中，存储引擎现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，MySQL 只能高效地使用索引的最左前缀列。

### 索引类型

索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，索引是存储引擎层而不是服务器层实现的。并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，即不是所有的存储引擎都支持所有类型的索引，即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同

#### B-Tree 索引

NDB 集群存储引擎内部实际上使用了 `T-Tree` 结构存储这种索引，即使其名字是 `BTREE`；`InnoDB` 则使用的是 `B+Tree`。存储引擎以不同的方式使用 `B-Tree` 索引，性能也各有不同。MyISAM 使用前缀压缩技术使得索引更小，但 `InnoDB` 则按照原数据格式进程存储。MyISAM 索引通过数据的物理位置引用被索引的行，而 `InnoDB` 则根据主键引用被索引的行。

`B-Tree` 通常意味着所有的值都是按顺序存储的，并且每个叶子页到跟的距离相同。

*B+Tree上的索引数据结构*

![](../Images/Performance/B+Tree上的索引数据结构.png)

存储引擎不需要进行全表扫描来获取需要的数据，从索引的根节点开始进行搜索：根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限，最终找到对应的值。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。

索引对多个值进行排序的依据是 `CREATE TABLE` 语句中定义索引时列的顺序。B-Tree 索引适合用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀的查找。因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用域查询中的 `OREDR BY` 操作（按顺序查找）。即，如果 `B-Tree` 可以按照某种方式查找到值，就可以按照这种方式用于排序。

##### B-Tree 索引限制

* 如果不是按照索引的最左列开始查找，则无法使用索引。
* 不能跳过索引中的列
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询

#### 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同的键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针

在 MySQL 中，只有 Memory 引擎显式支持哈希索引，哈希索引是 Memory 引擎表的默认索引类型。Memory 引擎同时也支持 B-Tree 索引。Memory 引擎是支持非唯一哈希索引的（如果多个列的哈希值相同，索引会以链表的方式存储多个记录指针到同一个哈希条目中）。因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，使哈希索引的查找速度非常快。

##### 哈希索引限制

* 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显
* 哈希索引数据并不是按照索引值顺序存储的，所以也无法用于排序
* 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
* 哈希索引只支持等值比较查找，不支持任何范围查询
* 访问哈希索引的数据非常快，除非有很多的哈希冲突（当出现哈希冲突的时候，存储引擎必须遍历链表中的所有的行指针，逐行进行比较，直到找到所有符合条件的行）
* 如果哈希冲突很多的化，一些索引的维护操作的代价也会很高。（如果某个选择性很低的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的应用，冲突越多，代价越大）

NDB 集群引擎也支持唯一哈希索引，且在 NDB 集群引擎中作用非常特殊。

InnoDB 引擎有一个特殊的功能是 “自适应哈希索引”（adaptive hash index）。当 `InnoDB` 注意到某些索引值被使用得非常频繁时，它会在内存中基于 `B-Tree` 索引之上再创建一个哈希索引，这样就让 `B-Tree` 索引页具有哈希索引的一些优点（如快速的哈希查找，这是一个完全自动的、内部的行为，用户无法控制或配置，但可以关闭该功能）

#### 空间数据索引（R-Tree）

MyISAM 表支持空间索引，可以用作地理数据存储，和 `B-Tree` 索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 `MBRCONTAINS()` 等来维护数据，MySQL 的 GIS 支持并不完善，一般不建议使用，开源数据库中对 GIS 的解决方案较好的时 `PostgreSQL` 和 `PostGIS`

#### 全文索引

全文索引时一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔查询等。全文索引类似于搜索引擎做的事情，而不是简单的 `where` 条件匹配

在相同的列上同时创建全文索引和基于值的 `B-Tree` 索引不会有冲突，全文索引适用于 `MATCH AGAINST` 操作，而不是普通的 `WHERE` 条件操作

### 索引的优点

索引可以让服务器快速定位到表的指定位置。但这并不是索引的唯一作用。常见的 `B-Tree` 索引，按照顺序存储数据，所以 MySQL 可以用来做 `ORDER BY` 和 `GROUP BY` 操作。因为数据是有序的，所以 `B-Tree` 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用了索引就能够完成全部查询。

* 索引可以大大减少服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机 I/O 变为顺序 I/O

#### 索引的 “三星系统”

* 索引将相关的记录放到一起则获得一星
* 如果索引中的数据顺序和查找中的排列顺序一致则获得二星
* 如果索引中的列包含了查询中需要的全部列则获得三星

索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是最有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价随之增长。这种情况下，则需要一种技术可以直接区分查询需要的一组数据

如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引

### 高性能索引策略

#### 独立的列

如果查询中的列不是独立的，则 MySQL 就不会使用索引。”独立的列“ 指的是索引列不能是表达式的一部分，也不能是函数的参数

下面的查询无法用到 `actor_id` 列的索引

```mysql
select actor_id from sakila.actor where actor_id + 1 = 5;
```

下面的查询也无法用到索引

```mysql
select * from t where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10
```

应该养成简化 WHERE 条件的习惯，始终将索引列放到单独比较符号的一侧

#### 前缀索引和索引选择性

