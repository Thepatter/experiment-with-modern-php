### 备份

#### 备份建议

复制不是备份，RAID 陈列也不是备份，也不是备份的替代品。最基本的，备份仅是数据的一个副本，但受限于应用程序的要求，存储引擎架构，以及系统配置等因素，会让复制一份数据变得困难。备份建议：

* 在生产实践中，对于大数据库来说，物理备份是必需的：逻辑备份太慢并受到资源限制，从逻辑备份中恢复需要很长时间。基于快照的备份（`Percona XtraBackup` 和 `MySQL Enterprise Backup`）和较小的数据库，逻辑备份可以很好的胜任
* 保留多个备份集
* 定期从逻辑备份（或物理备份）中抽取数据进行恢复测试
* 保存二进制日志以用于基于故障时间点的恢复，至少可以从最近两次物理备份中做基于时间点的恢复，这样可以在保持主库运行且不应用任何二进制日志的情况下创建一个备库。备份二进制日志与过期设置无关，二进制日志备份需要保存足够长的时间，以便能从最近的逻辑备份进行恢复
* 完全不借助备份工具本身来监控备份和备份的过程。需要另外验证备份是否正常
* 通过演练整个恢复过程来测试备份和恢复。测算恢复所需要的资源（CPU、磁盘空间、实际时间，以及网络带宽）
* 备份安全性

一般来说，能承受的数据丢失越多，备份越简单。如果有非常苛刻的需求，要确保能恢复所有数据，备份就很困难。基于故障时间点的恢复有：

* 一个宽松的故障时间点恢复需求意味着需要重建数据，直到足够接近问题发生的时刻
* 一个硬性的需求意味着不能容忍丢失任何一个已提交的事务

#### 在线备份与离线备份

如果可能，关闭 MySQL 做备份是最简单最安全的，也是所有获取一致性副本的方法中最好的，而且损坏或不一致的风险最小。（但在高负载和高数据量下关闭和重启 MySQL 可能会花费很长一段时间）。在众多的备份方法中，一个最大问题就是它们会使用 `FLUSH TABLES WITH READ LOCK` 操作。这会导致 MySQL 关闭并锁住所有的表，将 MyISAM 的数据文件刷新到磁盘上，并且刷新查询缓存。避免使用 `FLUSH TABLES WITH READ LOCK` 的最好方法是只使用 `InnoDB` 表。

##### 逻辑备份

逻辑备份即导出，将数据包含在一种 MySQL 能够解析的格式中，要么是 SQL，要么是以某个符号分割的文本，由 `mysqldump` 生成的逻辑备份并不一定是文本文件。SQL 导出会包含许多不同的字符集，同样也会包含二进制数据，这些数据并不是有效的字符。对于许多编辑器来说，文件行也可能会太长。但是，大多数这样的文件还是可以被编辑器打开和读取，特别是 `mysqldump` 使用了 `--hex-blob` 选项时，逻辑备份有如下优缺点：

* 逻辑备份是可以用编辑器或 `grep` ，`sed` 之类的命令查看和操作的普通文件当需要恢复数据或只想查看数据但不恢复时，这非常有帮助
* 恢复非常简单（`source`，`mysqlimport`）
* 可以通过网络来备份和恢复
* 可以在 RDS 中这样不能访问底层文件系统的系统中使用
* 与存储引擎无关。因为从 MySQL 服务器中提取数据而生成，消除了底层数据存储和不同
* 避免数据损坏
* 必须由数据库服务器完成生成逻辑备份的工作，因此要使用更多的 CPU 周期
* 逻辑备份在某些场景下比数据库文件本身更大。ASCII 形式的数据吧总是和存储引擎存储数据一样高效。
* 无法保证导出后再还原出来的一定是同样的数据（浮点表示问题，软件 bug等）
* 不确定的还原时间：从逻辑备份中还原需要 MySQL 加载和解释语句，转化为存储格式，并重建索引，所有这一切会很慢

*使用mysqldump进行逻辑备份*

```shell
# 服务器间复制表
mysqldump --host=server1 test t1 | mysql --host=server 2 test
# 对服务器上所有内容创建逻辑备份到单个文件中，每个库中所有的表在相同逻辑时间点备份,来自不同数据库的各个表未必是相互一致的。使用 --lock-all-tables 选项可以解决
mysqldump -all-databases > all.sql
# 只包含 sakila 数据库的逻辑备份
mysqldump -databases sakila > dump.sql
# 创建只包含 sakila.actor 表的逻辑备份
mysqldump sakila actor > dump.sql
```

对于 `InnoDB` 备份，增加 `--single-transaction` 选项，会使用 `InnoDB` 的 MVCC 特性在单个时间点创建一个一致的备份，而不需要使用 `LOCK TABLES` 锁定所有表。如果增加 `--master-data` 选项，备份还会包括在备份时服务器的二进制日志文件位置，这对基于时间点的恢复和设置复制非常有帮助。（获取日志位置时需要使用 `FLUSH TABLES WITH READ LOCK` 冻结服务器）

##### 物理备份

即直接复制原始文件（磁盘上的文件）的物理备份，基于物理备份有如下优缺点：

* 基于文件的物理备份，只需要将需要的文件复制到其他地方既可以完成备份。不需要其他额外的工作来生成原始文件
* 物理备份的恢复取决于存储引擎（对于 `MyISAM`，只需要简单地复制文件到目的地即可。对于 `InnoDB` 则需要停止数据库服务，可能还要采取其他一些步骤）
* `InnoDB` 和 `MyISAM` 的物理备份非常容易跨平台、操作系统和 `MySQL` 版本（逻辑备份亦如此）
* 从物理备份中恢复会更快，因为 MySQL 服务器不需要执行任何 SQL 或构建索引。如果有很大的 InnoDB 表，无法完全缓存到内存中，则物理备份的恢复会比逻辑备份快很多。
* `InnoDB` 的原始文件通常比相应的逻辑备份要大得多。`InnoDB` 的表空间往往包含很多未使用的空间。还有很多空间被用来做存储数据以外的用途（插入缓冲，回滚段）
* 物理备份不总是可以跨平台、操作系统以及 `MySQL` 版本。文件名大小写敏感和浮点格式是可能会遇到麻烦。很可能因浮点格式不同而不能移动文件到另一个系统

物理备份通常更加简单高效（会更容易出错）。对于需要长期保留的备份，或者是满足法律合规要求的备份，尽量不要完全依赖物理备份。至少每隔一段时间还是需要做一次逻辑备份。除非经过测试，不要假定备份（特别是物理备份）是正常的。对于 `InnoDB` 来说，这意味着需要启动一个 `MySQL` 实例，执行 `InnoDB` 恢复操作，然后运行 `CHECK TABLES` (或对文件运行 `innocheksum`)，对于 `MyISAM`，可以运行 `CHECK TABLES` ，或者使用 `mysqlcheck`（会对所有表执行 `check tables` 操作）

##### 备份内容

恢复的需求决定需要备份什么。最简单的策略是只备份数据和表定义，但这是一个最低的要求。在生产环境中恢复数据库一般需要更多的工作。MySQL 备份需要考虑的几点：

* 非显著数据

  不要忘记那些容易被忽略的数据：二进制日志和 `InnoDB` 事务日志

* 代码

  现代的 `MySQL` 服务器可以存储许多代码（触发器和存储过程）。如果备份了 `mysql` 数据库，那么大部分这类代码也就备份了，但如果 需要还原单个业务数据库会比较麻烦，因为这个数据库中的部分 ”数据“，例如存储过程，实际是存放在 `mysql` 数据库中的

* 复制配置

  如果恢复一个涉及复制关系的服务器，应该备份所有与复制相关的文件（二进制日志、中继日志、日志索引文件和 `.info` 文件。至少应该包含 `show master status` 或 `show slave status` 的输出）执行 `FLUSH LOGS` 也非常有好处，可以让 MySQL 从一个新的二进制日志开始。从日志文件的开头做基于故障时间点的恢复要比从中间更容易

##### 数据一致性

当备份时，应当考虑是否需要数据在指定时间点一致。`InnoDB` 存储引擎下，只要在服务器上使用 `REPEATABLE READ` 事务隔离级别，并且没有任何 DDL，则能保证一致性，以及基于时间点的快照，且在备份过程中不会阻塞任何后续工作。

##### 文件一致性

每个文件的内部一致性也非常重要，并且所有要备份的文件相互间也应一致。如果是在不同的时间复制相关的文件，它们彼此可能也不一致（`MyISAM` 的 `.MYD` 和 `.MYI` 文件）`InnoDB` 如果检测到不一致或损坏，会记录错误日志并让服务器崩溃。

对于非事务性存储引擎，如 MyISAM 可能的选项是锁住并刷新表。这意味着要么用 `LOCK TABLES` 和 `FLUSH TABLES` 结合的方法以使服务器将内存中的变更刷新到磁盘上，一旦刷新完成，便可以安全地复制 MyISAM 的原始文件。

对于 `InnoDB`，确保文件在磁盘上一致性更困难。即使使用 `FLUSH TABLES WITH READ LOCK`，`InnoDB` 依旧在后台运行：插入缓存、日志和写线程继续将变更合并到日志和表空间文件中。这些线程设计上是异步的，与 `LOCK TABLES` 无关。因此不仅需要确保每个文件内部是一致的，还需要同时复制同一个时间点的日志和表空间文件。如果在备份时有其他线程在修改文件，或在与表空间文件不同的时间点备份日志文件，会在恢复后再次因系统损坏而告终，可以通过以下方式规避：

* 等待直到 `InnoDB` 的清除线程和插入缓冲合并线程完成。观察 `SHOW  INNODB STATUS`，当没有脏缓存或挂起的写时，就可以复制文件。但可能需要很长时间，因为 `InnoDB` 的后台线程涉及太多的干扰而不太安全。
* 在一个类似 LVM 的系统中获取数据和日志文件一致的快照，必须让数据和日志文件在快照时相互一致；
* 发送一个 STOP 信号给 MySQL，做备份，然后再发送一个 CONT 信号来再次唤醒。

### 恢复

#### 从备份中恢复

如何恢复数据取决于怎么备份的。可能需要以下部分或全部步骤：

* 停止 MySQL 服务器
* 记录服务器的配置和文件权限
* 将数据从备份中移到 MySQL 数据目录
* 改变配置
* 改变文件权限
* 以限制访问模式重启服务器，等待完成启动
* 载入逻辑备份文件
* 检查和重放二进制日志
* 检测已经还原的数据
* 以完全权限重启服务器

#### 恢复物理备份

是否需要关闭 MySQL 取决于存储引擎。MyISAM 文件一般相互独立，即使服务器正在运行，简单地复制每个表的 `.frm`、`.MYI`、`.MYD` 文件也可以正常操作。一旦有任何对此表的查询，或者其他会导致服务器访问此表的操作，MySQL 都会立刻找到这些表。如果在复制这些文件时表是打开的，会有麻烦，因此操作前要么删除或重命名该表，要么使用 `LOCK TABLES` 和 `FLUSH TABLES` 来关闭它。

`InnoDB` 取决于表空间。如果所有表都存储在单个表空间，就必须关闭 `MySQL`，复制或移动文件到正确位置上，然后重启。同样也需要 `InnoDB` 的事务日志文件与表空间文件匹配。如果文件不匹配（替换了表空间文件，但没有替换事务日志文件）`InnoDB` 将会拒绝启动。如果每个表存储在单个表空间中（`InnoDB` 将每个表的数据和索引存储于一个 `.ibd` 文件中）可以在服务器运行时通过复制这些文件来备份和还原单个表，但不想 `MyISAM` 中那样简单。

还原物理备份后应仔细检测MySQL错误日志，对每个数据库运行 `SHOW TABLE STATUS` 来再次检测错误日志

#### 还原逻辑备份

需要使用 MySQL 服务器本身来加载数据到表中。在加载导出文件之前，应该查看文件多大，服务器加载一个巨大的导出文件的代价很大。加载巨大的文件对于一些存储引擎也有影响（在单个事务中加载 100GB 数据到 InnoDB 会造成巨大的回滚段导致问题）应该以可控大小的块来加载，并且逐个提交事务

##### 加载SQL文件

```shell
# MySQL 客户端
$ mysql < sakila-backup.sql
# MySQL 命令行
mysql> SET SQL_LOG_BIN = 0;
mysql> SOURCE sakila-backup.sql;
mysql> SET SQL_LOG_BIN = 1;
```

如果备份做过压缩，不要分别解压缩。应该在单个操作中完成解压缩和加载

```shell
gunzip -c sakila-backup.sql.gz | mysql
```

使用命名管道解压并导入

```shell
mkfifo /tmp/recover.fifo
chmod 666 /tmp/recover.fifo
gunzip -c ~/db.gz > /tmp/recover.fifo
mysql>source /tmp/recover.fifo;
```

##### 加载符号分割文件

如果是通过 `SELECT INTO OUTFILE` 导出的符号分隔文件，可以使用 `LOAD DATA INFILE` 通过相同的参数来加载。也可以用 `mysqlimport` ，这是 `LOAD DATA INFILE` 的一个包装。

```
mysql> SET SQL_LOG_BIN = 0;
mysql> LOAD DATA INFILE '/tmp/txt' INTO TABLE sakila.payment;
```

#### 基于时间点的恢复

对 MySQL 做基于时间点的恢复常见的方法是还原最近一次全备份，然后从那个时间点开始重放二进制日志。只要有二进制日志，就可以恢复到任何希望的时间点。缺点是二进制日志重放可能会是一个很慢的过程。流程大致如下：

1.停止服务器，防止更多修改

2.在要恢复的服务器的 `my.cnf` 中提交配置以静止正常连接

```ini
skip-networking
socket=/tmp/mysql_recover.sock
```

3.启动服务器

4.从二进制中分出需要重放和忽略的语句

5.重放二进制日志

```
mysqlbinlog --database=sakil /var/log/mysql/mysql-bin.000215 --stop-position=352 | mysql -uroot -p
mysqlbinlog --database=sakil /var/log/mysql/mysql-bin.000215 --start-position=429 | mysql -uroot -p
```

##### 用于快速恢复的延时复制

如果有一个延时的备库，并且在备库执行问题语句之前就发现了问题，那么基于时间点的恢复就更快更容易了：

1.停止备库

2.用 `START SLAVE UNTIL` 来重放事件直到要执行问题语句

```mysql
START SLAVE 
    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = gtid_set
          |   MASTER_LOG_FILE = 'log_name', MASTER_LOG_POS = log_pos
          |   RELAY_LOG_FILE = 'log_name', RELAY_LOG_POS = log_pos
start slave until master_log_file = 'master-bin.000010', master_log_pos = 2223;
```

3.跳过语句

```mysql
mysql>SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1
```

或者使用 `change master to` 来前移备库在日志中的位置。

4.开始复制

##### 使用日志服务器进行恢复

`mysqlbinlog` 可能会有一些导致异常行为的bug和不常见的情况。使用日志服务器进行恢复比 `mysqlbinlog` 更灵活更简单，可以做更复杂的过滤。假定要恢复误删除的 `payment` 表，一般步骤：

1.将需要恢复的服务器为 server1

2.在另一台 server2 服务器上恢复备份。在这台服务器上运行恢复进程

3.配置 server2 为 server1 的日志服务器（主从即 blockhone 引擎）

4.配置 server2 复制过滤规则

```ini
replicate-do-table=sakila.payment
```

5.重启 server2，然后用 `CHANGE MASTER TO` 来让它称为日志服务器的备库。配置二进制日志坐标

6.检测 server2 的 `show slave status`

7.找到二进制日志中问题语句的位置，在 server2 上执行 `START SLAVE UNTIL` 来重放事件直到该位置

8.在 server2 上用 `STOP SLAVE` 停掉复制进程。现在应该有被删除表，现在从库停止在被删除之前的时间点

9.将所需表从 server2 复制到 server1

基于语句的二进制日志在重放过程如果有多表更新操作，可能造成数据不一致，基于行的日志重放过程不会出现数据不一致

### InnoDB 崩溃恢复

`InnoDB` 在每次启动时都会检测数据和日志文件，以确认是否需要执行恢复过程。而且，`InnoDB` 的恢复过程并不是恢复数据，而是根据日志文件将事务应用到数据文件，将未提交的变更从数据文件回滚。

`InnoDB` 损坏有三种主要类型，它们对数据恢复有着不同程度的要求

* 二级索引损坏

  一般可以用 `OPTIMIZE TABLE` 来修复损坏的二级索引；也可以用 `SELECT INTO OUTFILE`，删除和重建表，然后 `LOAD DATA INFILE` 的方法（构建一个信标重建受影响的索引，来修复损坏的索引数据）

* 聚簇索引损坏

  使用 `innodb_force_recovery` 选项来导出表。有时导出过程会让 `InnoDB` 崩溃，如果出现这样的情况，或许需要跳过导致崩溃的损坏页以导出其他的记录。聚簇索引的损坏比二级索引更能修复

* 损坏系统结构

  系统结构包括 `InnoDB` 事务日志、表空间的撤销日志（undo log）区域和数据字典。这种损坏可能需要做整个数据库的导出和还原，因为 `InnoDB` 内部绝大部分的工作都可能受到影响



